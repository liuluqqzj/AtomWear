; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\output\ble_advdata.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\ble_advdata.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\Software\Include -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Device\Nordic\nRF51822\Include -DNRF51 -DBOARD_PCA10001 -DNRF51_DBG --omf_browse=.\output\ble_advdata.crf ..\..\..\Software\Source\ble_lib\ble_advdata.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  name_encode PROC
;;;24     
;;;25     static uint32_t name_encode(const ble_advdata_t * p_advdata,
000000  b5fe              PUSH     {r1-r7,lr}
;;;26                                 uint8_t *             p_encoded_data,
;;;27                                 uint8_t *             p_len)
;;;28     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;29         uint32_t err_code;
;;;30         uint16_t name_length = BLE_GAP_ADV_MAX_SIZE - (2 + *p_len);
000008  7820              LDRB     r0,[r4,#0]
00000a  1c80              ADDS     r0,r0,#2
00000c  211f              MOVS     r1,#0x1f
00000e  1a08              SUBS     r0,r1,r0
000010  b280              UXTH     r0,r0
000012  9000              STR      r0,[sp,#0]
;;;31         uint8_t  adv_data_format;
;;;32     
;;;33         // Get GAP device name.
;;;34         err_code = sd_ble_gap_device_name_get(&p_encoded_data[*p_len + 2], &name_length);
000014  7821              LDRB     r1,[r4,#0]
000016  1c89              ADDS     r1,r1,#2
000018  1988              ADDS     r0,r1,r6
00001a  4669              MOV      r1,sp
00001c  df6d              SVC      #0x6d
00001e  9001              STR      r0,[sp,#4]
;;;35         if (err_code != NRF_SUCCESS)
000020  9801              LDR      r0,[sp,#4]
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L1.42|
;;;36         {
;;;37             return err_code;
000026  9801              LDR      r0,[sp,#4]
                  |L1.40|
;;;38         }
;;;39     
;;;40         // Compute length and type of name field.
;;;41         if ((p_advdata->short_name_len != 0) && (name_length > p_advdata->short_name_len))
;;;42         {
;;;43             name_length     = p_advdata->short_name_len;
;;;44             adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
;;;45         }
;;;46         else
;;;47         {
;;;48             adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
;;;49         }
;;;50         
;;;51         // Complete name field in encoded data.
;;;52         p_encoded_data[(*p_len)++] = name_length + 1;
;;;53         p_encoded_data[(*p_len)++] = adv_data_format;
;;;54         (*p_len) += name_length;
;;;55         
;;;56         return NRF_SUCCESS;
;;;57     }
000028  bdfe              POP      {r1-r7,pc}
                  |L1.42|
00002a  7868              LDRB     r0,[r5,#1]            ;41
00002c  2800              CMP      r0,#0                 ;41
00002e  d008              BEQ      |L1.66|
000030  7868              LDRB     r0,[r5,#1]            ;41
000032  4669              MOV      r1,sp                 ;41
000034  8809              LDRH     r1,[r1,#0]            ;41
000036  4288              CMP      r0,r1                 ;41
000038  da03              BGE      |L1.66|
00003a  7868              LDRB     r0,[r5,#1]            ;43
00003c  9000              STR      r0,[sp,#0]            ;43
00003e  2708              MOVS     r7,#8                 ;44
000040  e000              B        |L1.68|
                  |L1.66|
000042  2709              MOVS     r7,#9                 ;48
                  |L1.68|
000044  4668              MOV      r0,sp                 ;52
000046  8800              LDRH     r0,[r0,#0]            ;52
000048  1c40              ADDS     r0,r0,#1              ;52
00004a  b2c1              UXTB     r1,r0                 ;52
00004c  7822              LDRB     r2,[r4,#0]            ;52
00004e  1c50              ADDS     r0,r2,#1              ;52
000050  7020              STRB     r0,[r4,#0]            ;52
000052  54b1              STRB     r1,[r6,r2]            ;52
000054  7821              LDRB     r1,[r4,#0]            ;53
000056  1c48              ADDS     r0,r1,#1              ;53
000058  7020              STRB     r0,[r4,#0]            ;53
00005a  5477              STRB     r7,[r6,r1]            ;53
00005c  7821              LDRB     r1,[r4,#0]            ;54
00005e  4668              MOV      r0,sp                 ;54
000060  8800              LDRH     r0,[r0,#0]            ;54
000062  1808              ADDS     r0,r1,r0              ;54
000064  7020              STRB     r0,[r4,#0]            ;54
000066  2000              MOVS     r0,#0                 ;56
000068  e7de              B        |L1.40|
;;;58     
                          ENDP

                  appearance_encode PROC
;;;59     
;;;60     static uint32_t appearance_encode(uint8_t * p_encoded_data, uint8_t * p_len)
00006a  b5f8              PUSH     {r3-r7,lr}
;;;61     {
00006c  4605              MOV      r5,r0
00006e  460c              MOV      r4,r1
;;;62         uint32_t err_code;
;;;63         uint16_t appearance;
;;;64     
;;;65         // Check for buffer overflow.
;;;66         if ((*p_len) + 4 > BLE_GAP_ADV_MAX_SIZE)
000070  7820              LDRB     r0,[r4,#0]
000072  1d00              ADDS     r0,r0,#4
000074  281f              CMP      r0,#0x1f
000076  dd01              BLE      |L1.124|
;;;67         {
;;;68             return NRF_ERROR_DATA_SIZE;
000078  200c              MOVS     r0,#0xc
                  |L1.122|
;;;69         }
;;;70     
;;;71         // Get GAP appearance field.
;;;72         err_code = sd_ble_gap_appearance_get(&appearance);
;;;73         if (err_code != NRF_SUCCESS)
;;;74         {
;;;75             return err_code;
;;;76         }
;;;77         
;;;78         // Encode Length, AD Type and Appearance.
;;;79         p_encoded_data[(*p_len)++] = 3;
;;;80         p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_APPEARANCE;
;;;81     
;;;82         (*p_len) += uint16_encode(appearance, &p_encoded_data[*p_len]);
;;;83         
;;;84         return NRF_SUCCESS;
;;;85     }
00007a  bdf8              POP      {r3-r7,pc}
                  |L1.124|
00007c  4668              MOV      r0,sp                 ;72
00007e  df69              SVC      #0x69                 ;72
000080  4606              MOV      r6,r0                 ;72
000082  2e00              CMP      r6,#0                 ;73
000084  d001              BEQ      |L1.138|
000086  4630              MOV      r0,r6                 ;75
000088  e7f7              B        |L1.122|
                  |L1.138|
00008a  2103              MOVS     r1,#3                 ;79
00008c  7822              LDRB     r2,[r4,#0]            ;79
00008e  1c50              ADDS     r0,r2,#1              ;79
000090  7020              STRB     r0,[r4,#0]            ;79
000092  54a9              STRB     r1,[r5,r2]            ;79
000094  2119              MOVS     r1,#0x19              ;80
000096  7822              LDRB     r2,[r4,#0]            ;80
000098  1c50              ADDS     r0,r2,#1              ;80
00009a  7020              STRB     r0,[r4,#0]            ;80
00009c  54a9              STRB     r1,[r5,r2]            ;80
00009e  7820              LDRB     r0,[r4,#0]            ;82
0000a0  1941              ADDS     r1,r0,r5              ;82
0000a2  4668              MOV      r0,sp                 ;82
0000a4  8800              LDRH     r0,[r0,#0]            ;82
0000a6  f7fffffe          BL       uint16_encode
0000aa  7821              LDRB     r1,[r4,#0]            ;82
0000ac  1840              ADDS     r0,r0,r1              ;82
0000ae  7020              STRB     r0,[r4,#0]            ;82
0000b0  2000              MOVS     r0,#0                 ;84
0000b2  e7e2              B        |L1.122|
;;;86     
                          ENDP

                  uint8_array_encode PROC
;;;87     
;;;88     static uint32_t uint8_array_encode(const uint8_array_t * p_uint8_array,
0000b4  b5f8              PUSH     {r3-r7,lr}
;;;89                                        uint8_t               adv_type,
;;;90                                        uint8_t *             p_encoded_data,
;;;91                                        uint8_t *             p_len)
;;;92     {
0000b6  4605              MOV      r5,r0
0000b8  460f              MOV      r7,r1
0000ba  4616              MOV      r6,r2
0000bc  461c              MOV      r4,r3
;;;93         // Check parameter consistency.
;;;94         if (p_uint8_array->p_data == NULL)
0000be  6868              LDR      r0,[r5,#4]
0000c0  2800              CMP      r0,#0
0000c2  d101              BNE      |L1.200|
;;;95         {
;;;96             return NRF_ERROR_INVALID_PARAM;
0000c4  2007              MOVS     r0,#7
                  |L1.198|
;;;97         }
;;;98     
;;;99         // Check for buffer overflow.
;;;100        if ((*p_len) + 2 + p_uint8_array->size > BLE_GAP_ADV_MAX_SIZE)
;;;101        {
;;;102            return NRF_ERROR_DATA_SIZE;
;;;103        }
;;;104    
;;;105        // Encode Length and AD Type.
;;;106        p_encoded_data[(*p_len)++] = 1 + p_uint8_array->size;
;;;107        p_encoded_data[(*p_len)++] = adv_type;
;;;108        
;;;109        // Encode array.
;;;110        memcpy(&p_encoded_data[*p_len], p_uint8_array->p_data, p_uint8_array->size);
;;;111        (*p_len) += p_uint8_array->size;
;;;112        
;;;113        return NRF_SUCCESS;
;;;114    }
0000c6  bdf8              POP      {r3-r7,pc}
                  |L1.200|
0000c8  7820              LDRB     r0,[r4,#0]            ;100
0000ca  1c80              ADDS     r0,r0,#2              ;100
0000cc  8829              LDRH     r1,[r5,#0]            ;100
0000ce  1840              ADDS     r0,r0,r1              ;100
0000d0  281f              CMP      r0,#0x1f              ;100
0000d2  dd01              BLE      |L1.216|
0000d4  200c              MOVS     r0,#0xc               ;102
0000d6  e7f6              B        |L1.198|
                  |L1.216|
0000d8  7828              LDRB     r0,[r5,#0]            ;106
0000da  1c40              ADDS     r0,r0,#1              ;106
0000dc  b2c1              UXTB     r1,r0                 ;106
0000de  7822              LDRB     r2,[r4,#0]            ;106
0000e0  1c50              ADDS     r0,r2,#1              ;106
0000e2  7020              STRB     r0,[r4,#0]            ;106
0000e4  54b1              STRB     r1,[r6,r2]            ;106
0000e6  7821              LDRB     r1,[r4,#0]            ;107
0000e8  1c48              ADDS     r0,r1,#1              ;107
0000ea  7020              STRB     r0,[r4,#0]            ;107
0000ec  5477              STRB     r7,[r6,r1]            ;107
0000ee  882a              LDRH     r2,[r5,#0]            ;110
0000f0  7823              LDRB     r3,[r4,#0]            ;110
0000f2  1998              ADDS     r0,r3,r6              ;110
0000f4  6869              LDR      r1,[r5,#4]            ;110
0000f6  f7fffffe          BL       __aeabi_memcpy
0000fa  7820              LDRB     r0,[r4,#0]            ;111
0000fc  7829              LDRB     r1,[r5,#0]            ;111
0000fe  1840              ADDS     r0,r0,r1              ;111
000100  7020              STRB     r0,[r4,#0]            ;111
000102  2000              MOVS     r0,#0                 ;113
000104  e7df              B        |L1.198|
;;;115    
                          ENDP

                  tx_power_level_encode PROC
;;;116    
;;;117    static uint32_t tx_power_level_encode(int8_t    tx_power_level,
000106  b530              PUSH     {r4,r5,lr}
;;;118                                          uint8_t * p_encoded_data,
;;;119                                          uint8_t * p_len)
;;;120    {
000108  4603              MOV      r3,r0
;;;121        // Check for buffer overflow.
;;;122        if ((*p_len) + 3 > BLE_GAP_ADV_MAX_SIZE)
00010a  7810              LDRB     r0,[r2,#0]
00010c  1cc0              ADDS     r0,r0,#3
00010e  281f              CMP      r0,#0x1f
000110  dd01              BLE      |L1.278|
;;;123        {
;;;124            return NRF_ERROR_DATA_SIZE;
000112  200c              MOVS     r0,#0xc
                  |L1.276|
;;;125        }
;;;126    
;;;127        // Encode TX Power Level.
;;;128        p_encoded_data[(*p_len)++] = 2;
;;;129        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
;;;130        p_encoded_data[(*p_len)++] = (uint8_t)tx_power_level;
;;;131        
;;;132        return NRF_SUCCESS;
;;;133    }
000114  bd30              POP      {r4,r5,pc}
                  |L1.278|
000116  2402              MOVS     r4,#2                 ;128
000118  7815              LDRB     r5,[r2,#0]            ;128
00011a  1c68              ADDS     r0,r5,#1              ;128
00011c  7010              STRB     r0,[r2,#0]            ;128
00011e  554c              STRB     r4,[r1,r5]            ;128
000120  240a              MOVS     r4,#0xa               ;129
000122  7815              LDRB     r5,[r2,#0]            ;129
000124  1c68              ADDS     r0,r5,#1              ;129
000126  7010              STRB     r0,[r2,#0]            ;129
000128  554c              STRB     r4,[r1,r5]            ;129
00012a  7815              LDRB     r5,[r2,#0]            ;130
00012c  1c68              ADDS     r0,r5,#1              ;130
00012e  7010              STRB     r0,[r2,#0]            ;130
000130  554b              STRB     r3,[r1,r5]            ;130
000132  2000              MOVS     r0,#0                 ;132
000134  e7ee              B        |L1.276|
;;;134    
                          ENDP

                  uuid_list_sized_encode PROC
;;;135    
;;;136    static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000136  b5ff              PUSH     {r0-r7,lr}
;;;137                                           uint8_t                         adv_type,
;;;138                                           uint8_t                         uuid_size,
;;;139                                           uint8_t *                       p_encoded_data,
;;;140                                           uint8_t *                       p_len)
;;;141    {
000138  b087              SUB      sp,sp,#0x1c
00013a  4606              MOV      r6,r0
00013c  461d              MOV      r5,r3
00013e  9c10              LDR      r4,[sp,#0x40]
;;;142        int     i;
;;;143        bool    is_heading_written = false;
000140  2000              MOVS     r0,#0
000142  9006              STR      r0,[sp,#0x18]
;;;144        uint8_t start_pos = *p_len;
000144  7820              LDRB     r0,[r4,#0]
000146  9005              STR      r0,[sp,#0x14]
;;;145        
;;;146        for (i = 0; i < p_uuid_list->uuid_cnt; i++)
000148  2700              MOVS     r7,#0
00014a  e047              B        |L1.476|
                  |L1.332|
;;;147        {
;;;148            uint32_t   err_code;
;;;149            uint8_t    encoded_size;
;;;150            ble_uuid_t uuid = p_uuid_list->p_uuids[i];
00014c  00b9              LSLS     r1,r7,#2
00014e  6870              LDR      r0,[r6,#4]
000150  1841              ADDS     r1,r0,r1
000152  880a              LDRH     r2,[r1,#0]
000154  4668              MOV      r0,sp
000156  8102              STRH     r2,[r0,#8]
000158  8849              LDRH     r1,[r1,#2]
00015a  8141              STRH     r1,[r0,#0xa]
;;;151            
;;;152            // Find encoded uuid size.
;;;153            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
00015c  2200              MOVS     r2,#0
00015e  a903              ADD      r1,sp,#0xc
000160  a802              ADD      r0,sp,#8
000162  df54              SVC      #0x54
000164  9004              STR      r0,[sp,#0x10]
;;;154            if (err_code != NRF_SUCCESS)
000166  9804              LDR      r0,[sp,#0x10]
000168  2800              CMP      r0,#0
00016a  d002              BEQ      |L1.370|
;;;155            {
;;;156                return err_code;
00016c  9804              LDR      r0,[sp,#0x10]
                  |L1.366|
;;;157            }
;;;158            
;;;159            // Check size.
;;;160            if (encoded_size == uuid_size)
;;;161            {
;;;162                uint8_t heading_bytes = (is_heading_written) ? 0 : 2;
;;;163                
;;;164                // Check for buffer overflow
;;;165                if (*p_len + encoded_size + heading_bytes > BLE_GAP_ADV_MAX_SIZE)
;;;166                {
;;;167                    return NRF_ERROR_DATA_SIZE;
;;;168                }
;;;169                
;;;170                if (!is_heading_written)
;;;171                {
;;;172                    // Write AD structure heading.
;;;173                    (*p_len)++;
;;;174                    p_encoded_data[(*p_len)++] = adv_type;
;;;175                    is_heading_written = true;
;;;176                }
;;;177                
;;;178                // Write UUID.
;;;179                err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_len]);
;;;180                if (err_code != NRF_SUCCESS)
;;;181                {
;;;182                    return err_code;
;;;183                }
;;;184                (*p_len) += encoded_size;
;;;185            }
;;;186        }
;;;187        
;;;188        if (is_heading_written)
;;;189        {
;;;190            // Write length.
;;;191            p_encoded_data[start_pos] = (*p_len) - (start_pos + 1);
;;;192        }
;;;193        
;;;194        return NRF_SUCCESS;
;;;195    }
00016e  b00b              ADD      sp,sp,#0x2c
000170  bdf0              POP      {r4-r7,pc}
                  |L1.370|
000172  4668              MOV      r0,sp                 ;160
000174  7b01              LDRB     r1,[r0,#0xc]          ;160
000176  9809              LDR      r0,[sp,#0x24]         ;160
000178  4281              CMP      r1,r0                 ;160
00017a  d12e              BNE      |L1.474|
00017c  9806              LDR      r0,[sp,#0x18]         ;162
00017e  2800              CMP      r0,#0                 ;162
000180  d001              BEQ      |L1.390|
000182  2000              MOVS     r0,#0                 ;162
000184  e000              B        |L1.392|
                  |L1.390|
000186  2002              MOVS     r0,#2                 ;162
                  |L1.392|
000188  9001              STR      r0,[sp,#4]            ;162
00018a  7820              LDRB     r0,[r4,#0]            ;165
00018c  4669              MOV      r1,sp                 ;165
00018e  7b09              LDRB     r1,[r1,#0xc]          ;165
000190  1841              ADDS     r1,r0,r1              ;165
000192  9801              LDR      r0,[sp,#4]            ;165
000194  1808              ADDS     r0,r1,r0              ;165
000196  281f              CMP      r0,#0x1f              ;165
000198  dd01              BLE      |L1.414|
00019a  200c              MOVS     r0,#0xc               ;167
00019c  e7e7              B        |L1.366|
                  |L1.414|
00019e  9806              LDR      r0,[sp,#0x18]         ;170
0001a0  2800              CMP      r0,#0                 ;170
0001a2  d109              BNE      |L1.440|
0001a4  7820              LDRB     r0,[r4,#0]            ;173
0001a6  1c40              ADDS     r0,r0,#1              ;173
0001a8  7020              STRB     r0,[r4,#0]            ;173
0001aa  7822              LDRB     r2,[r4,#0]            ;174
0001ac  1c51              ADDS     r1,r2,#1              ;174
0001ae  9808              LDR      r0,[sp,#0x20]         ;174
0001b0  7021              STRB     r1,[r4,#0]            ;174
0001b2  54a8              STRB     r0,[r5,r2]            ;174
0001b4  2001              MOVS     r0,#1                 ;175
0001b6  9006              STR      r0,[sp,#0x18]         ;175
                  |L1.440|
0001b8  7820              LDRB     r0,[r4,#0]            ;179
0001ba  1942              ADDS     r2,r0,r5              ;179
0001bc  a903              ADD      r1,sp,#0xc            ;179
0001be  a802              ADD      r0,sp,#8              ;179
0001c0  df54              SVC      #0x54                 ;179
0001c2  9004              STR      r0,[sp,#0x10]         ;179
0001c4  9804              LDR      r0,[sp,#0x10]         ;180
0001c6  2800              CMP      r0,#0                 ;180
0001c8  d001              BEQ      |L1.462|
0001ca  9804              LDR      r0,[sp,#0x10]         ;182
0001cc  e7cf              B        |L1.366|
                  |L1.462|
0001ce  7820              LDRB     r0,[r4,#0]            ;184
0001d0  4669              MOV      r1,sp                 ;184
0001d2  7b09              LDRB     r1,[r1,#0xc]          ;184
0001d4  1840              ADDS     r0,r0,r1              ;184
0001d6  7020              STRB     r0,[r4,#0]            ;184
0001d8  bf00              NOP                            ;185
                  |L1.474|
0001da  1c7f              ADDS     r7,r7,#1              ;146
                  |L1.476|
0001dc  8830              LDRH     r0,[r6,#0]            ;146
0001de  42b8              CMP      r0,r7                 ;146
0001e0  dcb4              BGT      |L1.332|
0001e2  9806              LDR      r0,[sp,#0x18]         ;188
0001e4  2800              CMP      r0,#0                 ;188
0001e6  d006              BEQ      |L1.502|
0001e8  7821              LDRB     r1,[r4,#0]            ;191
0001ea  9805              LDR      r0,[sp,#0x14]         ;191
0001ec  1c40              ADDS     r0,r0,#1              ;191
0001ee  1a08              SUBS     r0,r1,r0              ;191
0001f0  b2c1              UXTB     r1,r0                 ;191
0001f2  9805              LDR      r0,[sp,#0x14]         ;191
0001f4  5429              STRB     r1,[r5,r0]            ;191
                  |L1.502|
0001f6  2000              MOVS     r0,#0                 ;194
0001f8  e7b9              B        |L1.366|
;;;196    
                          ENDP

                  uuid_list_encode PROC
;;;197    
;;;198    static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
0001fa  b5ff              PUSH     {r0-r7,lr}
;;;199                                     uint8_t                         adv_type_16,
;;;200                                     uint8_t                         adv_type_128,
;;;201                                     uint8_t *                       p_encoded_data,
;;;202                                     uint8_t *                       p_len)
;;;203    {
0001fc  b081              SUB      sp,sp,#4
0001fe  4607              MOV      r7,r0
000200  4615              MOV      r5,r2
000202  9e0a              LDR      r6,[sp,#0x28]
;;;204        uint32_t err_code;
;;;205        
;;;206        // Encode 16 bit UUIDs.
;;;207        err_code = uuid_list_sized_encode(p_uuid_list,
000204  9600              STR      r6,[sp,#0]
000206  2202              MOVS     r2,#2
000208  4638              MOV      r0,r7
00020a  9b04              LDR      r3,[sp,#0x10]
00020c  9902              LDR      r1,[sp,#8]
00020e  f7fffffe          BL       uuid_list_sized_encode
000212  4604              MOV      r4,r0
;;;208                                          adv_type_16,
;;;209                                          sizeof(uint16_le_t),
;;;210                                          p_encoded_data,
;;;211                                          p_len);
;;;212        if (err_code != NRF_SUCCESS)
000214  2c00              CMP      r4,#0
000216  d002              BEQ      |L1.542|
;;;213        {
;;;214            return err_code;
000218  4620              MOV      r0,r4
                  |L1.538|
;;;215        }
;;;216        
;;;217        // Encode 128 bit UUIDs.
;;;218        err_code = uuid_list_sized_encode(p_uuid_list,
;;;219                                          adv_type_128,
;;;220                                          sizeof(ble_uuid128_t),
;;;221                                          p_encoded_data,
;;;222                                          p_len);
;;;223        if (err_code != NRF_SUCCESS)
;;;224        {
;;;225            return err_code;
;;;226        }
;;;227        
;;;228        return NRF_SUCCESS;
;;;229    }
00021a  b005              ADD      sp,sp,#0x14
00021c  bdf0              POP      {r4-r7,pc}
                  |L1.542|
00021e  9600              STR      r6,[sp,#0]            ;218
000220  2210              MOVS     r2,#0x10              ;218
000222  4629              MOV      r1,r5                 ;218
000224  4638              MOV      r0,r7                 ;218
000226  9b04              LDR      r3,[sp,#0x10]         ;218
000228  f7fffffe          BL       uuid_list_sized_encode
00022c  4604              MOV      r4,r0                 ;218
00022e  2c00              CMP      r4,#0                 ;223
000230  d001              BEQ      |L1.566|
000232  4620              MOV      r0,r4                 ;225
000234  e7f1              B        |L1.538|
                  |L1.566|
000236  2000              MOVS     r0,#0                 ;228
000238  e7ef              B        |L1.538|
;;;230    
                          ENDP

                  conn_int_check PROC
;;;231    
;;;232    static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
00023a  4601              MOV      r1,r0
;;;233    {
;;;234        // Check Minimum Connection Interval.
;;;235        if ((p_conn_int->min_conn_interval < 0x0006) || 
00023c  8808              LDRH     r0,[r1,#0]
00023e  2806              CMP      r0,#6
000240  db08              BLT      |L1.596|
;;;236            (
;;;237                (p_conn_int->min_conn_interval > 0x0c80) && 
000242  8808              LDRH     r0,[r1,#0]
000244  2219              MOVS     r2,#0x19
000246  01d2              LSLS     r2,r2,#7
000248  4290              CMP      r0,r2
00024a  dd05              BLE      |L1.600|
;;;238                (p_conn_int->min_conn_interval != 0xffff)
00024c  8808              LDRH     r0,[r1,#0]
00024e  4ae0              LDR      r2,|L1.1488|
000250  4290              CMP      r0,r2
000252  d001              BEQ      |L1.600|
                  |L1.596|
;;;239            )
;;;240        )
;;;241        {
;;;242            return NRF_ERROR_INVALID_PARAM;
000254  2007              MOVS     r0,#7
                  |L1.598|
;;;243        }
;;;244    
;;;245        // Check Maximum Connection Interval.
;;;246        if ((p_conn_int->max_conn_interval < 0x0006) || 
;;;247            (
;;;248                (p_conn_int->max_conn_interval > 0x0c80) && 
;;;249                (p_conn_int->max_conn_interval != 0xffff)
;;;250            )
;;;251        )
;;;252        {
;;;253            return NRF_ERROR_INVALID_PARAM;
;;;254        }
;;;255    
;;;256        // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
;;;257        if ((p_conn_int->min_conn_interval != 0xffff) &&
;;;258            (p_conn_int->max_conn_interval != 0xffff) &&
;;;259            (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
;;;260        )
;;;261        {
;;;262            return NRF_ERROR_INVALID_PARAM;
;;;263        }
;;;264        
;;;265        return NRF_SUCCESS;
;;;266    }
000256  4770              BX       lr
                  |L1.600|
000258  8848              LDRH     r0,[r1,#2]            ;246
00025a  2806              CMP      r0,#6                 ;246
00025c  db08              BLT      |L1.624|
00025e  8848              LDRH     r0,[r1,#2]            ;248
000260  2219              MOVS     r2,#0x19              ;248
000262  01d2              LSLS     r2,r2,#7              ;248
000264  4290              CMP      r0,r2                 ;248
000266  dd05              BLE      |L1.628|
000268  8848              LDRH     r0,[r1,#2]            ;249
00026a  4ad9              LDR      r2,|L1.1488|
00026c  4290              CMP      r0,r2                 ;249
00026e  d001              BEQ      |L1.628|
                  |L1.624|
000270  2007              MOVS     r0,#7                 ;253
000272  e7f0              B        |L1.598|
                  |L1.628|
000274  8808              LDRH     r0,[r1,#0]            ;257
000276  4ad6              LDR      r2,|L1.1488|
000278  4290              CMP      r0,r2                 ;257
00027a  d008              BEQ      |L1.654|
00027c  8848              LDRH     r0,[r1,#2]            ;258
00027e  4290              CMP      r0,r2                 ;258
000280  d005              BEQ      |L1.654|
000282  8808              LDRH     r0,[r1,#0]            ;259
000284  884a              LDRH     r2,[r1,#2]            ;259
000286  4290              CMP      r0,r2                 ;259
000288  dd01              BLE      |L1.654|
00028a  2007              MOVS     r0,#7                 ;262
00028c  e7e3              B        |L1.598|
                  |L1.654|
00028e  2000              MOVS     r0,#0                 ;265
000290  e7e1              B        |L1.598|
;;;267    
                          ENDP

                  conn_int_encode PROC
;;;268    
;;;269    static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
000292  b5f8              PUSH     {r3-r7,lr}
;;;270                                    uint8_t *                      p_encoded_data,
;;;271                                    uint8_t *                      p_len)
;;;272    {
000294  4606              MOV      r6,r0
000296  460d              MOV      r5,r1
000298  4614              MOV      r4,r2
;;;273        uint32_t err_code;
;;;274    
;;;275        // Check for buffer overflow.
;;;276        if ((*p_len) + 2 + 2 * sizeof(uint16_le_t) > BLE_GAP_ADV_MAX_SIZE)
00029a  7820              LDRB     r0,[r4,#0]
00029c  1d80              ADDS     r0,r0,#6
00029e  281f              CMP      r0,#0x1f
0002a0  d901              BLS      |L1.678|
;;;277        {
;;;278            return NRF_ERROR_DATA_SIZE;
0002a2  200c              MOVS     r0,#0xc
                  |L1.676|
;;;279        }
;;;280        
;;;281        // Check parameters.
;;;282        err_code = conn_int_check(p_conn_int);
;;;283        if (err_code != NRF_SUCCESS)
;;;284        {
;;;285            return err_code;
;;;286        }
;;;287        
;;;288        // Encode Length and AD Type.
;;;289        p_encoded_data[(*p_len)++] = 1 + 2 * sizeof(uint16_le_t);
;;;290        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
;;;291        
;;;292        // Encode Minimum and Maximum Connection Intervals.
;;;293        (*p_len) += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_len]);
;;;294        (*p_len) += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_len]);
;;;295        
;;;296        return NRF_SUCCESS;
;;;297    }
0002a4  bdf8              POP      {r3-r7,pc}
                  |L1.678|
0002a6  4630              MOV      r0,r6                 ;282
0002a8  f7fffffe          BL       conn_int_check
0002ac  4607              MOV      r7,r0                 ;282
0002ae  2f00              CMP      r7,#0                 ;283
0002b0  d001              BEQ      |L1.694|
0002b2  4638              MOV      r0,r7                 ;285
0002b4  e7f6              B        |L1.676|
                  |L1.694|
0002b6  2105              MOVS     r1,#5                 ;289
0002b8  7822              LDRB     r2,[r4,#0]            ;289
0002ba  1c50              ADDS     r0,r2,#1              ;289
0002bc  7020              STRB     r0,[r4,#0]            ;289
0002be  54a9              STRB     r1,[r5,r2]            ;289
0002c0  2112              MOVS     r1,#0x12              ;290
0002c2  7822              LDRB     r2,[r4,#0]            ;290
0002c4  1c50              ADDS     r0,r2,#1              ;290
0002c6  7020              STRB     r0,[r4,#0]            ;290
0002c8  54a9              STRB     r1,[r5,r2]            ;290
0002ca  7822              LDRB     r2,[r4,#0]            ;293
0002cc  1951              ADDS     r1,r2,r5              ;293
0002ce  8830              LDRH     r0,[r6,#0]            ;293
0002d0  f7fffffe          BL       uint16_encode
0002d4  7821              LDRB     r1,[r4,#0]            ;293
0002d6  1840              ADDS     r0,r0,r1              ;293
0002d8  7020              STRB     r0,[r4,#0]            ;293
0002da  7822              LDRB     r2,[r4,#0]            ;294
0002dc  1951              ADDS     r1,r2,r5              ;294
0002de  8870              LDRH     r0,[r6,#2]            ;294
0002e0  f7fffffe          BL       uint16_encode
0002e4  7821              LDRB     r1,[r4,#0]            ;294
0002e6  1840              ADDS     r0,r0,r1              ;294
0002e8  7020              STRB     r0,[r4,#0]            ;294
0002ea  2000              MOVS     r0,#0                 ;296
0002ec  e7da              B        |L1.676|
;;;298    
                          ENDP

                  manuf_specific_data_encode PROC
;;;299    
;;;300    static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
0002ee  b5f8              PUSH     {r3-r7,lr}
;;;301                                               uint8_t *                        p_encoded_data,
;;;302                                               uint8_t *                        p_len)
;;;303    {
0002f0  4605              MOV      r5,r0
0002f2  460e              MOV      r6,r1
0002f4  4614              MOV      r4,r2
;;;304        uint8_t data_size = sizeof(uint16_le_t) + p_manuf_sp_data->data.size;
0002f6  7928              LDRB     r0,[r5,#4]
0002f8  1c80              ADDS     r0,r0,#2
0002fa  b2c7              UXTB     r7,r0
;;;305        
;;;306        // Check for buffer overflow.
;;;307        if ((*p_len) + 2 + data_size > BLE_GAP_ADV_MAX_SIZE)
0002fc  7820              LDRB     r0,[r4,#0]
0002fe  1c80              ADDS     r0,r0,#2
000300  19c0              ADDS     r0,r0,r7
000302  281f              CMP      r0,#0x1f
000304  dd01              BLE      |L1.778|
;;;308        {
;;;309            return NRF_ERROR_DATA_SIZE;
000306  200c              MOVS     r0,#0xc
                  |L1.776|
;;;310        }
;;;311    
;;;312        // Encode Length and AD Type.
;;;313        p_encoded_data[(*p_len)++] = 1 + data_size;
;;;314        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
;;;315        
;;;316        // Encode Company Identifier.
;;;317        (*p_len) += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_len]);
;;;318        
;;;319        // Encode additional manufacturer specific data.
;;;320        if (p_manuf_sp_data->data.size > 0)
;;;321        {
;;;322            if (p_manuf_sp_data->data.p_data == NULL)
;;;323            {
;;;324                return NRF_ERROR_INVALID_PARAM;
;;;325            }
;;;326            memcpy(&p_encoded_data[*p_len], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
;;;327            (*p_len) += p_manuf_sp_data->data.size;
;;;328        }
;;;329        
;;;330        return NRF_SUCCESS;
;;;331    }
000308  bdf8              POP      {r3-r7,pc}
                  |L1.778|
00030a  1c78              ADDS     r0,r7,#1              ;313
00030c  b2c1              UXTB     r1,r0                 ;313
00030e  7822              LDRB     r2,[r4,#0]            ;313
000310  1c50              ADDS     r0,r2,#1              ;313
000312  7020              STRB     r0,[r4,#0]            ;313
000314  54b1              STRB     r1,[r6,r2]            ;313
000316  21ff              MOVS     r1,#0xff              ;314
000318  7822              LDRB     r2,[r4,#0]            ;314
00031a  1c50              ADDS     r0,r2,#1              ;314
00031c  7020              STRB     r0,[r4,#0]            ;314
00031e  54b1              STRB     r1,[r6,r2]            ;314
000320  7822              LDRB     r2,[r4,#0]            ;317
000322  1991              ADDS     r1,r2,r6              ;317
000324  8828              LDRH     r0,[r5,#0]            ;317
000326  f7fffffe          BL       uint16_encode
00032a  7821              LDRB     r1,[r4,#0]            ;317
00032c  1840              ADDS     r0,r0,r1              ;317
00032e  7020              STRB     r0,[r4,#0]            ;317
000330  88a8              LDRH     r0,[r5,#4]            ;320
000332  2800              CMP      r0,#0                 ;320
000334  dd0e              BLE      |L1.852|
000336  68a8              LDR      r0,[r5,#8]            ;322
000338  2800              CMP      r0,#0                 ;322
00033a  d101              BNE      |L1.832|
00033c  2007              MOVS     r0,#7                 ;324
00033e  e7e3              B        |L1.776|
                  |L1.832|
000340  88aa              LDRH     r2,[r5,#4]            ;326
000342  7823              LDRB     r3,[r4,#0]            ;326
000344  1998              ADDS     r0,r3,r6              ;326
000346  68a9              LDR      r1,[r5,#8]            ;326
000348  f7fffffe          BL       __aeabi_memcpy
00034c  7820              LDRB     r0,[r4,#0]            ;327
00034e  7929              LDRB     r1,[r5,#4]            ;327
000350  1840              ADDS     r0,r0,r1              ;327
000352  7020              STRB     r0,[r4,#0]            ;327
                  |L1.852|
000354  2000              MOVS     r0,#0                 ;330
000356  e7d7              B        |L1.776|
;;;332    
                          ENDP

                  service_data_encode PROC
;;;333    
;;;334    static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
000358  b5fe              PUSH     {r1-r7,lr}
;;;335                                        uint8_t *             p_encoded_data,
;;;336                                        uint8_t *             p_len)
;;;337    {
00035a  4607              MOV      r7,r0
00035c  460e              MOV      r6,r1
00035e  4614              MOV      r4,r2
;;;338        uint8_t i;
;;;339    
;;;340        // Check parameter consistency.
;;;341        if (p_advdata->p_service_data_array == NULL)
000360  6b38              LDR      r0,[r7,#0x30]
000362  2800              CMP      r0,#0
000364  d101              BNE      |L1.874|
;;;342        {
;;;343            return NRF_ERROR_INVALID_PARAM;
000366  2007              MOVS     r0,#7
                  |L1.872|
;;;344        }
;;;345        
;;;346        for (i = 0; i < p_advdata->service_data_count; i++)
;;;347        {
;;;348            ble_advdata_service_data_t * p_service_data;
;;;349            uint8_t                      data_size;
;;;350            
;;;351            p_service_data = &p_advdata->p_service_data_array[i];
;;;352            data_size      = sizeof(uint16_le_t) + p_service_data->data.size;
;;;353        
;;;354            // Encode Length and AD Type.
;;;355            p_encoded_data[(*p_len)++] = 1 + data_size;
;;;356            p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SERVICE_DATA;
;;;357            
;;;358            // Encode service UUID.
;;;359            (*p_len) += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_len]);
;;;360            
;;;361            // Encode additional service data.
;;;362            if (p_service_data->data.size > 0)
;;;363            {
;;;364                if (p_service_data->data.p_data == NULL)
;;;365                {
;;;366                    return NRF_ERROR_INVALID_PARAM;
;;;367                }
;;;368                memcpy(&p_encoded_data[*p_len], p_service_data->data.p_data, p_service_data->data.size);
;;;369                (*p_len) += p_service_data->data.size;
;;;370            }
;;;371        }
;;;372        
;;;373        return NRF_SUCCESS;
;;;374    }
000368  bdfe              POP      {r1-r7,pc}
                  |L1.874|
00036a  2000              MOVS     r0,#0                 ;346
00036c  9001              STR      r0,[sp,#4]            ;346
00036e  e032              B        |L1.982|
                  |L1.880|
000370  6b39              LDR      r1,[r7,#0x30]         ;351
000372  220c              MOVS     r2,#0xc               ;351
000374  9801              LDR      r0,[sp,#4]            ;351
000376  4350              MULS     r0,r2,r0              ;351
000378  180d              ADDS     r5,r1,r0              ;351
00037a  7928              LDRB     r0,[r5,#4]            ;352
00037c  1c80              ADDS     r0,r0,#2              ;352
00037e  b2c0              UXTB     r0,r0                 ;352
000380  9000              STR      r0,[sp,#0]            ;352
000382  9800              LDR      r0,[sp,#0]            ;355
000384  1c40              ADDS     r0,r0,#1              ;355
000386  b2c1              UXTB     r1,r0                 ;355
000388  7822              LDRB     r2,[r4,#0]            ;355
00038a  1c50              ADDS     r0,r2,#1              ;355
00038c  7020              STRB     r0,[r4,#0]            ;355
00038e  54b1              STRB     r1,[r6,r2]            ;355
000390  2116              MOVS     r1,#0x16              ;356
000392  7822              LDRB     r2,[r4,#0]            ;356
000394  1c50              ADDS     r0,r2,#1              ;356
000396  7020              STRB     r0,[r4,#0]            ;356
000398  54b1              STRB     r1,[r6,r2]            ;356
00039a  7822              LDRB     r2,[r4,#0]            ;359
00039c  1991              ADDS     r1,r2,r6              ;359
00039e  8828              LDRH     r0,[r5,#0]            ;359
0003a0  f7fffffe          BL       uint16_encode
0003a4  7821              LDRB     r1,[r4,#0]            ;359
0003a6  1840              ADDS     r0,r0,r1              ;359
0003a8  7020              STRB     r0,[r4,#0]            ;359
0003aa  88a8              LDRH     r0,[r5,#4]            ;362
0003ac  2800              CMP      r0,#0                 ;362
0003ae  dd0e              BLE      |L1.974|
0003b0  68a8              LDR      r0,[r5,#8]            ;364
0003b2  2800              CMP      r0,#0                 ;364
0003b4  d101              BNE      |L1.954|
0003b6  2007              MOVS     r0,#7                 ;366
0003b8  e7d6              B        |L1.872|
                  |L1.954|
0003ba  88aa              LDRH     r2,[r5,#4]            ;368
0003bc  7823              LDRB     r3,[r4,#0]            ;368
0003be  1998              ADDS     r0,r3,r6              ;368
0003c0  68a9              LDR      r1,[r5,#8]            ;368
0003c2  f7fffffe          BL       __aeabi_memcpy
0003c6  7820              LDRB     r0,[r4,#0]            ;369
0003c8  7929              LDRB     r1,[r5,#4]            ;369
0003ca  1840              ADDS     r0,r0,r1              ;369
0003cc  7020              STRB     r0,[r4,#0]            ;369
                  |L1.974|
0003ce  9801              LDR      r0,[sp,#4]            ;346
0003d0  1c40              ADDS     r0,r0,#1              ;346
0003d2  b2c0              UXTB     r0,r0                 ;346
0003d4  9001              STR      r0,[sp,#4]            ;346
                  |L1.982|
0003d6  2034              MOVS     r0,#0x34              ;346
0003d8  5dc1              LDRB     r1,[r0,r7]            ;346
0003da  9801              LDR      r0,[sp,#4]            ;346
0003dc  4281              CMP      r1,r0                 ;346
0003de  dcc7              BGT      |L1.880|
0003e0  2000              MOVS     r0,#0                 ;373
0003e2  e7c1              B        |L1.872|
;;;375    
                          ENDP

                  adv_data_encode PROC
;;;376    
;;;377    static uint32_t adv_data_encode(const ble_advdata_t * p_advdata,
0003e4  b5f8              PUSH     {r3-r7,lr}
;;;378                                    uint8_t *             p_encoded_data,
;;;379                                    uint8_t *             p_len)
;;;380    {
0003e6  4604              MOV      r4,r0
0003e8  460f              MOV      r7,r1
0003ea  4616              MOV      r6,r2
;;;381        uint32_t err_code = NRF_SUCCESS;
0003ec  2500              MOVS     r5,#0
;;;382        
;;;383        *p_len = 0;
0003ee  2000              MOVS     r0,#0
0003f0  7030              STRB     r0,[r6,#0]
;;;384        
;;;385        // Encode name.
;;;386        if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
0003f2  7820              LDRB     r0,[r4,#0]
0003f4  2800              CMP      r0,#0
0003f6  d009              BEQ      |L1.1036|
;;;387        {
;;;388            err_code = name_encode(p_advdata, p_encoded_data, p_len);
0003f8  4632              MOV      r2,r6
0003fa  4639              MOV      r1,r7
0003fc  4620              MOV      r0,r4
0003fe  f7fffffe          BL       name_encode
000402  4605              MOV      r5,r0
;;;389            if (err_code != NRF_SUCCESS)
000404  2d00              CMP      r5,#0
000406  d001              BEQ      |L1.1036|
;;;390            {
;;;391                return err_code;
000408  4628              MOV      r0,r5
                  |L1.1034|
;;;392            }
;;;393        }
;;;394        
;;;395        // Encode appearance.
;;;396        if (p_advdata->include_appearance)
;;;397        {
;;;398            err_code = appearance_encode(p_encoded_data, p_len);
;;;399            if (err_code != NRF_SUCCESS)
;;;400            {
;;;401                return err_code;
;;;402            }
;;;403        }
;;;404        
;;;405        // Encode flags.
;;;406        if (p_advdata->flags.size > 0)
;;;407        {
;;;408            err_code = uint8_array_encode(&p_advdata->flags,
;;;409                                          BLE_GAP_AD_TYPE_FLAGS,
;;;410                                          p_encoded_data,
;;;411                                          p_len);
;;;412            if (err_code != NRF_SUCCESS)
;;;413            {
;;;414                return err_code;
;;;415            }
;;;416        }
;;;417        
;;;418        // Encode TX power level.
;;;419        if (p_advdata->p_tx_power_level != NULL)
;;;420        {
;;;421            err_code = tx_power_level_encode(*p_advdata->p_tx_power_level, p_encoded_data, p_len);
;;;422            if (err_code != NRF_SUCCESS)
;;;423            {
;;;424                return err_code;
;;;425            }
;;;426        }
;;;427        
;;;428        // Encode 'more available' uuid list.
;;;429        if (p_advdata->uuids_more_available.uuid_cnt > 0)
;;;430        {
;;;431            err_code = uuid_list_encode(&p_advdata->uuids_more_available,
;;;432                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;433                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;434                                        p_encoded_data,
;;;435                                        p_len);
;;;436            if (err_code != NRF_SUCCESS)
;;;437            {
;;;438                return err_code;
;;;439            }
;;;440        }
;;;441        
;;;442        // Encode 'complete' uuid list.
;;;443        if (p_advdata->uuids_complete.uuid_cnt > 0)
;;;444        {
;;;445            err_code = uuid_list_encode(&p_advdata->uuids_complete,
;;;446                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
;;;447                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
;;;448                                        p_encoded_data,
;;;449                                        p_len);
;;;450            if (err_code != NRF_SUCCESS)
;;;451            {
;;;452                return err_code;
;;;453            }
;;;454        }
;;;455        
;;;456        // Encode 'solicited service' uuid list.
;;;457        if (p_advdata->uuids_solicited.uuid_cnt > 0)
;;;458        {
;;;459            err_code = uuid_list_encode(&p_advdata->uuids_solicited,
;;;460                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
;;;461                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
;;;462                                        p_encoded_data,
;;;463                                        p_len);
;;;464            if (err_code != NRF_SUCCESS)
;;;465            {
;;;466                return err_code;
;;;467            }
;;;468        }
;;;469        
;;;470        // Encode Slave Connection Interval Range.
;;;471        if (p_advdata->p_slave_conn_int != NULL)
;;;472        {
;;;473            err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len);
;;;474            if (err_code != NRF_SUCCESS)
;;;475            {
;;;476                return err_code;
;;;477            }
;;;478        }
;;;479        
;;;480        // Encode Manufacturer Specific Data.
;;;481        if (p_advdata->p_manuf_specific_data != NULL)
;;;482        {
;;;483            err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
;;;484                                                  p_encoded_data,
;;;485                                                  p_len);
;;;486            if (err_code != NRF_SUCCESS)
;;;487            {
;;;488                return err_code;
;;;489            }
;;;490        }
;;;491        
;;;492        // Encode Service Data.
;;;493        if (p_advdata->service_data_count > 0)
;;;494        {
;;;495            err_code = service_data_encode(p_advdata, p_encoded_data, p_len);
;;;496            if (err_code != NRF_SUCCESS)
;;;497            {
;;;498                return err_code;
;;;499            }
;;;500        }
;;;501        
;;;502        return err_code;
;;;503    }
00040a  bdf8              POP      {r3-r7,pc}
                  |L1.1036|
00040c  78a0              LDRB     r0,[r4,#2]            ;396
00040e  2800              CMP      r0,#0                 ;396
000410  d008              BEQ      |L1.1060|
000412  4631              MOV      r1,r6                 ;398
000414  4638              MOV      r0,r7                 ;398
000416  f7fffffe          BL       appearance_encode
00041a  4605              MOV      r5,r0                 ;398
00041c  2d00              CMP      r5,#0                 ;399
00041e  d001              BEQ      |L1.1060|
000420  4628              MOV      r0,r5                 ;401
000422  e7f2              B        |L1.1034|
                  |L1.1060|
000424  88a0              LDRH     r0,[r4,#4]            ;406
000426  2800              CMP      r0,#0                 ;406
000428  dd0a              BLE      |L1.1088|
00042a  4633              MOV      r3,r6                 ;408
00042c  463a              MOV      r2,r7                 ;408
00042e  2101              MOVS     r1,#1                 ;408
000430  1d20              ADDS     r0,r4,#4              ;408
000432  f7fffffe          BL       uint8_array_encode
000436  4605              MOV      r5,r0                 ;408
000438  2d00              CMP      r5,#0                 ;412
00043a  d001              BEQ      |L1.1088|
00043c  4628              MOV      r0,r5                 ;414
00043e  e7e4              B        |L1.1034|
                  |L1.1088|
000440  68e0              LDR      r0,[r4,#0xc]          ;419
000442  2800              CMP      r0,#0                 ;419
000444  d00b              BEQ      |L1.1118|
000446  2000              MOVS     r0,#0                 ;421
000448  68e1              LDR      r1,[r4,#0xc]          ;421
00044a  5608              LDRSB    r0,[r1,r0]            ;421
00044c  4632              MOV      r2,r6                 ;421
00044e  4639              MOV      r1,r7                 ;421
000450  f7fffffe          BL       tx_power_level_encode
000454  4605              MOV      r5,r0                 ;421
000456  2d00              CMP      r5,#0                 ;422
000458  d001              BEQ      |L1.1118|
00045a  4628              MOV      r0,r5                 ;424
00045c  e7d5              B        |L1.1034|
                  |L1.1118|
00045e  8a20              LDRH     r0,[r4,#0x10]         ;429
000460  2800              CMP      r0,#0                 ;429
000462  dd0c              BLE      |L1.1150|
000464  463b              MOV      r3,r7                 ;431
000466  2206              MOVS     r2,#6                 ;431
000468  2102              MOVS     r1,#2                 ;431
00046a  4620              MOV      r0,r4                 ;431
00046c  3010              ADDS     r0,r0,#0x10           ;431
00046e  9600              STR      r6,[sp,#0]            ;431
000470  f7fffffe          BL       uuid_list_encode
000474  4605              MOV      r5,r0                 ;431
000476  2d00              CMP      r5,#0                 ;436
000478  d001              BEQ      |L1.1150|
00047a  4628              MOV      r0,r5                 ;438
00047c  e7c5              B        |L1.1034|
                  |L1.1150|
00047e  8b20              LDRH     r0,[r4,#0x18]         ;443
000480  2800              CMP      r0,#0                 ;443
000482  dd0c              BLE      |L1.1182|
000484  463b              MOV      r3,r7                 ;445
000486  2207              MOVS     r2,#7                 ;445
000488  2103              MOVS     r1,#3                 ;445
00048a  4620              MOV      r0,r4                 ;445
00048c  3018              ADDS     r0,r0,#0x18           ;445
00048e  9600              STR      r6,[sp,#0]            ;445
000490  f7fffffe          BL       uuid_list_encode
000494  4605              MOV      r5,r0                 ;445
000496  2d00              CMP      r5,#0                 ;450
000498  d001              BEQ      |L1.1182|
00049a  4628              MOV      r0,r5                 ;452
00049c  e7b5              B        |L1.1034|
                  |L1.1182|
00049e  8c20              LDRH     r0,[r4,#0x20]         ;457
0004a0  2800              CMP      r0,#0                 ;457
0004a2  dd0c              BLE      |L1.1214|
0004a4  463b              MOV      r3,r7                 ;459
0004a6  2215              MOVS     r2,#0x15              ;459
0004a8  2114              MOVS     r1,#0x14              ;459
0004aa  4620              MOV      r0,r4                 ;459
0004ac  3020              ADDS     r0,r0,#0x20           ;459
0004ae  9600              STR      r6,[sp,#0]            ;459
0004b0  f7fffffe          BL       uuid_list_encode
0004b4  4605              MOV      r5,r0                 ;459
0004b6  2d00              CMP      r5,#0                 ;464
0004b8  d001              BEQ      |L1.1214|
0004ba  4628              MOV      r0,r5                 ;466
0004bc  e7a5              B        |L1.1034|
                  |L1.1214|
0004be  6aa0              LDR      r0,[r4,#0x28]         ;471
0004c0  2800              CMP      r0,#0                 ;471
0004c2  d009              BEQ      |L1.1240|
0004c4  4632              MOV      r2,r6                 ;473
0004c6  4639              MOV      r1,r7                 ;473
0004c8  6aa0              LDR      r0,[r4,#0x28]         ;473
0004ca  f7fffffe          BL       conn_int_encode
0004ce  4605              MOV      r5,r0                 ;473
0004d0  2d00              CMP      r5,#0                 ;474
0004d2  d001              BEQ      |L1.1240|
0004d4  4628              MOV      r0,r5                 ;476
0004d6  e798              B        |L1.1034|
                  |L1.1240|
0004d8  6ae0              LDR      r0,[r4,#0x2c]         ;481
0004da  2800              CMP      r0,#0                 ;481
0004dc  d009              BEQ      |L1.1266|
0004de  4632              MOV      r2,r6                 ;483
0004e0  4639              MOV      r1,r7                 ;483
0004e2  6ae0              LDR      r0,[r4,#0x2c]         ;483
0004e4  f7fffffe          BL       manuf_specific_data_encode
0004e8  4605              MOV      r5,r0                 ;483
0004ea  2d00              CMP      r5,#0                 ;486
0004ec  d001              BEQ      |L1.1266|
0004ee  4628              MOV      r0,r5                 ;488
0004f0  e78b              B        |L1.1034|
                  |L1.1266|
0004f2  2034              MOVS     r0,#0x34              ;493
0004f4  5d00              LDRB     r0,[r0,r4]            ;493
0004f6  2800              CMP      r0,#0                 ;493
0004f8  dd09              BLE      |L1.1294|
0004fa  4632              MOV      r2,r6                 ;495
0004fc  4639              MOV      r1,r7                 ;495
0004fe  4620              MOV      r0,r4                 ;495
000500  f7fffffe          BL       service_data_encode
000504  4605              MOV      r5,r0                 ;495
000506  2d00              CMP      r5,#0                 ;496
000508  d001              BEQ      |L1.1294|
00050a  4628              MOV      r0,r5                 ;498
00050c  e77d              B        |L1.1034|
                  |L1.1294|
00050e  4628              MOV      r0,r5                 ;502
000510  e77b              B        |L1.1034|
;;;504    
                          ENDP

                  advdata_check PROC
;;;505    
;;;506    static uint32_t advdata_check(const ble_advdata_t * p_advdata)
000512  4601              MOV      r1,r0
;;;507    {
;;;508        // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
;;;509        if ((p_advdata->flags.size == 0)      ||
000514  8888              LDRH     r0,[r1,#4]
000516  2800              CMP      r0,#0
000518  d007              BEQ      |L1.1322|
;;;510            (p_advdata->flags.p_data == NULL) ||
00051a  6888              LDR      r0,[r1,#8]
00051c  2800              CMP      r0,#0
00051e  d004              BEQ      |L1.1322|
;;;511            ((p_advdata->flags.p_data[0] & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
000520  6888              LDR      r0,[r1,#8]
000522  7800              LDRB     r0,[r0,#0]
000524  2204              MOVS     r2,#4
000526  4210              TST      r0,r2
000528  d101              BNE      |L1.1326|
                  |L1.1322|
;;;512        )
;;;513        {
;;;514            return NRF_ERROR_INVALID_PARAM;
00052a  2007              MOVS     r0,#7
                  |L1.1324|
;;;515        }
;;;516        
;;;517        return NRF_SUCCESS;
;;;518    }
00052c  4770              BX       lr
                  |L1.1326|
00052e  2000              MOVS     r0,#0                 ;517
000530  e7fc              B        |L1.1324|
;;;519    
                          ENDP

                  srdata_check PROC
;;;520    
;;;521    static uint32_t srdata_check(const ble_advdata_t * p_srdata)
000532  4601              MOV      r1,r0
;;;522    {
;;;523        // Flags shall not be included in the scan response data.
;;;524        if (p_srdata->flags.size > 0)
000534  8888              LDRH     r0,[r1,#4]
000536  2800              CMP      r0,#0
000538  dd01              BLE      |L1.1342|
;;;525        {
;;;526            return NRF_ERROR_INVALID_PARAM;
00053a  2007              MOVS     r0,#7
                  |L1.1340|
;;;527        }
;;;528        
;;;529        return NRF_SUCCESS;
;;;530    }
00053c  4770              BX       lr
                  |L1.1342|
00053e  2000              MOVS     r0,#0                 ;529
000540  e7fc              B        |L1.1340|
;;;531    
                          ENDP

                  ble_advdata_set PROC
;;;532    
;;;533    uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
000542  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;534    {
000544  b093              SUB      sp,sp,#0x4c
000546  460d              MOV      r5,r1
;;;535        uint32_t  err_code;
;;;536        uint8_t   len_advdata = 0;
000548  2100              MOVS     r1,#0
00054a  9112              STR      r1,[sp,#0x48]
;;;537        uint8_t   len_srdata = 0;
00054c  9111              STR      r1,[sp,#0x44]
;;;538        uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
;;;539        uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
;;;540        uint8_t * p_encoded_advdata;
;;;541        uint8_t * p_encoded_srdata;
;;;542    
;;;543        // Encode advertising data (if supplied).
;;;544        if (p_advdata != NULL)
00054e  9813              LDR      r0,[sp,#0x4c]
000550  2800              CMP      r0,#0
000552  d014              BEQ      |L1.1406|
;;;545        {
;;;546            err_code = advdata_check(p_advdata);
000554  9813              LDR      r0,[sp,#0x4c]
000556  f7fffffe          BL       advdata_check
00055a  4604              MOV      r4,r0
;;;547            if (err_code != NRF_SUCCESS)
00055c  2c00              CMP      r4,#0
00055e  d002              BEQ      |L1.1382|
;;;548            {
;;;549                return err_code;
000560  4620              MOV      r0,r4
                  |L1.1378|
;;;550            }
;;;551            
;;;552            err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
;;;553            if (err_code != NRF_SUCCESS)
;;;554            {
;;;555                return err_code;
;;;556            }
;;;557            p_encoded_advdata = encoded_advdata;
;;;558        }
;;;559        else
;;;560        {
;;;561            p_encoded_advdata = NULL;
;;;562        }
;;;563        
;;;564        // Encode scan response data (if supplied).
;;;565        if (p_srdata != NULL)
;;;566        {
;;;567            err_code = srdata_check(p_srdata);
;;;568            if (err_code != NRF_SUCCESS)
;;;569            {
;;;570                return err_code;
;;;571            }
;;;572            
;;;573            err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
;;;574            if (err_code != NRF_SUCCESS)
;;;575            {
;;;576                return err_code;
;;;577            }
;;;578            p_encoded_srdata = encoded_srdata;
;;;579        }
;;;580        else
;;;581        {
;;;582            p_encoded_srdata = NULL;
;;;583        }
;;;584    
;;;585        // Pass encoded advertising data and/or scan response data to the stack.
;;;586        return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
;;;587    }
000562  b015              ADD      sp,sp,#0x54
000564  bdf0              POP      {r4-r7,pc}
                  |L1.1382|
000566  aa12              ADD      r2,sp,#0x48           ;552
000568  a909              ADD      r1,sp,#0x24           ;552
00056a  9813              LDR      r0,[sp,#0x4c]         ;552
00056c  f7fffffe          BL       adv_data_encode
000570  4604              MOV      r4,r0                 ;552
000572  2c00              CMP      r4,#0                 ;553
000574  d001              BEQ      |L1.1402|
000576  4620              MOV      r0,r4                 ;555
000578  e7f3              B        |L1.1378|
                  |L1.1402|
00057a  ae09              ADD      r6,sp,#0x24           ;557
00057c  e000              B        |L1.1408|
                  |L1.1406|
00057e  2600              MOVS     r6,#0                 ;561
                  |L1.1408|
000580  2d00              CMP      r5,#0                 ;565
000582  d013              BEQ      |L1.1452|
000584  4628              MOV      r0,r5                 ;567
000586  f7fffffe          BL       srdata_check
00058a  4604              MOV      r4,r0                 ;567
00058c  2c00              CMP      r4,#0                 ;568
00058e  d001              BEQ      |L1.1428|
000590  4620              MOV      r0,r4                 ;570
000592  e7e6              B        |L1.1378|
                  |L1.1428|
000594  aa11              ADD      r2,sp,#0x44           ;573
000596  a901              ADD      r1,sp,#4              ;573
000598  4628              MOV      r0,r5                 ;573
00059a  f7fffffe          BL       adv_data_encode
00059e  4604              MOV      r4,r0                 ;573
0005a0  2c00              CMP      r4,#0                 ;574
0005a2  d001              BEQ      |L1.1448|
0005a4  4620              MOV      r0,r4                 ;576
0005a6  e7dc              B        |L1.1378|
                  |L1.1448|
0005a8  af01              ADD      r7,sp,#4              ;578
0005aa  e000              B        |L1.1454|
                  |L1.1452|
0005ac  2700              MOVS     r7,#0                 ;582
                  |L1.1454|
0005ae  a810              ADD      r0,sp,#0x40           ;586
0005b0  7903              LDRB     r3,[r0,#4]            ;586
0005b2  463a              MOV      r2,r7                 ;586
0005b4  7a01              LDRB     r1,[r0,#8]            ;586
0005b6  4630              MOV      r0,r6                 ;586
0005b8  df62              SVC      #0x62                 ;586
0005ba  e7d2              B        |L1.1378|
                          ENDP

                  uint16_encode PROC
;;;287     */
;;;288    static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
0005bc  4602              MOV      r2,r0
;;;289    {
;;;290        p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
0005be  700a              STRB     r2,[r1,#0]
;;;291        p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
0005c0  20ff              MOVS     r0,#0xff
0005c2  0200              LSLS     r0,r0,#8
0005c4  4010              ANDS     r0,r0,r2
0005c6  1200              ASRS     r0,r0,#8
0005c8  7048              STRB     r0,[r1,#1]
;;;292        return sizeof(uint16_t);
0005ca  2002              MOVS     r0,#2
;;;293    }
0005cc  4770              BX       lr
;;;294        
                          ENDP

0005ce  0000              DCW      0x0000
                  |L1.1488|
                          DCD      0x0000ffff

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Software\\Source\\ble_lib\\ble_advdata.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_ble_advdata_c_cb25090c____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_ble_advdata_c_cb25090c____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_ble_advdata_c_cb25090c____REVSH|
#line 130
|__asm___13_ble_advdata_c_cb25090c____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

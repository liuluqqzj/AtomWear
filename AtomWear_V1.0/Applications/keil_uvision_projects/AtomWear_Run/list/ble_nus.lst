L 1 "..\..\..\Software\Source\ble_serv\ble_nus.c"
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#include "ble_nus.h"
L 1 "..\..\..\Software\Include\ble_nus.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_srv_nus  Service
N * @{
N * @ingroup ble_sdk_srv
N * @brief  Service module.
N *
N * @details This module implements the Service with an RX and TX characteristics. Data
N *          received will be passed to the application, while data sent will be transferred as 
N *          notifications. 
N *          During initialization it adds the  Service and its characteristics to 
N *          the BLE stack datanuse. 
N *
N * @note The application must propagate BLE stack events to the  Service module by calling
N *       ble_nus_on_ble_evt() from the from the @ref ble_stack_handler callback.
N */
N
N#ifndef BLE_NUS_H__
N#define BLE_NUS_H__
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 410000
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 34 "..\..\..\Software\Include\ble_nus.h" 2
N#include <stdbool.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 410000
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 35 "..\..\..\Software\Include\ble_nus.h" 2
N#include "ble.h"
L 1 "..\..\..\Software\Include\ble.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_COMMON BLE SoftDevice Common
N  @{
N  @defgroup ble_api Events, type definitions and API calls
N  @{
N
N  @brief Module independent events, type definitions and API calls for the S110 SoftDevice.
N
N */
N
N#ifndef BLE_H__
N#define BLE_H__
N
N#include "ble_ranges.h"
L 1 "..\..\..\Software\Include\ble_ranges.h" 1
N/*
N  Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N
N  The information contained herein is confidential property of Nordic Semiconductor. The use,
N  copying, transfer or disclosure of such information is prohibited except by express written
N  agreement with Nordic Semiconductor.
N */
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @defgroup ble_ranges Module specific SVC and event number subranges
N  @{
N
N  @brief Definition of SVC and event number subranges for each API module.
N
N  @note
N  SVCs and event numbers are split into subranges for each API module.
N  Each module receives its entire allocated range of SVC calls, whether implemented or not,
N  but return BLE_ERROR_NOT_SUPPORTED for unimplemented or undefined calls in its range.
N
N  Note that the symbols BLE_<module>_SVC_LAST is the end of the allocated SVC range,
N  rather than the last SVC function call actually defined and implemented.
N
N  Specific SVC and event values are defined in each module's ble_<module>.h file,
N  which defines names of each individual SVC code based on the range start value.
N*/
N
N#ifndef BLE_RANGES_H__
N#define BLE_RANGES_H__
N
N#define BLE_SVC_BASE           0x50
N#define BLE_SVC_LAST           0x5B       /* Total: 12. */
N
N#define BLE_RESERVED_SVC_BASE  0x5C
N#define BLE_RESERVED_SVC_LAST  0x5F       /* Total: 4. */
N
N#define BLE_GAP_SVC_BASE       0x60
N#define BLE_GAP_SVC_LAST       0x7F       /* Total: 32. */
N
N#define BLE_GATTC_SVC_BASE     0x80
N#define BLE_GATTC_SVC_LAST     0x9F       /* Total: 32. */
N
N#define BLE_GATTS_SVC_BASE     0xA0
N#define BLE_GATTS_SVC_LAST     0xAF       /* Total: 16. */
N
N#define BLE_L2CAP_SVC_BASE     0xB0
N#define BLE_L2CAP_SVC_LAST     0xBF       /* Total: 16. */
N
N
N#define BLE_EVT_INVALID        0x00
N
N#define BLE_EVT_BASE           0x01
N#define BLE_EVT_LAST           0x0F       /* Total: 15. */
N
N#define BLE_GAP_EVT_BASE       0x10
N#define BLE_GAP_EVT_LAST       0x2F       /* Total: 32. */
N
N#define BLE_GATTC_EVT_BASE     0x30
N#define BLE_GATTC_EVT_LAST     0x4F       /* Total: 32. */
N
N#define BLE_GATTS_EVT_BASE     0x50
N#define BLE_GATTS_EVT_LAST     0x6F       /* Total: 32. */
N
N#define BLE_L2CAP_EVT_BASE     0x70
N#define BLE_L2CAP_EVT_LAST     0x8F       /* Total: 32.  */
N
N#endif /* BLE_RANGES_H__ */
N
N/**
N  @}
N  @}
N*/
L 22 "..\..\..\Software\Include\ble.h" 2
N#include "ble_types.h"
L 1 "..\..\..\Software\Include\ble_types.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @defgroup ble_types Common types and macro definitions
N  @{
N
N  @brief Common types and macro definitions for the S110 SoftDevice.
N */
N
N#ifndef BLE_TYPES_H__
N#define BLE_TYPES_H__
N
N#include <stdint.h>
N
N/** @addtogroup BLE_COMMON_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_CONN_HANDLES BLE Connection Handles
N * @{ */
N#define BLE_CONN_HANDLE_INVALID 0xFFFF  /**< Invalid Connection Handle. */
N#define BLE_CONN_HANDLE_ALL     0xFFFE  /**< Applies to all Connection Handles. */
N/** @} */
N
N
N/** @defgroup BLE_UUID_VALUES Assigned Values for BLE UUIDs
N * @{ */
N/* Generic UUIDs, applicable to all services */
N#define BLE_UUID_UNKNOWN                              0x0000 /**< Reserved UUID. */
N#define BLE_UUID_SERVICE_PRIMARY                      0x2800 /**< Primary Service. */
N#define BLE_UUID_SERVICE_SECONDARY                    0x2801 /**< Secondary Service. */
N#define BLE_UUID_SERVICE_INCLUDE                      0x2802 /**< Include. */
N#define BLE_UUID_CHARACTERISTIC                       0x2803 /**< Characteristic. */
N#define BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP             0x2900 /**< Characteristic Extended Properties Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_USER_DESC            0x2901 /**< Characteristic User Description Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG        0x2902 /**< Client Characteristic Configuration Descriptor. */
N#define BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG        0x2903 /**< Server Characteristic Configuration Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT  0x2904 /**< Characteristic Presentation Format Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT     0x2905 /**< Characteristic Aggregate Format Descriptor. */
N/* GATT specific UUIDs */
N#define BLE_UUID_GATT                                 0x1801 /**< Generic Attribute Profile. */
N#define BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED  0x2A05 /**< Service Changed Characteristic. */
N/* GAP specific UUIDs */
N#define BLE_UUID_GAP                                  0x1800 /**< Generic Access Profile. */
N#define BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME       0x2A00 /**< Device Name Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE        0x2A01 /**< Appearance Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_PPF               0x2A02 /**< Peripheral Privacy Flag Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 /**< Reconnection Address Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_PPCP              0x2A04 /**< Peripheral Preferred Connection Parameters Characteristic. */
N/** @} */
N
N
N/** @defgroup BLE_UUID_TYPES Types of UUID
N * @{ */
N#define BLE_UUID_TYPE_UNKNOWN       0x00 /**< Invalid UUID type. */
N#define BLE_UUID_TYPE_BLE           0x01 /**< Bluetooth SIG UUID (16-bit). */
N#define BLE_UUID_TYPE_VENDOR_BEGIN  0x02 /**< Vendor UUID types start at this index (128-bit). */
N/** @} */
N
N
N/** @defgroup BLE_APPEARANCES Bluetooth Appearance values
N *  @note Retrieved from http://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml
N * @{ */
N#define BLE_APPEARANCE_UNKNOWN                              0   /**< Unknown. */
N#define BLE_APPEARANCE_GENERIC_PHONE                        64  /**< Generic Phone. */
N#define BLE_APPEARANCE_GENERIC_COMPUTER                     128 /**< Generic Computer. */
N#define BLE_APPEARANCE_GENERIC_WATCH                        192 /**< Generic Watch. */
N#define BLE_APPEARANCE_WATCH_SPORTS_WATCH                   193 /**< Watch: Sports Watch. */
N#define BLE_APPEARANCE_GENERIC_CLOCK                        256 /**< Generic Clock. */
N#define BLE_APPEARANCE_GENERIC_DISPLAY                      320 /**< Generic Display. */
N#define BLE_APPEARANCE_GENERIC_REMOTE_CONTROL               384 /**< Generic Remote Control. */
N#define BLE_APPEARANCE_GENERIC_EYE_GLASSES                  448 /**< Generic Eye-glasses. */
N#define BLE_APPEARANCE_GENERIC_TAG                          512 /**< Generic Tag. */
N#define BLE_APPEARANCE_GENERIC_KEYRING                      576 /**< Generic Keyring. */
N#define BLE_APPEARANCE_GENERIC_MEDIA_PLAYER                 640 /**< Generic Media Player. */
N#define BLE_APPEARANCE_GENERIC_BARCODE_SCANNER              704 /**< Generic Barcode Scanner. */
N#define BLE_APPEARANCE_GENERIC_THERMOMETER                  768 /**< Generic Thermometer. */
N#define BLE_APPEARANCE_THERMOMETER_EAR                      769 /**< Thermometer: Ear. */
N#define BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR            832 /**< Generic Heart rate Sensor. */
N#define BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT    833 /**< Heart Rate Sensor: Heart Rate Belt. */
N#define BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE               896 /**< Generic Blood Pressure. */
N#define BLE_APPEARANCE_BLOOD_PRESSURE_ARM                   897 /**< Blood Pressure: Arm. */
N#define BLE_APPEARANCE_BLOOD_PRESSURE_WRIST                 898 /**< Blood Pressure: Wrist. */
N#define BLE_APPEARANCE_GENERIC_HID                          960 /**< Human Interface Device (HID). */
N#define BLE_APPEARANCE_HID_KEYBOARD                         961 /**< Keyboard (HID Subtype). */
N#define BLE_APPEARANCE_HID_MOUSE                            962 /**< Mouse (HID Subtype). */
N#define BLE_APPEARANCE_HID_JOYSTICK                         963 /**< Joystiq (HID Subtype). */
N#define BLE_APPEARANCE_HID_GAMEPAD                          964 /**< Gamepad (HID Subtype). */
N#define BLE_APPEARANCE_HID_DIGITIZERSUBTYPE                 965 /**< Digitizer Tablet (HID Subtype). */
N#define BLE_APPEARANCE_HID_CARD_READER                      966 /**< Card Reader (HID Subtype). */
N#define BLE_APPEARANCE_HID_DIGITAL_PEN                      967 /**< Digital Pen (HID Subtype). */
N#define BLE_APPEARANCE_HID_BARCODE                          968 /**< Barcode Scanner (HID Subtype). */
N#define BLE_APPEARANCE_GENERIC_GLUCOSE_METER               1024 /**< Generic Glucose Meter. */
N#define BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR      1088 /**< Generic Running Walking Sensor. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE      1089 /**< Running Walking Sensor: In-Shoe. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE      1090 /**< Running Walking Sensor: On-Shoe. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP       1091 /**< Running Walking Sensor: On-Hip. */
N#define BLE_APPEARANCE_GENERIC_CYCLING                     1152 /**< Generic Cycling. */
N#define BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER            1153 /**< Cycling: Cycling Computer. */
N#define BLE_APPEARANCE_CYCLING_SPEED_SENSOR                1154 /**< Cycling: Speed Sensor. */
N#define BLE_APPEARANCE_CYCLING_CADENCE_SENSOR              1155 /**< Cycling: Cadence Sensor. */
N#define BLE_APPEARANCE_CYCLING_POWER_SENSOR                1156 /**< Cycling: Power Sensor. */
N#define BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR        1157 /**< Cycling: Speed and Cadence Sensor. */
N/** @} */
N
N/** @brief Set .type and .uuid fields of ble_uuid_struct to specified uuid value. */
N#define BLE_UUID_BLE_ASSIGN(instance, value) do {\
N            instance.type = BLE_UUID_TYPE_BLE; \
N            instance.uuid = value;} while(0)
X#define BLE_UUID_BLE_ASSIGN(instance, value) do {            instance.type = BLE_UUID_TYPE_BLE;             instance.uuid = value;} while(0)
N
N/** @brief Copy type and uuid members from src to dst ble_uuid_t pointer. Both pointers must be valid/non-null. */
N#define BLE_UUID_COPY_PTR(dst, src) do {\
N            (dst)->type = (src)->type; \
N            (dst)->uuid = (src)->uuid;} while(0)
X#define BLE_UUID_COPY_PTR(dst, src) do {            (dst)->type = (src)->type;             (dst)->uuid = (src)->uuid;} while(0)
N
N/** @brief Copy type and uuid members from src to dst ble_uuid_t struct. */
N#define BLE_UUID_COPY_INST(dst, src) do {\
N            (dst).type = (src).type; \
N            (dst).uuid = (src).uuid;} while(0)
X#define BLE_UUID_COPY_INST(dst, src) do {            (dst).type = (src).type;             (dst).uuid = (src).uuid;} while(0)
N
N/** @brief Compare for equality both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
N#define BLE_UUID_EQ(p_uuid1, p_uuid2) \
N            (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
X#define BLE_UUID_EQ(p_uuid1, p_uuid2)             (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
N
N/** @brief Compare for difference both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
N#define BLE_UUID_NEQ(p_uuid1, p_uuid2) \
N            (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
X#define BLE_UUID_NEQ(p_uuid1, p_uuid2)             (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
N
N/** @} */
N
N/** @brief 128 bit UUID values. */
Ntypedef struct
N{ 
N    unsigned char uuid128[16];
N} ble_uuid128_t;
N
N/** @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs. */
Ntypedef struct
N{
N    uint16_t    uuid; /**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
N    uint8_t     type; /**< UUID type, see @ref BLE_UUID_TYPES. */
N} ble_uuid_t;
N
N
N
N#endif /* BLE_TYPES_H__ */
N
N/**
N  @}
N  @}
N*/
L 23 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gap.h"
L 1 "..\..\..\Software\Include\ble_gap.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_GAP Generic Access Profile (GAP)
N  @{
N  @brief Definitions and prototypes for the GAP interface.
N */
N
N#ifndef BLE_GAP_H__
N#define BLE_GAP_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "nrf_svc.h"
L 1 "..\..\..\Software\Include\nrf_svc.h" 1
N#ifndef NRF_SVC__
N#define NRF_SVC__
N
N#ifdef SVCALL_AS_NORMAL_FUNCTION
S#define SVCALL(number, return_type, signature) return_type signature
N#else
N
N#ifndef SVCALL
N#if defined (__CC_ARM)
X#if 1L
N#define SVCALL(number, return_type, signature) return_type __svc(number) signature
N#elif defined (__GNUC__)
S#define SVCALL(number, return_type, signature) \
S  _Pragma("GCC diagnostic ignored \"-Wreturn-type\"") \
S  _Pragma("GCC diagnostic ignored \"-Wunused-function\"") \
S  __attribute__((naked)) static return_type signature \
S  { \
S    __asm( \
S        "svc %0\n" \
S        "bx r14" : : "I" (number) : "r0" \
S    ); \
S  }
X#define SVCALL(number, return_type, signature)   _Pragma("GCC diagnostic ignored \"-Wreturn-type\"")   _Pragma("GCC diagnostic ignored \"-Wunused-function\"")   __attribute__((naked)) static return_type signature   {     __asm(         "svc %0\n"         "bx r14" : : "I" (number) : "r0"     );   }
S#elif defined (__ICCARM__)
S#define PRAGMA(x) _Pragma(#x)
S#define SVCALL(number, return_type, signature) \
SPRAGMA(swi_number = number) \
S __swi return_type signature;
X#define SVCALL(number, return_type, signature) PRAGMA(swi_number = number)  __swi return_type signature;
S#else
S#define SVCALL(number, return_type, signature) return_type signature  
N#endif
N#endif	// SVCALL
N	
N#endif	// SVCALL_AS_NORMAL_FUNCTION
N#endif	// NRF_SVC__
L 20 "..\..\..\Software\Include\ble_gap.h" 2
N
N/**
N * @brief GAP API SVC numbers.
N */
Nenum BLE_GAP_SVCS
N{
N  SD_BLE_GAP_ADDRESS_SET  = BLE_GAP_SVC_BASE,  /**< Set own Bluetooth Address. */
X  SD_BLE_GAP_ADDRESS_SET  = 0x60,   
N  SD_BLE_GAP_ADDRESS_GET,                      /**< Get own Bluetooth Address. */
N  SD_BLE_GAP_ADV_DATA_SET,                     /**< Set Advertisement Data. */
N  SD_BLE_GAP_ADV_START,                        /**< Start Advertising. */
N  SD_BLE_GAP_ADV_STOP,                         /**< Stop Advertising. */
N  SD_BLE_GAP_CONN_PARAM_UPDATE,                /**< Connection Parameter Update. */
N  SD_BLE_GAP_DISCONNECT,                       /**< Disconnect. */
N  SD_BLE_GAP_TX_POWER_SET,                     /**< Set TX Power. */
N  SD_BLE_GAP_APPEARANCE_SET,                   /**< Set Appearance. */
N  SD_BLE_GAP_APPEARANCE_GET,                   /**< Get Appearance. */
N  SD_BLE_GAP_PPCP_SET,                         /**< Set PPCP. */
N  SD_BLE_GAP_PPCP_GET,                         /**< Get PPCP. */
N  SD_BLE_GAP_DEVICE_NAME_SET,                  /**< Set Device Name. */
N  SD_BLE_GAP_DEVICE_NAME_GET,                  /**< Get Device Name. */
N  SD_BLE_GAP_AUTHENTICATE,                     /**< Initiate Pairing/Bonding. */
N  SD_BLE_GAP_SEC_PARAMS_REPLY,                 /**< Reply with Security Parameters. */
N  SD_BLE_GAP_AUTH_KEY_REPLY,                   /**< Reply with an authentication key. */
N  SD_BLE_GAP_SEC_INFO_REPLY,                   /**< Reply with Security Information. */
N  SD_BLE_GAP_CONN_SEC_GET,                     /**< Obtain connection security level. */
N  SD_BLE_GAP_RSSI_START,                       /**< Start reporting of changes in RSSI. */ 
N  SD_BLE_GAP_RSSI_STOP,                        /**< Stop reporting of changes in RSSI. */ 
N};
N
N
N/** @addtogroup BLE_GAP_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_ERRORS_GAP SVC return values specific to GAP
N * @{ */
N#define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  /**< UUID list does not contain an integral number of UUIDs. */
N#define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  /**< Use of Whitelist not permitted with discoverable advertising. */
N#define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  /**< The upper two bits of the address do not correspond to the specified address type. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ROLES GAP Roles
N * @note Not explicitly used in peripheral API, but will be relevant for central API.
N * @{ */
N#define BLE_GAP_ROLE_INVALID     0x0            /**< Invalid Role. */
N#define BLE_GAP_ROLE_PERIPH      0x1            /**< Peripheral Role. */
N#define BLE_GAP_ROLE_CENTRAL     0x2            /**< Central Role. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_TIMEOUT_SOURCES GAP Timeout sources
N * @{ */
N#define BLE_GAP_TIMEOUT_SRC_ADVERTISEMENT              0x00 /**< Advertisement timeout. */
N#define BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST           0x01 /**< Security request timeout. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADDR_TYPES GAP Address types
N * @{ */
N#define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 /**< Public address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 /**< Random Static address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 /**< Private Resolvable address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 /**< Private Non-Resolvable address. */
N/** @} */
N
N
N/** @brief BLE address length. */
N#define BLE_GAP_ADDR_LEN            6
N
N
N/** @defgroup BLE_GAP_AD_TYPE_DEFINITIONS GAP Advertising and Scan Response Data format
N *  @note Found at https://www.bluetooth.org/Technical/AssignedNumbers/generic_access_profile.htm
N * @{ */
N#define BLE_GAP_AD_TYPE_FLAGS                               0x01 /**< Flags for discoverability. */
N#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 /**< Short local device name. */
N#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 /**< Complete local device name. */
N#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A /**< Transmit power level. */
N#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D /**< Class of device. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E /**< Simple Pairing Hash C. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F /**< Simple Pairing Randomizer R. */
N#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 /**< Security Manager TK Value. */
N#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 /**< Security Manager Out Of Band Flags. */
N#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 /**< Slave Connection Interval Range. */
N#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
N#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
N#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 /**< Service Data. */
N#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 /**< Public Target Address. */
N#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 /**< Random Target Address. */
N#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 /**< Appearance. */
N#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF /**< Manufacturer Specific Data. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_FLAGS GAP Advertisement Flags
N * @{ */
N#define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   /**< LE Limited Discoverable Mode. */
N#define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   /**< LE General Discoverable Mode. */
N#define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   /**< BR/EDR not supported. */
N#define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   /**< Simultaneous LE and BR/EDR, Controller. */
N#define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   /**< Simultaneous LE and BR/EDR, Host. */
N#define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE Limited Discoverable Mode, BR/EDR not supported. */
N#define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE General Discoverable Mode, BR/EDR not supported. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
N * @{ */
N#define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
N#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
N#define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
N /** @}  */
N
N
N/** @brief Maximum size of advertising data in octets. */
N#define  BLE_GAP_ADV_MAX_SIZE       31
N
N
N/** @defgroup BLE_GAP_ADV_TYPES GAP Advertising types
N * @{ */
N#define BLE_GAP_ADV_TYPE_ADV_IND          0x00   /**< Connectable undirected. */
N#define BLE_GAP_ADV_TYPE_ADV_DIRECT_IND   0x01   /**< Connectable directed. */
N#define BLE_GAP_ADV_TYPE_ADV_SCAN_IND     0x02   /**< Scannable undirected. */
N#define BLE_GAP_ADV_TYPE_ADV_NONCONN_IND  0x03   /**< Non connectable undirected. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_FILTER_POLICIES GAP Advertising filter policies
N * @{ */
N#define BLE_GAP_ADV_FP_ANY                0x00   /**< Allow scan requests and connect requests from any device. */
N#define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   /**< Filter scan requests with whitelist. */
N#define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   /**< Filter connect requests with whitelist. */
N#define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   /**< Filter both scan and connect requests with whitelist. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_TIMEOUT_VALUES GAP Advertising timeout values
N * @{ */
N#define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX      180 /**< Maximum advertising time in limited discoverable mode (TGAP(lim_adv_timeout) = 180s in spec (Addendum 2)). */
N#define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED  0 /**< Unlimited advertising in general discoverable mode. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_DISC_MODES GAP Discovery modes
N * @{ */
N#define BLE_GAP_DISC_MODE_NOT_DISCOVERABLE  0x00   /**< Not discoverable discovery Mode. */
N#define BLE_GAP_DISC_MODE_LIMITED           0x01   /**< Limited Discovery Mode. */
N#define BLE_GAP_DISC_MODE_GENERAL           0x02   /**< General Discovery Mode. */
N/** @} */
N
N/** @defgroup BLE_GAP_IO_CAPS GAP IO Capabilities
N * @{ */
N#define BLE_GAP_IO_CAPS_DISPLAY_ONLY      0x00   /**< Display Only. */
N#define BLE_GAP_IO_CAPS_DISPLAY_YESNO     0x01   /**< Display and Yes/No entry. */
N#define BLE_GAP_IO_CAPS_KEYBOARD_ONLY     0x02   /**< Keyboard Only. */
N#define BLE_GAP_IO_CAPS_NONE              0x03   /**< No I/O capabilities. */
N#define BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY  0x04   /**< Keyboard and Display. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_AUTH_KEY_TYPES GAP Authentication Key Types
N * @{ */
N#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   /**< No key (may be used to reject). */
N#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   /**< 6-digit Passkey. */
N#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   /**< Out Of Band data. */
N/** @} */
N
N/** @defgroup BLE_GAP_SEC_STATUS GAP Security status
N * @{ */
N#define BLE_GAP_SEC_STATUS_SUCCESS                0x00  /**< Successful parameters. */
N#define BLE_GAP_SEC_STATUS_TIMEOUT                0x01  /**< Procedure timed out. */
N#define BLE_GAP_SEC_STATUS_PDU_INVALID            0x02  /**< Invalid PDU received. */
N#define BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED   0x81  /**< Passkey entry failed (user cancelled or other). */
N#define BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE      0x82  /**< Out of Band Key not available. */
N#define BLE_GAP_SEC_STATUS_AUTH_REQ               0x83  /**< Authentication requirements not met. */
N#define BLE_GAP_SEC_STATUS_CONFIRM_VALUE          0x84  /**< Confirm value failed. */
N#define BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP       0x85  /**< Pairing not supported.  */
N#define BLE_GAP_SEC_STATUS_ENC_KEY_SIZE           0x86  /**< Encryption key size. */
N#define BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED    0x87  /**< Unsupported SMP command. */
N#define BLE_GAP_SEC_STATUS_UNSPECIFIED            0x88  /**< Unspecified reason. */
N#define BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS      0x89  /**< Too little time elapsed since last attempt. */
N#define BLE_GAP_SEC_STATUS_INVALID_PARAMS         0x8A  /**< Invalid parameters. */
N/** @} */
N
N/** @defgroup BLE_GAP_SEC_STATUS_SOURCES GAP Security status sources
N * @{ */
N#define BLE_GAP_SEC_STATUS_SOURCE_LOCAL           0x00  /**< Local failure. */
N#define BLE_GAP_SEC_STATUS_SOURCE_REMOTE          0x01  /**< Remote failure. */
N/** @} */
N
N/** @defgroup BLE_GAP_CP_LIMITS GAP Connection Parameters Limits
N * @{ */
N#define BLE_GAP_CP_MIN_CONN_INTVL_NONE           0xFFFF  /**< No new minimum connction interval specified in connect parameters. */
N#define BLE_GAP_CP_MIN_CONN_INTVL_MIN            0x0006  /**< Lowest mimimum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
N#define BLE_GAP_CP_MIN_CONN_INTVL_MAX            0x0C80  /**< Highest minimum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_NONE           0xFFFF  /**< No new maximum connction interval specified in connect parameters. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_MIN            0x0006  /**< Lowest maximum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_MAX            0x0C80  /**< Highest maximum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
N#define BLE_GAP_CP_SLAVE_LATENCY_MAX             0x03E8  /**< Highest slave latency permitted, in connection events. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE         0xFFFF  /**< No new supervision timeout specified in connect parameters. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN          0x000A  /**< Lowest supervision timeout permitted, in units of 10 ms, i.e. 100 ms. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX          0x0C80  /**< Highest supervision timeout permitted, in units of 10 ms, i.e. 32 s. */
N/** @} */
N
N
N/**@brief GAP device name maximum writable length. */
N#define BLE_GAP_DEVNAME_MAX_WR_LEN        20
N
N/**@brief GAP device name maximum length. */
N#define BLE_GAP_DEVNAME_MAX_LEN           31
N
N
N/** @defgroup BLE_GAP_CONN_SEC_MODE_SET_MACROS GAP attribute security requirement setters
N *
N * See @ref ble_gap_conn_sec_mode_t.
N * @{ */
N/** @brief Set sec_mode pointed to by ptr to have no access rights.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(ptr)         do {(ptr)->sm = 0; (ptr)->lv = 0;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require no protection, open link.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_OPEN(ptr)              do {(ptr)->sm = 1; (ptr)->lv = 1;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require encryption, but no MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(ptr)       do {(ptr)->sm = 1; (ptr)->lv = 2;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require encryption and MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(ptr)     do {(ptr)->sm = 1; (ptr)->lv = 3;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require signing or encryption, no MITM protection needed.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(ptr)    do {(ptr)->sm = 2; (ptr)->lv = 1;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require signing or encryption with MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(ptr)  do {(ptr)->sm = 2; (ptr)->lv = 2;} while(0)
N/** @} */
N
N
N/**@brief GAP Security Key Length. */
N#define BLE_GAP_SEC_KEY_LEN 16
N
N/**@brief Maximum amount of addresses in a whitelist. */
N#define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
N
N/**@brief Maximum amount of IRKs in a whitelist.
N * @note  The number of IRKs is limited to 8, even if the hardware supports more.
N */
N#define BLE_GAP_WHITELIST_IRK_MAX_COUNT (8)
N
N/** @defgroup GAP_SEC_MODES GAP Security Modes
N * @{ */
N#define BLE_GAP_SEC_MODE 0x00 /**< No key (may be used to reject). */
N
N/** @} */
N
N
N/** @} */
N
N/**@brief Bluetooth Low Energy address. */
Ntypedef struct
N{
N  uint8_t addr_type;                    /**< See @ref BLE_GAP_ADDR_TYPES. */
N  uint8_t addr[BLE_GAP_ADDR_LEN];       /**< 48-bit address, LSB format. */
X  uint8_t addr[6];        
N} ble_gap_addr_t;
N
N
N/**@brief GAP connection parameters. */
Ntypedef struct
N{
N  uint16_t min_conn_interval;         /**< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t max_conn_interval;         /**< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t slave_latency;             /**< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t conn_sup_timeout;          /**< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N} ble_gap_conn_params_t;
N
N
N/**@brief GAP link requirements.
N *
N * See Bluetooth Core specification, Volume 3 Part C 10.2 for details.
N *
N * Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\n
N * Security Mode 1 Level 1: No security is needed (aka open link).\n
N * Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\n
N * Security Mode 1 Level 3: MITM protected encrypted link required.\n
N * Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\n
N * Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\n
N */
Ntypedef struct
N{
N  uint8_t sm : 4;                     /**< Security Mode (1 or 2), 0 for no permissions at all. */
N  uint8_t lv : 4;                     /**< Level (1, 2 or 3), 0 for no permissions at all. */
N
N} ble_gap_conn_sec_mode_t;
N
N
N
N/**@brief GAP connection security status.*/
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t sec_mode;           /**< Currently active security mode for this connection.*/
N  uint8_t                 encr_key_size;      /**< Length of currently active encryption key, 7 to 16 octets.*/
N} ble_gap_conn_sec_t;
N
N
N
N/**@brief Identity Resolving Key. */
Ntypedef struct
N{
N  uint8_t irk[BLE_GAP_SEC_KEY_LEN];   /**< Array containing IRK. */
X  uint8_t irk[16];    
N} ble_gap_irk_t;
N
N
N/**@brief White list structure. */
Ntypedef struct
N{
N  ble_gap_addr_t   ** pp_addrs;        /**< Pointer to array of device address pointers, pointing to addresses to be used in whitelist. NULL if none are given. */
N  uint8_t             addr_count;      /**< Count of device addresses in array, up to @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT. */
N  ble_gap_irk_t    ** pp_irks;         /**< Pointer to array of Identity Resolving Key (IRK) pointers, each pointing to an IRK in the whitelist. NULL if none are given. */
N  uint8_t             irk_count;       /**< Count of IRKs in array, up to @ref BLE_GAP_WHITELIST_IRK_MAX_COUNT. */
N} ble_gap_whitelist_t;
N
N
N/**@brief GAP advertising parameters.*/
Ntypedef struct
N{
N  uint8_t               type;                 /**< See @ref BLE_GAP_ADV_TYPES. */
N  ble_gap_addr_t*       p_peer_addr;          /**< For BLE_GAP_CONN_MODE_DIRECTED mode only, known peer address. */
N  uint8_t               fp;                   /**< Filter Policy, see @ref BLE_GAP_ADV_FILTER_POLICIES. */
N  ble_gap_whitelist_t * p_whitelist;          /**< Pointer to whitelist, NULL if none is given. */
N  uint16_t              interval;             /**< Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS. This parameter must be set to 0 if type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND. */
N  uint16_t              timeout;              /**< Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See also @ref BLE_GAP_ADV_TIMEOUT_VALUES. This parameter must be set to 0 if type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND. */
N} ble_gap_adv_params_t;
N
N
N/**@brief GAP scanning parameters. */
Ntypedef struct
N{
N  uint8_t    filter;                    /**< Filter based on discovery mode, see @ref BLE_GAP_DISC_MODES. */
N  uint8_t    active    : 1;             /**< If 1, perform active scanning (scan requests). */
N  uint8_t    selective : 1;             /**< If 1, ignore unknown devices (non white listed). */
N  uint16_t   interval;                  /**< Scan interval between 0x0020 and 0x4000 in 0.625ms units (20ms to 10.24s). */
N  uint16_t   window;                    /**< Scan window between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
N  uint16_t   timeout;                   /**< Scan timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. */
N} ble_gap_scan_params_t;
N
N
N/**@brief GAP security parameters. */
Ntypedef struct
N{
N  uint16_t   timeout;                   /**< Timeout for SMP transactions or Security Request in seconds, see @ref sd_ble_gap_authenticate and @ref sd_ble_gap_sec_params_reply for more information. */
N  uint8_t    bond    : 1;               /**< Perform bonding. */
N  uint8_t    mitm    : 1;               /**< Man In The Middle protection required. */
N  uint8_t    io_caps : 3;               /**< IO capabilities, see @ref BLE_GAP_IO_CAPS. */
N  uint8_t    oob     : 1;               /**< Out Of Band data available. */
N  uint8_t    min_key_size;              /**< Minimum encryption key size in octets between 7 and 16. */
N  uint8_t    max_key_size;              /**< Maximum encryption key size in octets between min_key_size and 16. */
N} ble_gap_sec_params_t;
N
N
N/**@brief GAP Encryption Information. */
Ntypedef struct
N{
N  uint16_t  div;                        /**< Encryption Diversifier. */
N  uint8_t   ltk[BLE_GAP_SEC_KEY_LEN];   /**< Long Term Key. */
X  uint8_t   ltk[16];    
N  uint8_t   auth : 1;                   /**< Authenticated Key. */
N  uint8_t   ltk_len : 7;                /**< LTK length in octets. */
N} ble_gap_enc_info_t;
N
N
N/**@brief GAP Master Identification. */
Ntypedef struct
N{
N  uint16_t  ediv;                       /**< Encrypted Diversifier. */
N  uint8_t   rand[8];                    /**< Random Number. */
N} ble_gap_master_id_t;
N
N
N/**@brief GAP Identity Information. */
Ntypedef struct
N{
N  ble_gap_addr_t  addr;                       /**< Bluetooth address to which this key applies. */
N  uint8_t         irk[BLE_GAP_SEC_KEY_LEN];   /**< Identity Resolution Key. */
X  uint8_t         irk[16];    
N} ble_gap_id_info_t;
N
N
N/**@brief GAP Signing Information. */
Ntypedef struct
N{
N  uint8_t   csrk[BLE_GAP_SEC_KEY_LEN]; /* Connection Signature Resolving Key. */
X  uint8_t   csrk[16];  
N} ble_gap_sign_info_t;
N
N
N
N/**
N * @brief GAP Event IDs.
N * Those IDs uniquely identify an event coming from the stack to the application.
N */
Nenum BLE_GAP_EVTS
N{
N  BLE_GAP_EVT_CONNECTED  = BLE_GAP_EVT_BASE,    /**< Connection established. */
X  BLE_GAP_EVT_CONNECTED  = 0x10,     
N  BLE_GAP_EVT_DISCONNECTED,                     /**< Disconnected from peer. */
N  BLE_GAP_EVT_CONN_PARAM_UPDATE,                /**< Connection Parameters updated. */
N  BLE_GAP_EVT_SEC_PARAMS_REQUEST,               /**< Request to provide security parameters. */
N  BLE_GAP_EVT_SEC_INFO_REQUEST,                 /**< Request to provide security information. */
N  BLE_GAP_EVT_PASSKEY_DISPLAY,                  /**< Request to display a passkey to the user. */
N  BLE_GAP_EVT_AUTH_KEY_REQUEST,                 /**< Request to provide an authentication key. */
N  BLE_GAP_EVT_AUTH_STATUS,                      /**< Authentication procedure completed with status. */
N  BLE_GAP_EVT_CONN_SEC_UPDATE,                  /**< Connection security updated. */
N  BLE_GAP_EVT_TIMEOUT,                          /**< Timeout expired. */
N  BLE_GAP_EVT_RSSI_CHANGED,                     /**< Signal strength measurement report. */
N};
N
N
N/** @brief Event data for connected event. */
Ntypedef struct
N{
N  ble_gap_addr_t        peer_addr;              /**< Bluetooth address of the peer device. */
N  uint8_t               irk_match :1;           /**< If 1, peer device's address resolved using an IRK. */
N  uint8_t               irk_match_idx  :7;      /**< Index in IRK list where the address was matched. */
N  ble_gap_conn_params_t conn_params;            /**< GAP Connection Parameters. */
N} ble_gap_evt_connected_t;
N
N
N/** @brief Event data for disconnected event. */
Ntypedef struct
N{
N  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. */
N  uint8_t reason;                               /**< HCI error code. */
N} ble_gap_evt_disconnected_t;
N
N
N/** @brief Event data for connection parameter update event. */
Ntypedef struct
N{
N  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
N} ble_gap_evt_conn_param_update_t;
N
N
N/** @brief Event data for security parameters request event. */
Ntypedef struct
N{
N  ble_gap_sec_params_t peer_params;             /**< Initiator Security Parameters. */
N} ble_gap_evt_sec_params_request_t;
N
N
N/** @brief Event data for securito info request event. */
Ntypedef struct
N{
N  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. */
N  uint16_t       div;                           /**< Encryption diversifier for LTK lookup. */
N  uint8_t        enc_info  : 1;                 /**< If 1, Encryption Information required. */
N  uint8_t        id_info   : 1;                 /**< If 1, Identity Information required. */
N  uint8_t        sign_info : 1;                 /**< If 1, Signing Information required. */
N} ble_gap_evt_sec_info_request_t;
N
N
N/** @brief Event data for passkey display event. */
Ntypedef struct
N{
N  uint8_t passkey[6];                           /**< 6-digit passkey in ASCII ('0'-'9' digits only). */
N} ble_gap_evt_passkey_display_t;
N
N
N/** @brief Event data for authentication key request event. */
Ntypedef struct
N{
N  uint8_t key_type;                             /**< See @ref BLE_GAP_AUTH_KEY_TYPES. */
N} ble_gap_evt_auth_key_request_t;
N
N
N/** @brief Security levels supported.
N *  @note See Bluetooth Specification Version 4.0 Volume 3, Chapter 10.
N*/
Ntypedef struct
N{
N  uint8_t lv1 : 1;                              /**< If 1: Level 1 is supported. */
N  uint8_t lv2 : 1;                              /**< If 1: Level 2 is supported. */
N  uint8_t lv3 : 1;                              /**< If 1: Level 3 is supported. */
N} ble_gap_sec_levels_t;
N
N
N/** @brief Keys that have been exchanged. */
Ntypedef struct
N{
N  uint8_t ltk       : 1;                        /**< Long Term Key. */
N  uint8_t ediv_rand : 1;                        /**< Encrypted Diversifier and Random value. */
N  uint8_t irk       : 1;                        /**< Identity Resolving Key. */
N  uint8_t address   : 1;                        /**< Public or static random address. */
N  uint8_t csrk      : 1;                        /**< Connection Signature Resolving Key. */
N} ble_gap_sec_keys_t;
N
N
N/** @brief Event data for authentication status event. */
Ntypedef struct
N{
N  uint8_t               auth_status;            /**< Authentication status, see @ref BLE_GAP_SEC_STATUS. */
N  uint8_t               error_src;              /**< On error, source that caused the failure, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
N  ble_gap_sec_levels_t  sm1_levels;             /**< Levels supported in Security Mode 1. */
N  ble_gap_sec_levels_t  sm2_levels;             /**< Levels supported in Security Mode 2. */
N  ble_gap_sec_keys_t    periph_kex;             /**< Bitmap stating which keys were exchanged (distributed) by the peripheral. */
N  ble_gap_sec_keys_t    central_kex;            /**< Bitmap stating which keys were exchanged (distributed) by the central. */
N  struct periph_keys_t
N  {
N    ble_gap_enc_info_t    enc_info;             /**< Peripheral's Encryption information. */
N  } periph_keys;                                /**< Actual keys distributed from the Peripheral to the Central. */ 
N  struct central_keys_t
N  {
N    ble_gap_irk_t         irk;                  /**< Central's IRK. */
N    ble_gap_addr_t        id_info;              /**< Central's Identity Info. */
N  } central_keys;                               /**< Actual keys distributed from the Central to the Peripheral. */
N} ble_gap_evt_auth_status_t;
N
N
N/** @brief Event data for connection security update event. */
Ntypedef struct
N{
N  ble_gap_conn_sec_t conn_sec;                  /**< Connection security level. */
N} ble_gap_evt_conn_sec_update_t;
N
N
N/** @brief Event data for timeout event. */
Ntypedef struct
N{
N  uint8_t src;                                  /**< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES. */
N} ble_gap_evt_timeout_t;
N
N
N/** @brief Event data for advertisement report event. */
Ntypedef struct
N{
N  int8_t  rssi;                               /**< Received Signal Strength Indication in dBm. */
N} ble_gap_evt_rssi_changed_t;
N
N
N
N/**@brief GAP event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                     /**< Connection Handle on which event occured. */
N  union                                                     /**< union alternative identified by evt_id in enclosing struct. */
N  {
N    ble_gap_evt_connected_t          connected;             /**< Connected Event Parameters. */
N    ble_gap_evt_disconnected_t       disconnected;          /**< Disconnected Event Parameters. */
N    ble_gap_evt_conn_param_update_t  conn_param_update;     /**< Connection Parameter Update Parameters. */
N    ble_gap_evt_sec_params_request_t sec_params_request;    /**< Security Parameters Request Event Parameters. */
N    ble_gap_evt_sec_info_request_t   sec_info_request;      /**< Security Information Request Event Parameters. */
N    ble_gap_evt_passkey_display_t    passkey_display;       /**< Passkey Display Event Parameters. */
N    ble_gap_evt_auth_key_request_t   auth_key_request;      /**< Authentication Key Request Event Parameters. */
N    ble_gap_evt_auth_status_t        auth_status;           /**< Authentication Status Event Parameters. */
N    ble_gap_evt_conn_sec_update_t    conn_sec_update;       /**< Connection Security Update Event Parameters. */
N    ble_gap_evt_timeout_t            timeout;               /**< Timeout Event Parameters. */
N    ble_gap_evt_rssi_changed_t       rssi_changed;          /**< RSSI Event parameters. */
N  } params;
N
N} ble_gap_evt_t;
N
N
N/**@brief Set local Bluetooth address.
N *
N * @param[in] p_addr Pointer to address structure.
N *
N * @return @ref NRF_SUCCESS Address successfully set.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_ADDRESS_SET, uint32_t, sd_ble_gap_address_set(ble_gap_addr_t const * const p_addr));
Xuint32_t __svc(SD_BLE_GAP_ADDRESS_SET) sd_ble_gap_address_set(ble_gap_addr_t const * const p_addr);
N
N
N/**@brief Get local Bluetooth address.
N *
N * @param[out] p_addr Pointer to address structure.
N *
N * @return @ref NRF_SUCCESS Address successfully retrieved.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_ADDRESS_GET, uint32_t, sd_ble_gap_address_get(ble_gap_addr_t * const p_addr));
Xuint32_t __svc(SD_BLE_GAP_ADDRESS_GET) sd_ble_gap_address_get(ble_gap_addr_t * const p_addr);
N
N
N/**@brief Set, clear or update advertisement and scan response data.
N *
N * @note The format of the advertisement data will be checked by this call to ensure interoperability.
N *       Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and
N *       duplicating the local name in the advertisement data and scan response data. 
N *
N * @note: To clear the advertisement data and set it to a 0-length packet, simply provide a valid pointer (p_data/p_sr_data) with its corresponding 
N *        length (dlen/srdlen) set to 0.
N *
N * @note: The call will fail if p_data and p_sr_data are both NULL since this would have no effect.
N *
N * @param[in] p_data    Raw data to be placed in advertisement packet. If NULL, no changes are made to the current advertisement packet data.
N * @param[in] dlen      Data length for p_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_data is NULL, can be 0 if p_data is not NULL.
N * @param[in] p_sr_data Raw data to be placed in scan response packet. If NULL, no changes are made to the current scan response packet data.
N * @param[in] srdlen    Data length for p_sr_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_sr_data is NULL, can be 0 if p_data is not NULL.
N *
N * @return @ref NRF_SUCCESS Advertisement data successfully updated or cleared.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_FLAGS Invalid combination of advertising flags supplied.
N * @return @ref NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
N * @return @ref NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
N * @return @ref BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const * const p_data, uint8_t dlen, uint8_t const * const p_sr_data, uint8_t srdlen));
Xuint32_t __svc(SD_BLE_GAP_ADV_DATA_SET) sd_ble_gap_adv_data_set(uint8_t const * const p_data, uint8_t dlen, uint8_t const * const p_sr_data, uint8_t srdlen);
N
N
N/**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
N *
N * @param[in] p_adv_params Pointer to advertising parameters structure.
N *
N * @return @ref NRF_SUCCESS The BLE stack has started advertising.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check the accepted ranges and limits.
N * @return @ref BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
N * @return @ref BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.
N */
NSVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const * const p_adv_params));
Xuint32_t __svc(SD_BLE_GAP_ADV_START) sd_ble_gap_adv_start(ble_gap_adv_params_t const * const p_adv_params);
N
N
N/**@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
N *
N * @return @ref NRF_SUCCESS The BLE stack has stopped advertising.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
N */
NSVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
Xuint32_t __svc(SD_BLE_GAP_ADV_STOP) sd_ble_gap_adv_stop(void);
N
N
N/**@brief Update connection parameters.
N *
N * @details In the central role this will initiate a Link Layer connection parameter update procedure,
N *          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for
N *          the central to perform the procedure. In both cases, and regardless of success or failure, the application
N *          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event.
N *
N * @note If both a connection supervision timeout and a maximum connection interval are specified, then the following constraint
N *       applies: (conn_sup_timeout * 8) >= (max_conn_interval * (slave_latency + 1))
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,
N *                           the parameters in the PPCP characteristic of the GAP service will be used instead.
N *
N * @return @ref NRF_SUCCESS The Connection Update procedure has been started successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and retry.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const * const p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_CONN_PARAM_UPDATE) sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const * const p_conn_params);
N
N
N/**@brief Disconnect (GAP Link Termination).
N *
N * @details This call initiates the disconnection procedure, and its completion will be communicated to the application
N *          with a BLE_GAP_EVT_DISCONNECTED event.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES.
N *
N * @return @ref NRF_SUCCESS The disconnection procedure has been started successfully.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress or not connected at all).
N */
NSVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
Xuint32_t __svc(SD_BLE_GAP_DISCONNECT) sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code);
N
N
N/**@brief Set the radio's transmit power.
N *
N * @param[in] tx_power Radio transmit power in dBm (accepted values are -40, -30, -20, -16, -12, -8, -4, 0, and 4 dBm).
N *
N * @note -40 dBm will not actually give -40 dBm, but will instead be remapped to -30 dBm.
N *
N * @return @ref NRF_SUCCESS Successfully changed the transmit power.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
Xuint32_t __svc(SD_BLE_GAP_TX_POWER_SET) sd_ble_gap_tx_power_set(int8_t tx_power);
N
N
N/**@brief Set GAP Appearance value.
N *
N * @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
N *
N * @return @ref NRF_SUCCESS  Appearance value set successfully.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
Xuint32_t __svc(SD_BLE_GAP_APPEARANCE_SET) sd_ble_gap_appearance_set(uint16_t appearance);
N
N
N/**@brief Get GAP Appearance value.
N *
N * @param[out] p_appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
N *
N * @return @ref NRF_SUCCESS Appearance value retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t * const p_appearance));
Xuint32_t __svc(SD_BLE_GAP_APPEARANCE_GET) sd_ble_gap_appearance_get(uint16_t * const p_appearance);
N
N
N/**@brief Set GAP Peripheral Preferred Connection Parameters.
N *
N * @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters.
N *
N * @return @ref NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const * const p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_PPCP_SET) sd_ble_gap_ppcp_set(ble_gap_conn_params_t const * const p_conn_params);
N
N
N/**@brief Get GAP Peripheral Preferred Connection Parameters.
N *
N * @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored.
N *
N * @return @ref NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t * const p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_PPCP_GET) sd_ble_gap_ppcp_get(ble_gap_conn_params_t * const p_conn_params);
N
N
N/**@brief Set GAP device name.
N *
N * @param[in] p_write_perm Write permissions for the Device Name characteristic see @ref ble_gap_conn_sec_mode_t.
N * @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string.
N * @param[in] len   Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN).
N *
N * @return @ref NRF_SUCCESS GAP device name and permissions set successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N */
NSVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const * const p_write_perm, uint8_t const * const p_dev_name, uint16_t len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_NAME_SET) sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const * const p_write_perm, uint8_t const * const p_dev_name, uint16_t len);
N
N
N/**@brief Get GAP device name.
N *
N * @param[in]     p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed.
N * @param[in,out] p_len      Length of the buffer pointed by p_dev_name, bytes returned on output.
N *
N * @return @ref NRF_SUCCESS GAP device name retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N */
NSVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t * const p_dev_name, uint16_t * const p_len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_NAME_GET) sd_ble_gap_device_name_get(uint8_t * const p_dev_name, uint16_t * const p_len);
N
N
N/**@brief Initiate GAP Authentication procedure.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing procedure.
N *
N * @details In the central role, this function will send an SMP Pairing Request, otherwise in the peripheral role, an SMP Security Request will be sent.
N *          In the peripheral role, only the timeout, bond and mitm fields of @ref ble_gap_sec_params_t are used.
N *
N * @note    The GAP Authentication procedure may be triggered by the central without calling this function when accessing a secure service.
N * @note    Calling this function may result in the following events depending on the outcome and parameters: @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST,
N *          @ref BLE_GAP_EVT_SEC_INFO_REQUEST, @ref BLE_GAP_EVT_AUTH_KEY_REQUEST, @ref BLE_GAP_EVT_AUTH_STATUS.
N * @note    The timeout parameter in @ref ble_gap_sec_params_t is interpreted here as the Security Request timeout
N *
N *
N * @return @ref NRF_SUCCESS Successfully initiated authentication procedure.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const * const p_sec_params));
Xuint32_t __svc(SD_BLE_GAP_AUTHENTICATE) sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const * const p_sec_params);
N
N
N/**@brief Reply with GAP security parameters.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS.
N * @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N * @note    The timeout parameter in @ref ble_gap_sec_params_t is interpreted here as the SMP procedure timeout, and must be 30 seconds. The function will fail
N *          if the application supplies a different value.
N *
N * @return @ref NRF_SUCCESS Successfully accepted security parameter from the application.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_SEC_PARAMS_REPLY, uint32_t, sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const * const p_sec_params));
Xuint32_t __svc(SD_BLE_GAP_SEC_PARAMS_REPLY) sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const * const p_sec_params);
N
N
N/**@brief Reply with an authentication key.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES.
N * @param[in] key If key type is BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL.
N *                If key type is BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination).
N *                If key type is BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in Little Endian format.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST, calling it at other times will result in an NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N *
N * @return @ref NRF_SUCCESS Authentication key successfully set.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_AUTH_KEY_REPLY, uint32_t, sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const * const key));
Xuint32_t __svc(SD_BLE_GAP_AUTH_KEY_REPLY) sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const * const key);
N
N
N/**@brief Reply with GAP security information.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available.
N * @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N * @note    Data signing is not implemented yet. p_sign_info must therefore be NULL.
N *
N * @return @ref NRF_SUCCESS Successfully accepted security information.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const * const p_enc_info, ble_gap_sign_info_t const * const p_sign_info));
Xuint32_t __svc(SD_BLE_GAP_SEC_INFO_REPLY) sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const * const p_enc_info, ble_gap_sign_info_t const * const p_sign_info);
N
N
N/**@brief Get the current connection security.
N *
N * @param[in]  conn_handle Connection handle.
N * @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in.
N *
N * @return @ref NRF_SUCCESS Current connection security successfully retrieved.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_CONN_SEC_GET, uint32_t, sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t * const p_conn_sec));
Xuint32_t __svc(SD_BLE_GAP_CONN_SEC_GET) sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t * const p_conn_sec);
N
N
N/**@brief Start reporting the received signal strength to the application. 
N *
N * A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called.
N *
N * @param[in] conn_handle Connection handle.
N *
N * @return @ref NRF_SUCCESS Successfully activated RSSI reporting.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle));
Xuint32_t __svc(SD_BLE_GAP_RSSI_START) sd_ble_gap_rssi_start(uint16_t conn_handle);
N
N
N/**@brief Stop reporting the received singnal strength. 
N *
N * An RSSI change detected before the call but not yet received by the application 
N * may be reported after @ref sd_ble_gap_rssi_stop has been called.
N *
N * @param[in] conn_handle Connection handle.
N *
N * @return @ref NRF_SUCCESS Successfully deactivated RSSI reporting.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_RSSI_STOP, uint32_t, sd_ble_gap_rssi_stop(uint16_t conn_handle));
Xuint32_t __svc(SD_BLE_GAP_RSSI_STOP) sd_ble_gap_rssi_stop(uint16_t conn_handle);
N
N#endif // BLE_GAP_H__
N
N/**
N  @}
N*/
L 24 "..\..\..\Software\Include\ble.h" 2
N#include "ble_l2cap.h"
L 1 "..\..\..\Software\Include\ble_l2cap.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_L2CAP Logical Link Control and Adaptation Protocol (L2CAP)
N  @{
N  @brief Definitions and prototypes for the L2CAP interface.
N */
N
N#ifndef BLE_L2CAP_H__
N#define BLE_L2CAP_H__ 
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "ble_err.h"
L 1 "..\..\..\Software\Include\ble_err.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @addtogroup BLE_COMMON
N  @{
N  @addtogroup  nrf_error
N  @{
N    @ingroup BLE_COMMON
N  @}
N
N  @defgroup ble_err General error codes
N  @{
N
N  @brief General error code definitions for the BLE API.
N
N  @ingroup BLE_COMMON
N*/
N#ifndef NRF_BLE_ERR_H__
N#define NRF_BLE_ERR_H__
N
N#include "nrf_error.h"
L 1 "..\..\..\Software\Include\nrf_error.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @defgroup nrf_error SoftDevice Global Error Codes
N  @{
N   
N  @brief Global Error definitions
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_H__
N#define NRF_ERROR_H__
N
N/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
N * @{ */
N#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
N#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
N#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
N#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
N/** @} */
N
N#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
N#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
N#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
N#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
N#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
N#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
N#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
N#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
N#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
N#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
N#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
N#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
N#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Data size exceeds limit
N#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
N#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
N#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
N#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
N#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
N
N#endif // NRF_ERROR_H__
N
N/**
N  @}
N*/
L 28 "..\..\..\Software\Include\ble_err.h" 2
N
N/* @defgroup BLE_ERRORS Error Codes
N * @{ */
N#define BLE_ERROR_INVALID_CONN_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x001) /**< Invalid connection handle. */
N#define BLE_ERROR_INVALID_ATTR_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x002) /**< Invalid attribute handle. */
N#define BLE_ERROR_NO_TX_BUFFERS          (NRF_ERROR_STK_BASE_NUM+0x003) /**< Buffer capacity exceeded. */
N/** @} */
N
N
N/** @defgroup BLE_ERROR_SUBRANGES Module specific error code subranges
N *  @brief Assignment of subranges for module specific error codes.
N *  @note For specific error codes, see ble_<module>.h or ble_error_<module>.h.
N * @{ */
N#define NRF_L2CAP_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x100) /**< L2CAP specific errors. */
N#define NRF_GAP_ERR_BASE               (NRF_ERROR_STK_BASE_NUM+0x200) /**< GAP specific errors. */
N#define NRF_GATTC_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x300) /**< GATT client specific errors. */
N#define NRF_GATTS_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x400) /**< GATT server specific errors. */
N/** @} */
N
N#endif
N
N
N/**
N  @}
N  @}
N*/
L 20 "..\..\..\Software\Include\ble_l2cap.h" 2
N#include "nrf_svc.h"
N
N/**@brief L2CAP API SVC numbers. */
Nenum BLE_L2CAP_SVCS 
N{
N  SD_BLE_L2CAP_CID_REGISTER = BLE_L2CAP_SVC_BASE,  /**< Register a CID. */
X  SD_BLE_L2CAP_CID_REGISTER = 0xB0,   
N  SD_BLE_L2CAP_CID_UNREGISTER,                     /**< Unregister a CID. */
N  SD_BLE_L2CAP_TX                                  /**< Transmit a packet. */
N};
N
N/**@addtogroup BLE_L2CAP_DEFINES Defines
N * @{ */
N
N/**@defgroup BLE_ERRORS_L2CAP SVC return values specific to L2CAP
N * @{ */
N#define BLE_ERROR_L2CAP_CID_IN_USE            (NRF_L2CAP_ERR_BASE + 0x000)  /**< CID already in use. */
N/** @} */
N
N/**@brief Default L2CAP MTU. */
N#define BLE_L2CAP_MTU_DEF           (23)    
N
N/**@brief Invalid Channel Identifier. */
N#define BLE_L2CAP_CID_INVALID       (0x0000) 
N
N/**@brief Dynamic Channel Identifier base. */
N#define BLE_L2CAP_CID_DYN_BASE      (0x0040) 
N
N/**@brief Maximum amount of dynamic CIDs. */
N#define BLE_L2CAP_CID_DYN_MAX       (8) 
N
N/** @} */
N
N/**@brief Packet header format for L2CAP transmission. */
Ntypedef struct
N{
N  uint16_t   len;                                 /**< Length of valid info in data member. */
N  uint16_t   cid;                                 /**< Channel ID on which packet is transmitted. */
N} ble_l2cap_header_t;
N
N/**@brief L2CAP Event IDs. */
Nenum BLE_L2CAP_EVTS 
N{
N  BLE_L2CAP_EVT_RX  = BLE_L2CAP_EVT_BASE          /**< L2CAP packet received. */
X  BLE_L2CAP_EVT_RX  = 0x70           
N};
N
N
N/**@brief L2CAP Received packet event report. */
Ntypedef struct
N{
N  ble_l2cap_header_t header;                      /** L2CAP packet header. */
N  uint8_t    data[1];                             /**< Packet data, variable length. */
N} ble_l2cap_evt_rx_t;
N
N
N/**@brief L2CAP event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                           /**< Connection Handle on which event occured. */
N  union
N  {
N    ble_l2cap_evt_rx_t rx;                        /**< RX Event parameters. */
N  } params;
N} ble_l2cap_evt_t;
N
N
N/**@brief Register a CID with L2CAP.
N *
N * @details This registers a higher protocol layer with the L2CAP multiplexer, and is requried prior to all operations on the CID.
N *          
N * @param[in] cid L2CAP CID.
N *
N * @return @ref NRF_SUCCESS Successfully registered a CID with the L2CAP layer.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CID must be above @ref BLE_L2CAP_CID_DYN_BASE.
N * @return @ref BLE_ERROR_L2CAP_CID_IN_USE L2CAP CID already in use.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_L2CAP_CID_REGISTER, uint32_t, sd_ble_l2cap_cid_register(uint16_t cid));
Xuint32_t __svc(SD_BLE_L2CAP_CID_REGISTER) sd_ble_l2cap_cid_register(uint16_t cid);
N
N/**@brief Unregister a CID with L2CAP.
N *
N * @details This unregisters a previously registerd higher protocol layer with the L2CAP multiplexer.
N *          
N * @param[in] cid L2CAP CID.
N *
N * @return @ref NRF_SUCCESS Successfully unregistered the CID.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_NOT_FOUND CID not previously registered.
N */
NSVCALL(SD_BLE_L2CAP_CID_UNREGISTER, uint32_t, sd_ble_l2cap_cid_unregister(uint16_t cid));
Xuint32_t __svc(SD_BLE_L2CAP_CID_UNREGISTER) sd_ble_l2cap_cid_unregister(uint16_t cid);
N
N/**@brief Transmit an L2CAP packet.
N *
N * @note    It is important to note that a call to this function will <b>consume an application buffer</b>, and will therefore 
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. 
N *          Please see the documentation of @ref sd_ble_tx_buffer_count_get for more details.
N *
N * @param[in] conn_handle Connection Handle.
N * @param[in] p_header    Pointer to a packet header containing length and CID.
N * @param[in] p_data      Pointer to the data to be transmitted.
N *
N * @return @ref NRF_SUCCESS Successfully queued an L2CAP packet for transmission.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CIDs must be registered beforehand with @ref sd_ble_l2cap_cid_register.
N * @return @ref NRF_ERROR_NOT_FOUND CID not found.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS Not enough application buffers available.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, see @ref BLE_L2CAP_MTU_DEF.
N */
NSVCALL(SD_BLE_L2CAP_TX, uint32_t, sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const * const p_header, uint8_t const * const p_data));
Xuint32_t __svc(SD_BLE_L2CAP_TX) sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const * const p_header, uint8_t const * const p_data);
N
N
N#endif // BLE_L2CAP_H__
N
N/**
N  @}
N*/
L 25 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gatt.h"
L 1 "..\..\..\Software\Include\ble_gatt.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @addtogroup BLE_GATT Generic Attribute Profile (GATT) Common
N  @{
N  @brief  Common definitions and prototypes for the GATT interfaces.
N */
N
N#ifndef BLE_GATT_H__
N#define BLE_GATT_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N
N
N/** @addtogroup BLE_GATT_DEFINES Defines
N * @{ */
N
N/** @brief Default MTU size. */
N#define GATT_MTU_SIZE_DEFAULT 23
N
N/** @brief Only the default MTU size of 23 is currently supported. */
N#define GATT_RX_MTU 23
N
N
N/**@brief Invalid Attribute Handle. */
N#define BLE_GATT_HANDLE_INVALID            0x0000
N
N/** @defgroup BLE_GATT_TIMEOUT_SOURCES GATT Timeout sources
N * @{ */
N#define BLE_GATT_TIMEOUT_SRC_PROTOCOL                  0x00 /**< ATT Protocol timeout. */
N/** @} */
N
N/** @defgroup BLE_GATT_WRITE_OPS GATT Write operations
N * @{ */
N#define BLE_GATT_OP_INVALID                0x00  /**< Invalid Operation. */
N#define BLE_GATT_OP_WRITE_REQ              0x01  /**< Write Request. */
N#define BLE_GATT_OP_WRITE_CMD              0x02  /**< Write Command. */
N#define BLE_GATT_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
N#define BLE_GATT_OP_PREPARE_WRITE_REQ      0x04  /**< Prepare Write Request. */
N#define BLE_GATT_OP_EXECUTE_WRITE_REQ      0x05  /**< Execute Write Request. */
N/** @} */
N
N/** @defgroup BLE_GATT_HVX_TYPES GATT Handle Value operations
N * @{ */
N#define BLE_GATT_HVX_INVALID               0x00  /**< Invalid Operation. */
N#define BLE_GATT_HVX_NOTIFICATION          0x01  /**< Handle Value Notification. */
N#define BLE_GATT_HVX_INDICATION            0x02  /**< Handle Value Indication. */
N/** @} */
N
N/** @defgroup BLE_GATT_STATUS_CODES GATT Status Codes
N * @{ */
N#define BLE_GATT_STATUS_SUCCESS                           0x0000  /**< Success. */
N#define BLE_GATT_STATUS_UNKNOWN                           0x0001  /**< Unknown or not applicable status. */
N#define BLE_GATT_STATUS_ATTERR_INVALID                    0x0100  /**< ATT Error: Invalid Error Code. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_HANDLE             0x0101  /**< ATT Error: Invalid Attribute Handle. */
N#define BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED         0x0102  /**< ATT Error: Read not permitted. */
N#define BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED        0x0103  /**< ATT Error: Write not permitted. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_PDU                0x0104  /**< ATT Error: Used in ATT as Invalid PDU. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION       0x0105  /**< ATT Error: Authenticated link required. */
N#define BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED      0x0106  /**< ATT Error: Used in ATT as Request Not Supported. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_OFFSET             0x0107  /**< ATT Error: Offset specified was past the end of the attribute. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION        0x0108  /**< ATT Error: Used in ATT as Insufficient Authorisation. */
N#define BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL         0x0109  /**< ATT Error: Used in ATT as Prepare Queue Full. */
N#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND        0x010A  /**< ATT Error: Used in ATT as Attribute not found. */
N#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG         0x010B  /**< ATT Error: Attribute cannot be read or written using read/write blob requests. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE         0x010C  /**< ATT Error: Encryption key size used is insufficient. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH     0x010D  /**< ATT Error: Invalid value size. */
N#define BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR             0x010E  /**< ATT Error: Very unlikely error. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION           0x010F  /**< ATT Error: Encrypted link required. */
N#define BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE     0x0110  /**< ATT Error: Attribute type is not a supported grouping attribute. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES            0x0111  /**< ATT Error: Encrypted link required. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN           0x0112  /**< ATT Error: Reserved for Future Use range #1 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END             0x017F  /**< ATT Error: Reserved for Future Use range #1 end. */
N#define BLE_GATT_STATUS_ATTERR_APP_BEGIN                  0x0180  /**< ATT Error: Application range begin. */
N#define BLE_GATT_STATUS_ATTERR_APP_END                    0x019F  /**< ATT Error: Application range end. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN           0x01A0  /**< ATT Error: Reserved for Future Use range #2 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END             0x01DF  /**< ATT Error: Reserved for Future Use range #2 end. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN           0x01E0  /**< ATT Error: Reserved for Future Use range #3 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END             0x01FC  /**< ATT Error: Reserved for Future Use range #3 end. */
N#define BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR      0x01FD  /**< ATT Common Profile and Service Error: Client Characteristic Configuration Descriptor improperly configured. */
N#define BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG       0x01FE  /**< ATT Common Profile and Service Error: Procedure Already in Progress. */
N#define BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE           0x01FF  /**< ATT Common Profile and Service Error: Out Of Range. */
N/** @} */
N
N
N/** @defgroup BLE_GATT_CPF_FORMATS Characteristic Presentation Formats
N *  @note Found at http://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.characteristic_presentation_format.xml
N * @{ */
N#define BLE_GATT_CPF_FORMAT_RFU                 0x00 /**< Reserved For Future Use. */
N#define BLE_GATT_CPF_FORMAT_BOOLEAN             0x01 /**< Boolean. */
N#define BLE_GATT_CPF_FORMAT_2BIT                0x02 /**< Unsigned 2-bit integer. */
N#define BLE_GATT_CPF_FORMAT_NIBBLE              0x03 /**< Unsigned 4-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT8               0x04 /**< Unsigned 8-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT12              0x05 /**< Unsigned 12-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT16              0x06 /**< Unsigned 16-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT24              0x07 /**< Unsigned 24-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT32              0x08 /**< Unsigned 32-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT48              0x09 /**< Unsigned 48-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT64              0x0A /**< Unsigned 64-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT128             0x0B /**< Unsigned 128-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT8               0x0C /**< Signed 2-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT12              0x0D /**< Signed 12-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT16              0x0E /**< Signed 16-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT24              0x0F /**< Signed 24-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT32              0x10 /**< Signed 32-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT48              0x11 /**< Signed 48-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT64              0x12 /**< Signed 64-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT128             0x13 /**< Signed 128-bit integer. */
N#define BLE_GATT_CPF_FORMAT_FLOAT32             0x14 /**< IEEE-754 32-bit floating point. */
N#define BLE_GATT_CPF_FORMAT_FLOAT64             0x15 /**< IEEE-754 64-bit floating point. */
N#define BLE_GATT_CPF_FORMAT_SFLOAT              0x16 /**< IEEE-11073 16-bit SFLOAT. */
N#define BLE_GATT_CPF_FORMAT_FLOAT               0x17 /**< IEEE-11073 32-bit FLOAT. */
N#define BLE_GATT_CPF_FORMAT_DUINT16             0x18 /**< IEEE-20601 format. */
N#define BLE_GATT_CPF_FORMAT_UTF8S               0x19 /**< UTF-8 string. */
N#define BLE_GATT_CPF_FORMAT_UTF16S              0x1A /**< UTF-16 string. */
N#define BLE_GATT_CPF_FORMAT_STRUCT              0x1B /**< Opaque Structure. */
N/** @} */
N
N/** @defgroup BLE_GATT_CPF_NAMESPACES GATT Bluetooth Namespaces
N * @{
N */
N#define BLE_GATT_CPF_NAMESPACE_BTSIG            0x01
N#define BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN 0x0000
N/** @} */
N
N/** @} */
N
N/**@brief GATT Characteristic Properties. */
Ntypedef struct
N{
N  /* Standard properties */
N  uint8_t broadcast       :1; /**< Broadcasting of value permitted. */
N  uint8_t read            :1; /**< Reading value permitted. */
N  uint8_t write_wo_resp   :1; /**< Writing value with Write Command permitted. */
N  uint8_t write           :1; /**< Writing value with Write Request permitted. */
N  uint8_t notify          :1; /**< Notications of value permitted. */
N  uint8_t indicate        :1; /**< Indications of value permitted. */
N  uint8_t auth_signed_wr  :1; /**< Writing value with Signed Write Command permitted. */
N} ble_gatt_char_props_t;
N
N/**@brief GATT Characteristic Extended Properties. */
Ntypedef struct
N{
N  /* Extended properties */
N  uint8_t reliable_wr     :1; /**< Writing value with Queued Write Request permitted. */
N  uint8_t wr_aux          :1; /**< Writing the Characteristic User Description permitted. */
N} ble_gatt_char_ext_props_t;
N
N#endif // BLE_GATT_H__
N
N/**
N  @}
N  @}
N*/
L 26 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gattc.h"
L 1 "..\..\..\Software\Include\ble_gattc.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_GATTC Generic Attribute Profile (GATT) Client
N  @{
N  @brief  Definitions and prototypes for the GATT Client interface.
N */
N
N#ifndef BLE_GATTC_H__
N#define BLE_GATTC_H__
N
N#include "ble_gatt.h"
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "nrf_svc.h"
N
N
N/**@brief GATTC API SVC numbers. */
Nenum BLE_GATTC_SVCS
N{
N  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = BLE_GATTC_SVC_BASE, /**< Primary Service Discovery. */
X  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = 0x80,  
N  SD_BLE_GATTC_RELATIONSHIPS_DISCOVER,                         /**< Relationship Discovery. */
N  SD_BLE_GATTC_CHARACTERISTICS_DISCOVER,                       /**< Characteristic Discovery. */
N  SD_BLE_GATTC_DESCRIPTORS_DISCOVER,                           /**< Characteristic Descriptor Discovery. */
N  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
N  SD_BLE_GATTC_READ,                                           /**< Generic read. */
N  SD_BLE_GATTC_CHAR_VALUES_READ,                               /**< Read multiple Characteristic Values. */
N  SD_BLE_GATTC_WRITE,                                          /**< Generic write. */
N  SD_BLE_GATTC_HV_CONFIRM                                      /**< Handle Value Confirmation. */
N};
N
N/** @addtogroup BLE_GATTC_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_ERRORS_GATTC SVC return values specific to GATTC
N * @{ */
N#define BLE_ERROR_GATTC_PROC_NOT_PERMITTED    (NRF_GATTC_ERR_BASE + 0x000)
N/** @} */
N
N/**@brief Last Attribute Handle. */
N#define BLE_GATTC_HANDLE_END                0xFFFF
N
N/** @} */
N
N/**@brief Operation Handle Range. */
Ntypedef struct
N{
N  uint16_t          start_handle; /**< Start Handle. */
N  uint16_t          end_handle;   /**< End Handle. */
N} ble_gattc_handle_range_t;
N
N
N/**@brief GATT service. */
Ntypedef struct
N{
N  ble_uuid_t               uuid;          /**< Service UUID. */
N  ble_gattc_handle_range_t handle_range;  /**< Service Handle Range. */
N} ble_gattc_service_t;
N
N
N/**@brief  GATT include. */
Ntypedef struct
N{
N  uint16_t            handle;           /**< Include Handle. */
N  ble_gattc_service_t included_srvc;    /**< Handle of the included service. */
N} ble_gattc_include_t;
N
N
N/**@brief GATT characteristic. */
Ntypedef struct
N{
N  ble_uuid_t              uuid;                 /**< Characteristic UUID. */
N  ble_gatt_char_props_t   char_props;           /**< Characteristic Properties. */
N  uint8_t                 char_ext_props : 1;   /**< Extended properties present. */
N  uint16_t                handle_decl;          /**< Handle of the Characteristic Declaration. */
N  uint16_t                handle_value;         /**< Handle of the Characteristic Value. */
N} ble_gattc_char_t;
N
N
N/**@brief GATT descriptor. */
Ntypedef struct
N{
N  uint16_t          handle;         /**< Descriptor Handle. */
N  ble_uuid_t        uuid;           /**< Descriptor UUID. */
N} ble_gattc_desc_t;
N
N
N/**@brief Write Parameters. */
Ntypedef struct
N{
N  uint8_t    write_op;                 /**< Write Operation to be performed, see BLE_GATT_WRITE_OPS. */
N  uint16_t   handle;                   /**< Handle to the attribute to be written. */
N  uint16_t   offset;                   /**< Offset in bytes. */
N  uint16_t   len;                      /**< Length of data in bytes. */
N  uint8_t*   p_value;                  /**< Pointer to the value data. */
N} ble_gattc_write_params_t;
N
N
N/**
N * @brief GATT Client Event IDs.
N */
Nenum BLE_GATTC_EVTS
N{
N  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = BLE_GATTC_EVT_BASE,  /**< Primary Service Discovery Response event.  */
X  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = 0x30,   
N  BLE_GATTC_EVT_REL_DISC_RSP,                             /**< Relationship Discovery Response event. */
N  BLE_GATTC_EVT_CHAR_DISC_RSP,                            /**< Characteristic Discovery Response event. */
N  BLE_GATTC_EVT_DESC_DISC_RSP,                            /**< Descriptor Discovery Response event. */
N  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event. */
N  BLE_GATTC_EVT_READ_RSP,                                 /**< Read Response event. */
N  BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       /**< Read multiple Response event. */
N  BLE_GATTC_EVT_WRITE_RSP,                                /**< Write Response event. */
N  BLE_GATTC_EVT_HVX,                                      /**< Handle Value Notification or Indication event. */
N  BLE_GATTC_EVT_TIMEOUT                                   /**< Timeout event. */
N};
N
N/**@brief Event structure for BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t             count;           /**< Service count. */
N  ble_gattc_service_t services[1];      /**< Service data, variable length. */
N} ble_gattc_evt_prim_srvc_disc_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_REL_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t             count;           /**< Include count. */
N  ble_gattc_include_t includes[1];      /**< Include data, variable length. */
N} ble_gattc_evt_rel_disc_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_CHAR_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t            count;          /**< Characteristic count. */
N  ble_gattc_char_t    chars[1];       /**< Characteristic data, variable length. */
N} ble_gattc_evt_char_disc_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_DESC_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t            count;          /**< Descriptor count. */
N  ble_gattc_desc_t    descs[1];       /**< Descriptor data, variable length. */
N} ble_gattc_evt_desc_disc_rsp_t;
N
N/**@brief GATT read by UUID handle value pair. */
Ntypedef struct 
N{
N  uint16_t            handle;          /**< Attribute Handle. */
N  uint8_t             *p_value;        /**< Pointer to value, variable length (length available as value_len in ble_gattc_evt_read_by_uuid_rsp_t). 
N                                            Please note that this pointer is absolute to the memory provided by the user when retrieving the event,
N                                            so it will effectively point to a location inside the handle_value array. */
N} ble_gattc_handle_value_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
Ntypedef struct
N{
N  uint16_t                  count;            /**< Handle-Value Pair Count. */
N  uint16_t                  value_len;        /**< Length of the value in Handle-Value(s) list. */
N  ble_gattc_handle_value_t  handle_value[1];  /**< Handle-Value(s) list, variable length. */
N} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_READ_RSP. */
Ntypedef struct
N{
N  uint16_t            handle;         /**< Attribute Handle. */
N  uint16_t            offset;         /**< Offset of the attribute data. */
N  uint16_t            len;            /**< Attribute data length. */
N  uint8_t             data[1];        /**< Attribute data, variable length. */
N} ble_gattc_evt_read_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_CHAR_VALS_READ_RSP. */
Ntypedef struct
N{
N  uint16_t            len;            /**< Concatenated Attribute values length. */
N  uint8_t             values[1];      /**< Attribute values, variable length. */
N} ble_gattc_evt_char_vals_read_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_WRITE_RSP. */
Ntypedef struct
N{
N  uint16_t            handle;           /**< Attribute Handle. */
N  uint8_t             write_op;         /**< Type of write operation, see @ref BLE_GATT_WRITE_OPS. */
N  uint16_t            len;              /**< Prepare write data length. */
N  uint8_t             data[1];          /**< Prepare write data, variable length. */
N} ble_gattc_evt_write_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_HVX. */
Ntypedef struct
N{
N  uint16_t            handle;         /**< Handle to which the HVx operation applies. */
N  uint8_t             type;           /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
N  uint16_t            len;            /**< Attribute data length. */
N  uint8_t             data[1];        /**< Attribute data, variable length. */
N} ble_gattc_evt_hvx_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
N} ble_gattc_evt_timeout_t;
N
N/**@brief GATTC event type. */
Ntypedef struct
N{
N  uint16_t            conn_handle;                /**< Connection Handle on which event occured. */
N  uint16_t            gatt_status;                /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N  union
N  {
N    ble_gattc_evt_prim_srvc_disc_rsp_t          prim_srvc_disc_rsp;         /**< Primary Service Discovery Response Event Parameters. */
N    ble_gattc_evt_rel_disc_rsp_t                rel_disc_rsp;               /**< Relationship Discovery Response Event Parameters. */
N    ble_gattc_evt_char_disc_rsp_t               char_disc_rsp;              /**< Characteristic Discovery Response Event Parameters. */
N    ble_gattc_evt_desc_disc_rsp_t               desc_disc_rsp;              /**< Descriptor Discovery Response Event Parameters. */
N    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
N    ble_gattc_evt_read_rsp_t                    read_rsp;                   /**< Read Response Event Parameters. */
N    ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         /**< Characteristic Values Read Response Event Parameters. */
N    ble_gattc_evt_write_rsp_t                   write_rsp;                  /**< Write Response Event Parameters. */
N    ble_gattc_evt_hvx_t                         hvx;                        /**< Handle Value Notification/Indication Event Parameters. */
N    ble_gattc_evt_timeout_t                     timeout;                    /**< Timeout Event Parameters. */
N   } params;
N} ble_gattc_evt_t;
N
N
N/**@brief Initiate or continue a GATT Primary Service Discovery procedure.
N *
N * @details This function initiates a Primary Service discovery, starting from the supplied handle. 
N *          If the last service has not been reached, this must be called again with an updated start handle value to continue the search.
N *
N * @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
N *       type BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] start_handle Handle to start searching from.
N * @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const * const p_srvc_uuid));
Xuint32_t __svc(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER) sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const * const p_srvc_uuid);
N
N
N/**@brief Initiate or continue a GATT Relationship Discovery procedure.
N *
N * @details This function initiates the Find Included Services sub-procedure. If the last included service has not been reached,
N *          this must be called again with an updated handle range to continue the search.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER, uint32_t, sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER) sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Characteristic Discovery procedure.
N *
N * @details This function initiates a Characteristic discovery procedure. If the last Characteristic has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
N *       type BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER) sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure.
N *
N * @details This function initiates the Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_DESCRIPTORS_DISCOVER, uint32_t, sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_DESCRIPTORS_DISCOVER) sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
N *
N * @details This function initiates the Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
N * @param[in] p_handle_range A pointer to the range of handles to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const * const p_uuid, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ) sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const * const p_uuid, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.
N *
N * @details This function initiates a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor
N *          to be read is longer than GATT_MTU - 1, this function must be called multiple times with appropriate offset to read the 
N *          complete value.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] handle The handle of the attribute to be read.
N * @param[in] offset Offset into the attribute value to be read.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
Xuint32_t __svc(SD_BLE_GATTC_READ) sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset);
N
N
N/**@brief Initiate a GATT Read Multiple Characteristic Values procedure.
N *
N * @details This function initiates a GATT Read Multiple Characteristic Values procedure. 
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.
N * @param[in] handle_count The number of handles in p_handles.
N *
N * @return @ref NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const * const p_handles, uint16_t handle_count));
Xuint32_t __svc(SD_BLE_GATTC_CHAR_VALUES_READ) sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const * const p_handles, uint16_t handle_count);
N
N
N/**@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure.
N *
N * @details This function can perform all write procedures described in GATT. 
N *
N * @note    It is important to note that a write without response will <b>consume an application buffer</b>, and will therefore 
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. A write on the other hand will use the 
N *          standard client internal buffer and thus will only generate a @ref BLE_GATTC_EVT_WRITE_RSP event as soon as the write response 
N *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_buffer_count_get for more details.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_write_params A pointer to a write parameters structure.
N *
N * @return @ref NRF_SUCCESS Successfully started the Write procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS There are no available buffers left.
N */
NSVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const * const p_write_params));
Xuint32_t __svc(SD_BLE_GATTC_WRITE) sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const * const p_write_params);
N
N
N/**@brief Send a Handle Value Confirmation to the GATT Server.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] handle The handle of the attribute in the indication.
N *
N * @return @ref NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_STATE No Indication pending to be confirmed.
N * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS There are no available buffers left.
N */
NSVCALL(SD_BLE_GATTC_HV_CONFIRM, uint32_t, sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle));
Xuint32_t __svc(SD_BLE_GATTC_HV_CONFIRM) sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle);
N
N
N#endif /* BLE_GATTC_H__ */
N
N/**
N  @}
N  @}
N*/
L 27 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gatts.h"
L 1 "..\..\..\Software\Include\ble_gatts.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_GATTS Generic Attribute Profile (GATT) Server
N  @{
N  @brief  Definitions and prototypes for the GATTS interface.
N */
N
N#ifndef BLE_GATTS_H__
N#define BLE_GATTS_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "ble_l2cap.h"
N#include "ble_gap.h"
N#include "ble_gatt.h"
N#include "nrf_svc.h"
N
N
N/**
N * @brief GATTS API SVC numbers.
N */
Nenum BLE_GATTS_SVCS
N{
N  SD_BLE_GATTS_SERVICE_ADD = BLE_GATTS_SVC_BASE, /**< Add a service. */
X  SD_BLE_GATTS_SERVICE_ADD = 0xA0,  
N  SD_BLE_GATTS_INCLUDE_ADD,                      /**< Add an included service. */
N  SD_BLE_GATTS_CHARACTERISTIC_ADD,               /**< Add a characteristic. */
N  SD_BLE_GATTS_DESCRIPTOR_ADD,                   /**< Add a generic attribute. */
N  SD_BLE_GATTS_VALUE_SET,                        /**< Set an attribute value. */
N  SD_BLE_GATTS_VALUE_GET,                        /**< Get an attribute value. */
N  SD_BLE_GATTS_HVX,                              /**< Handle Value Notification or Indication. */
N  SD_BLE_GATTS_SERVICE_CHANGED,                  /**< Perform a Service Changed Indication to one or more peers. */
N  SD_BLE_GATTS_RW_AUTHORIZE_REPLY,               /**< Reply to an authorization request for a read or write operation on one or more attributes. */ 
N  SD_BLE_GATTS_SYS_ATTR_SET,                     /**< Set the persistent system attributes for a connection. */  
N  SD_BLE_GATTS_SYS_ATTR_GET,                     /**< Get updated persistent system attributes after terminating a connection. */
N};
N
N
N/** @addtogroup BLE_GATTS_DEFINES Defines
N * @{ */
N
N/** @brief Only the default MTU size of 23 is currently supported. */
N#define GATT_RX_MTU 23
N
N/** @defgroup BLE_ERRORS_GATTS SVC return values specific to GATTS
N * @{ */
N#define BLE_ERROR_GATTS_INVALID_ATTR_TYPE   (NRF_GATTS_ERR_BASE + 0x000) /**< Invalid attribute type. */
N#define BLE_ERROR_GATTS_SYS_ATTR_MISSING    (NRF_GATTS_ERR_BASE + 0x001) /**< System Attributes missing. */
N/** @} */
N
N/** @defgroup BLE_GATTS_ATTR_LENS_MAX Maximum attribute lengths
N * @{ */
N#define BLE_GATTS_FIX_ATTR_LEN_MAX (510)  /**< Maximum length for fixed length Attribute Values. */
N#define BLE_GATTS_VAR_ATTR_LEN_MAX (512)  /**< Maximum length for variable length Attribute Values. */ 
N/** @} */
N
N/** @defgroup BLE_GATTS_SRVC_TYPES GATT Server Service Types
N * @{ */
N#define BLE_GATTS_SRVC_TYPE_INVALID          0x00  /**< Invalid Service Type. */
N#define BLE_GATTS_SRVC_TYPE_PRIMARY          0x01  /**< Primary Service. */
N#define BLE_GATTS_SRVC_TYPE_SECONDARY        0x02  /**< Secondary Type. */
N/** @} */
N
N
N/** @defgroup BLE_GATTS_ATTR_TYPES GATT Server Attribute Types
N * @{ */
N#define BLE_GATTS_ATTR_TYPE_INVALID         0x00  /**< Invalid Attribute Type. */
N#define BLE_GATTS_ATTR_TYPE_PRIM_SRVC_DECL  0x01  /**< Primary Service Declaration. */
N#define BLE_GATTS_ATTR_TYPE_SEC_SRVC_DECL   0x02  /**< Secondary Service Declaration. */
N#define BLE_GATTS_ATTR_TYPE_INC_DECL        0x03  /**< Include Declaration. */
N#define BLE_GATTS_ATTR_TYPE_CHAR_DECL       0x04  /**< Characteristic Declaration. */
N#define BLE_GATTS_ATTR_TYPE_CHAR_VAL        0x05  /**< Characteristic Value. */
N#define BLE_GATTS_ATTR_TYPE_DESC            0x06  /**< Descriptor. */
N#define BLE_GATTS_ATTR_TYPE_OTHER           0x07  /**< Other, non-GATT specific type. */
N/** @} */
N
N
N/** @defgroup BLE_GATTS_OPS GATT Server Operations
N * @{ */
N#define BLE_GATTS_OP_INVALID                0x00  /**< Invalid Operation. */
N#define BLE_GATTS_OP_WRITE_REQ              0x01  /**< Write Request. */
N#define BLE_GATTS_OP_WRITE_CMD              0x02  /**< Write Command. */
N#define BLE_GATTS_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
N/** @} */
N
N/** @defgroup BLE_GATTS_VLOCS GATT Value Locations
N * @{ */
N#define BLE_GATTS_VLOC_INVALID       0x00  /**< Invalid Location. */
N#define BLE_GATTS_VLOC_STACK         0x01  /**< Attribute Value is located in stack memory, no user memory is required. */
N#define BLE_GATTS_VLOC_USER          0x02  /**< Attribute Value is located in user memory. This requires the user to maintain a valid buffer through the lifetime of the attribute, since the stack
N                                                will read and write directly to the memory using the pointer provided in the APIs. There are no alignment requirements for the buffer. */
N/** @} */
N
N/** @defgroup BLE_GATTS_AUTHORIZE_TYPES GATT Server Authorization Types
N * @{ */
N#define BLE_GATTS_AUTHORIZE_TYPE_INVALID    0x00  /**< Invalid Type. */
N#define BLE_GATTS_AUTHORIZE_TYPE_READ       0x01  /**< Authorize a Read Operation. */
N#define BLE_GATTS_AUTHORIZE_TYPE_WRITE      0x02  /**< Authorize a Write Request Operation. */
N/** @} */
N
N/** @} */
N
N/**@brief Attribute metadata. */
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t read_perm;       /**< Read permissions. */
N  ble_gap_conn_sec_mode_t write_perm;      /**< Write permissions. */
N  uint8_t                 vlen       :1;   /**< Variable length attribute. */
N  uint8_t                 vloc       :2;   /**< Value location, see @ref BLE_GATTS_VLOCS.*/
N  uint8_t                 rd_auth    :1;   /**< Read Authorization and value will be requested from the application on every read operation. */ 
N  uint8_t                 wr_auth    :1;   /**< Write Authorization will be requested from the application on every Write Request operation (but not Write Command). */
N} ble_gatts_attr_md_t;
N
N
N/**@brief GATT Attribute. */
Ntypedef struct
N{
N  ble_uuid_t*          p_uuid;          /**< Pointer to the attribute UUID. */
N  ble_gatts_attr_md_t* p_attr_md;       /**< Pointer to the attribute metadata structure. */
N  uint16_t             init_len;        /**< Initial attribute value length in bytes. */
N  uint16_t             init_offs;       /**< Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized. */
N  uint16_t             max_len;         /**< Maximum attribute value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values. */
N  uint8_t*             p_value;         /**< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer
N                                             that remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location. 
N                                             The stack may access that memory directly without the application's knowledge. */
N} ble_gatts_attr_t;
N
N
N/**@brief GATT Attribute Context. */
Ntypedef struct
N{
N  ble_uuid_t           srvc_uuid;       /**< Service UUID. */
N  ble_uuid_t           char_uuid;       /**< Characteristic UUID if applicable (BLE_UUID_TYPE_UNKNOWN if N/A). */
N  ble_uuid_t           desc_uuid;       /**< Descriptor UUID if applicable (BLE_UUID_TYPE_UNKNOWN if N/A). */
N  uint16_t             srvc_handle;     /**< Service Handle. */
N  uint16_t             value_handle;    /**< Characteristic Handle if applicable (BLE_GATT_HANDLE_INVALID if N/A). */
N  uint8_t              type;            /**< Attribute Type, see @ref BLE_GATTS_ATTR_TYPES. */
N} ble_gatts_attr_context_t;
N
N
N/**@brief GATT Characteristic Presentation Format. */
Ntypedef struct
N{
N  uint8_t          format;      /**< Format of the value, see @ref BLE_GATT_CPF_FORMATS. */
N  int8_t           exponent;    /**< Exponent for integer data types. */
N  uint16_t         unit;        /**< UUID from Bluetooth Assigned Numbers. */
N  uint8_t          name_space;  /**< Namespace from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
N  uint16_t         desc;        /**< Namespace description from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
N} ble_gatts_char_pf_t;
N
N
N/**@brief GATT Characteristic metadata. */
Ntypedef struct
N{
N  ble_gatt_char_props_t       char_props;               /**< Characteristic Properties. */
N  ble_gatt_char_ext_props_t   char_ext_props;           /**< Characteristic Extended Properties. */
N  uint8_t*                    p_char_user_desc;         /**< Pointer to a UTF-8, NULL if the descriptor is not required. */
N  uint16_t                    char_user_desc_max_size;  /**< The maximum size in bytes of the user description descriptor. */
N  uint16_t                    char_user_desc_size;      /**< The size of the user description, must be smaller or equal to char_user_desc_max_size. */ 
N  ble_gatts_char_pf_t*        p_char_pf;                /**< Pointer to a presentation format structure or NULL if the descriptor is not required. */
N  ble_gatts_attr_md_t*        p_user_desc_md;           /**< Attribute metadata for the User Description descriptor, or NULL for default values. */
N  ble_gatts_attr_md_t*        p_cccd_md;                /**< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values. */
N  ble_gatts_attr_md_t*        p_sccd_md;                /**< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values. */
N} ble_gatts_char_md_t;
N
N
N/**@brief GATT Characteristic Definition Handles. */
Ntypedef struct
N{
N  uint16_t          value_handle;       /**< Handle to the characteristic value. */
N  uint16_t          user_desc_handle;   /**< Handle to the User Description descriptor, or BLE_GATT_HANDLE_INVALID if not present. */
N  uint16_t          cccd_handle;        /**< Handle to the Client Characteristic Configuration Descriptor, or BLE_GATT_HANDLE_INVALID if not present. */
N  uint16_t          sccd_handle;        /**< Handle to the Server Characteristic Configuration Descriptor, or BLE_GATT_HANDLE_INVALID if not present. */
N} ble_gatts_char_handles_t;
N
N
N/**@brief GATT HVx parameters. */
Ntypedef struct
N{
N  uint16_t          handle;             /**< Characteristic Value Handle. */
N  uint8_t           type;               /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
N  uint16_t          offset;             /**< Offset within the attribute value. */
N  uint16_t*         p_len;              /**< Length in bytes to be written, length in bytes written after successful return. */
N  uint8_t*          p_data;             /**< Actual data content, use NULL to use the current attribute value. */
N} ble_gatts_hvx_params_t;
N
N/**@brief GATT Read Authorization parameters. */
Ntypedef struct
N{
N  uint16_t          gatt_status;        /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N  uint8_t           update : 1;         /**< If set, data supplied in p_data will be used in the ATT response. */
N  uint16_t          offset;             /**< Offset of the attribute value being updated. */
N  uint16_t          len;                /**< Length in bytes of the value in p_data pointer, see @ref BLE_GATTS_ATTR_LENS_MAX. */
N  uint8_t*          p_data;             /**< Pointer to new value used to update the attribute value. */
N} ble_gatts_read_authorize_params_t;
N
N/**@brief GATT Write Authorisation parameters. */
Ntypedef struct
N{
N  uint16_t          gatt_status;        /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N} ble_gatts_write_authorize_params_t;
N
N/**@brief GATT Read or Write Authorize Reply parameters. */
Ntypedef struct
N{
N  uint8_t                               type;   /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
N  union {
N    ble_gatts_read_authorize_params_t   read;   /**< Read authorization parameters. */
N    ble_gatts_write_authorize_params_t  write;  /**< Write authorization parameters. */
N  } params;
N} ble_gatts_rw_authorize_reply_params_t;
N
N/**
N * @brief GATT Server Event IDs.
N */
Nenum BLE_GATTS_EVTS
N{
N  BLE_GATTS_EVT_WRITE = BLE_GATTS_EVT_BASE,       /**< Write operation performed. */
X  BLE_GATTS_EVT_WRITE = 0x50,        
N  BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST,             /**< Read/Write Authorization request. */
N  BLE_GATTS_EVT_SYS_ATTR_MISSING,                 /**< A persistent system attribute access is pending, awaiting a sd_ble_gatts_sys_attr_set(). */
N  BLE_GATTS_EVT_HVC,                              /**< Handle Value Confirmation. */
N  BLE_GATTS_EVT_SC_CONFIRM,                       /**< Service Changed Confirmation. */
N  BLE_GATTS_EVT_TIMEOUT                           /**< Timeout. */
N};
N
N
N/**@brief Event structure for BLE_GATTS_EVT_WRITE. */
Ntypedef struct
N{
N  uint16_t                    handle;             /**< Attribute Handle. */
N  uint8_t                     op;                 /**< Type of write operation, see @ref BLE_GATTS_OPS. */
N  ble_gatts_attr_context_t    context;            /**< Attribute Context. */
N  uint16_t                    offset;             /**< Offset for the write operation. */
N  uint16_t                    len;                /**< Length of the incoming data. */
N  uint8_t                     data[1];            /**< Incoming data, variable length. */
N} ble_gatts_evt_write_t;
N
N/**@brief Event structure for authorize read request. */
Ntypedef struct
N{
N  uint16_t                    handle;             /**< Attribute Handle. */
N  ble_gatts_attr_context_t    context;            /**< Attribute Context. */
N  uint16_t                    offset;             /**< Offset for the read operation. */
N} ble_gatts_evt_read_t;
N
N/**@brief Event structure for BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST. */
Ntypedef struct
N{
N  uint8_t                     type;             /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
N  union {
N    ble_gatts_evt_read_t      read;             /**< Attribute Read Parameters. */
N    ble_gatts_evt_write_t     write;            /**< Attribute Write Parameters. */
N  } request;
N} ble_gatts_evt_rw_authorize_request_t;
N
N/**@brief Event structure for BLE_GATTS_EVT_SYS_ATTR_MISSING. */
Ntypedef struct
N{
N  uint8_t hint;
N} ble_gatts_evt_sys_attr_missing_t;
N
N
N/**@brief Event structure for BLE_GATTS_EVT_HVC. */
Ntypedef struct
N{
N  uint16_t          handle;                       /**< Attribute Handle. */
N} ble_gatts_evt_hvc_t;
N
N/**@brief Event structure for BLE_GATTS_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
N} ble_gatts_evt_timeout_t;
N
N
N/**@brief GATT Server event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                       /**< Connection Handle on which event occurred. */
N  union
N  {
N    ble_gatts_evt_write_t                 write;              /**< Write Event Parameters. */
N    ble_gatts_evt_rw_authorize_request_t  authorize_request;  /**< Read or Write Authorize Request Parameters. */
N    ble_gatts_evt_sys_attr_missing_t      sys_attr_missing;   /**< System attributes missing. */
N    ble_gatts_evt_hvc_t                   hvc;                /**< Handle Value Confirmation Event Parameters. */
N    ble_gatts_evt_timeout_t               timeout;            /**< Timeout Event. */
N  } params;
N} ble_gatts_evt_t;
N
N
N/**@brief Add a service declaration to the local server ATT table.
N *
N * @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES.
N * @param[in] p_uuid    Pointer to service UUID.
N * @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to
N *       add a secondary service declaration that is not referenced by another service later in the ATT table.
N *
N * @return @ref NRF_SUCCESS Successfully added a service declaration.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const*const p_uuid, uint16_t *const p_handle));
Xuint32_t __svc(SD_BLE_GATTS_SERVICE_ADD) sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const*const p_uuid, uint16_t *const p_handle);
N
N
N/**@brief Add an include declaration to the local server ATT table.
N *
N * @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential addition is supported at this time). 
N *
N * @note The included service must already be present in the ATT table prior to this call.
N *
N * @param[in] service_handle    Handle of the service where the included service is to be placed, if BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] inc_srvc_handle   Handle of the included service.
N * @param[out] p_include_handle Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added an include declaration.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, self inclusions are not allowed.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N */
NSVCALL(SD_BLE_GATTS_INCLUDE_ADD, uint32_t, sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *const p_include_handle));
Xuint32_t __svc(SD_BLE_GATTS_INCLUDE_ADD) sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *const p_include_handle);
N
N
N/**@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the local server ATT table.
N *
N * @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential addition is supported at this time). 
N *
N * @note Several restrictions apply to the parameters, such as matching permissions between the user description descriptor and the writeable auxiliaries bits,
N *       readable (no security) and writeable (selectable) CCCDs and SCCDs and valid presentation format values.
N *
N * @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions.
N *
N * @param[in] service_handle    Handle of the service where the characteristic is to be placed, if BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] p_char_md         Characteristic metadata.
N * @param[in] p_attr_char_value Pointer to the attribute structure corresponding to the characteristic value.
N * @param[out] p_handles        Pointer to the structure where the assigned handles will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added a characteristic.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const*const p_char_md, ble_gatts_attr_t const*const p_attr_char_value, ble_gatts_char_handles_t *const p_handles));
Xuint32_t __svc(SD_BLE_GATTS_CHARACTERISTIC_ADD) sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const*const p_char_md, ble_gatts_attr_t const*const p_attr_char_value, ble_gatts_char_handles_t *const p_handles);
N
N
N/**@brief Add a descriptor to the local server ATT table.
N *
N * @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential addition is supported at this time). 
N *
N * @param[in] char_handle   Handle of the characteristic where the descriptor is to be placed, if BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] p_attr        Pointer to the attribute structure.
N * @param[out] p_handle     Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added a descriptor.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, a characteristic context is required.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_DESCRIPTOR_ADD, uint32_t, sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const * const p_attr, uint16_t* const p_handle));
Xuint32_t __svc(SD_BLE_GATTS_DESCRIPTOR_ADD) sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const * const p_attr, uint16_t* const p_handle);
N
N/**@brief Set the value of a given attribute.
N *
N * @param[in] handle    Attribute handle.
N * @param[in] offset    Offset in bytes to write from.
N * @param[in,out] p_len Length in bytes to be written, length in bytes written after successful return.
N * @param[in] p_value   Pointer to a buffer (at least len bytes long) containing the desired attribute value.
N *
N * @return @ref NRF_SUCCESS Successfully set the value of the attribute.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden handle supplied, certain attributes are not modifiable by the application.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_VALUE_SET, uint32_t, sd_ble_gatts_value_set(uint16_t handle, uint16_t offset, uint16_t* const p_len, uint8_t const * const p_value));
Xuint32_t __svc(SD_BLE_GATTS_VALUE_SET) sd_ble_gatts_value_set(uint16_t handle, uint16_t offset, uint16_t* const p_len, uint8_t const * const p_value);
N
N/**@brief Get the value of a given attribute.
N *
N * @param[in] handle     Attribute handle.
N * @param[in] offset     Offset in bytes to read from.
N * @param[in,out] p_len  Length in bytes to be read, length in bytes read after successful return.
N * @param[in,out] p_data Pointer to a buffer (at least len bytes long) where to store the attribute value.
N * 
N * @return @ref NRF_SUCCESS Successfully retrieved the value of the attribute.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N */
NSVCALL(SD_BLE_GATTS_VALUE_GET, uint32_t, sd_ble_gatts_value_get(uint16_t handle, uint16_t offset, uint16_t *const p_len, uint8_t* const p_data));
Xuint32_t __svc(SD_BLE_GATTS_VALUE_GET) sd_ble_gatts_value_get(uint16_t handle, uint16_t offset, uint16_t *const p_len, uint8_t* const p_data);
N
N/**@brief Notify or Indicate an attribute value.
N *
N * @details This function checks for the relevant Client Characteristic Configuration descriptor value to verify that the relevant operation
N *          (notification or indication) has been enabled by the client. It is also able to update the attribute value before issuing the PDU, so that
N *          the application can atomically perform a value update and a server initiated transaction with a single API call.
N *          If the application chooses to indicate an attribute value, a @ref BLE_GATTS_EVT_HVC will be sent up as soon as the confirmation arrives from
N *          the peer.
N *
N * @note    The local attribute value may be updated even if an outgoing packet is not sent to the peer due to an error during execution. 
N *          When receiveing the error codes @ref NRF_ERROR_INVALID_STATE, @ref NRF_ERROR_BUSY, @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING and 
N *          @ref BLE_ERROR_NO_TX_BUFFERS the ATT table has been updated.
N *          The caller can check whether the value has been updated by looking at the contents of *(p_hvx_params->p_len).
N *
N * @note    It is important to note that a notification will <b>consume an application buffer</b>, and will therefore 
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. An indication on the other hand will use the 
N *          standard server internal buffer and thus will only generate a @ref BLE_GATTS_EVT_HVC event as soon as the confirmation 
N *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_buffer_count_get for more details.
N *
N * @param[in] conn_handle  Connection handle.
N * @param[in] p_hvx_params Pointer to an HVx parameters structure. If the p_data member contains a non-NULL pointer the attribute value will be updated with
N *                         the contents pointed by it before sending the notification or indication.
N *
N * @return @ref NRF_SUCCESS Successfully queued a notification or indication for transmission, and optionally updated the attribute value.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate.
N * @return @ref BLE_ERROR_GATTS_INVALID_ATTR_TYPE Invalid attribute type(s) supplied, only characteristic values may be notified and indicated.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, notifications or indications must be enabled in the CCCD.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress.
N * @return @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS There are no available buffers to send the data, applies only to notifications.
N */
NSVCALL(SD_BLE_GATTS_HVX, uint32_t, sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const*const p_hvx_params));
Xuint32_t __svc(SD_BLE_GATTS_HVX) sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const*const p_hvx_params);
N
N/**@brief Indicate the Service Changed attribute value.
N *
N * @details This call will send a Handle Value Indication to one or more peers connected to inform them that the attribute
N *          table layout has changed. As soon as the peer has confirmed the indication, a @ref BLE_GATTS_EVT_SC_CONFIRM event will
N *          be issued.
N *
N * @note    Some of the restrictions and limitations that apply to @ref sd_ble_gatts_hvx also apply here.
N *
N * @param[in] conn_handle  Connection handle.
N * @param[in] start_handle Start of affected attribute handle range.
N * @param[in] end_handle   End of affected attribute handle range.
N *
N * @return @ref NRF_SUCCESS Successfully queued the Service Changed indication for transmission.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied, handles must be in the range populated by the application.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, notifications or indications must be enabled in the CCCD.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress.
N * @return @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N */
NSVCALL(SD_BLE_GATTS_SERVICE_CHANGED, uint32_t, sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle));
Xuint32_t __svc(SD_BLE_GATTS_SERVICE_CHANGED) sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle);
N
N/**@brief Respond to a Read/Write authorization request.
N *
N * @note This call should only be used as a response to a @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST event issued to the application.
N *
N * @param[in] conn_handle                 Connection handle.
N * @param[in] p_rw_authorize_reply_params Pointer to a structure with the attribute provided by the application.
N *
N * @return @ref NRF_SUCCESS               Successfully queued a response to the peer, and in the case of a write operation, ATT table updated.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_STATE   No authorization request pending.
N * @return @ref NRF_ERROR_INVALID_PARAM   Authorization op invalid,
N *                                         or for Read Authorization reply: requested handles not replied with,
N *                                         or for Write Authorization reply: handle supplied does not match requested handle.
N */
NSVCALL(SD_BLE_GATTS_RW_AUTHORIZE_REPLY, uint32_t, sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const*const p_rw_authorize_reply_params));
Xuint32_t __svc(SD_BLE_GATTS_RW_AUTHORIZE_REPLY) sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const*const p_rw_authorize_reply_params);
N
N
N/**@brief Update persistent system attribute information.
N *
N * @details Supply to the stack information about persistent system attributes.
N *          This call is legal in the connected state only, and is usually 
N *          made immediately after a connection is established and the bond identified.
N *          usually as a response to a BLE_GATTS_EVT_SYS_ATTR_MISSING.
N *
N *          p_sysattrs may point directly to the application's stored copy of the struct.
N *          If the pointer is NULL, the system attribute info is initialized, assuming that
N *          the application does not have any previously saved data for this bond.
N *
N * @note The state of persistent system attributes is reset upon connection and then remembered for its duration. 
N *
N * @note If this call returns with an error code different from @ref NRF_SUCCESS, the storage of persistent system attributes may have been completed only partially.
N *       This means that the state of the attribute table is undefined, and the application should either provide a new set of attributes using this same call or
N *       reset the SoftDevice to return to a known state.
N *
N * @param[in]  conn_handle        Connection handle.
N * @param[in]  p_sys_attr_data    Pointer to a saved copy of system attributes supplied to the stack, or NULL.
N * @param[in]  len                Size of data pointed by p_sys_attr_data, in octets. 
N *
N * @return @ref NRF_SUCCESS Successfully set the system attribute information.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */ 
NSVCALL(SD_BLE_GATTS_SYS_ATTR_SET, uint32_t, sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const*const p_sys_attr_data, uint16_t len)); 
Xuint32_t __svc(SD_BLE_GATTS_SYS_ATTR_SET) sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const*const p_sys_attr_data, uint16_t len); 
N
N 
N/**@brief Retrieve persistent system attribute information from the stack.
N *
N * @details This call is used to retrieve information about values to be stored perisistently by the application
N *          after a connection has been terminated. When a new connection is made to the same bond, the values
N *          should be restored using @ref sd_ble_gatts_sys_attr_set.
N *          The data should be read before any new advertising is started, or any new connection established. The connection handle for
N *          the previous now defunct connection will remain valid until a new one is created to allow this API call to refer to it.
N *
N * @param[in]     conn_handle       Connection handle of the recently terminated connection.
N * @param[in]     p_sys_attr_data   Pointer to a buffer where updated information about system attributes will be filled in. NULL can be provided to 
N *                                  obtain the length of the data
N * @param[in,out] p_len             Size of application buffer if p_sys_attr_data is not NULL. Unconditially updated to actual length of system attribute data.
N *
N * @return @ref NRF_SUCCESS Successfully retrieved the system attribute information.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_DATA_SIZE The system attribute information did not fit into the provided buffer.
N */ 
NSVCALL(SD_BLE_GATTS_SYS_ATTR_GET, uint32_t, sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t * const p_sys_attr_data, uint16_t* const p_len)); 
Xuint32_t __svc(SD_BLE_GATTS_SYS_ATTR_GET) sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t * const p_sys_attr_data, uint16_t* const p_len); 
N
N
N#endif // BLE_GATTS_H__
N
N/**
N  @}
N*/
L 28 "..\..\..\Software\Include\ble.h" 2
N
N/**
N * @brief Common API SVC numbers.
N */
Nenum BLE_COMMON_SVCS
N{
N  SD_BLE_EVT_GET  = BLE_SVC_BASE,       /**< Get an event from the pending events queue. */
X  SD_BLE_EVT_GET  = 0x50,        
N  SD_BLE_TX_BUFFER_COUNT_GET,           /**< Get the total number of available application transmission buffers from the stack. */
N  SD_BLE_UUID_VS_ADD,                   /**< Add a Vendor Specific UUID. */
N  SD_BLE_UUID_DECODE,                   /**< Decode UUID bytes. */
N  SD_BLE_UUID_ENCODE,                   /**< Encode UUID bytes. */
N  SD_BLE_VERSION_GET                    /**< Get the local version information (company id, LMP Version, LMP Subversion). */
N};
N
N/** @brief  Required pointer alignment for BLE Events.
N*/
N#define BLE_EVTS_PTR_ALIGNMENT    4
N
N/**
N * @brief BLE Module Independent Event IDs.
N */
Nenum BLE_COMMON_EVTS
N{
N  BLE_EVT_TX_COMPLETE  = BLE_EVT_BASE,  /**< Transmission Complete. */
X  BLE_EVT_TX_COMPLETE  = 0x01,   
N};
N
N
N/**
N * @brief TX complete event.
N */
Ntypedef struct
N{
N  uint8_t count;                        /**< Number of packets transmitted. */
N} ble_evt_tx_complete_t;
N
N
N/**@brief Event structure for events not associated with a specific function module. */
Ntypedef struct
N{
N  uint16_t conn_handle;                 /**< Connection Handle on which this event occured. */
N  union
N  {
N    ble_evt_tx_complete_t tx_complete;  /**< Transmission Complete. */
N  } params;
N} ble_common_evt_t;
N
N/**@brief BLE Event header. */
Ntypedef struct
N{
N  uint16_t evt_id;                      /**< Value from a BLE_<module>_EVT series. */
N  uint16_t evt_len;                     /**< Length in octets excluding this header. */
N} ble_evt_hdr_t;
N
N/**@brief Common BLE Event type, wrapping the module specific event reports. */
Ntypedef struct
N{
N  ble_evt_hdr_t header;                 /**< Event header. */
N  union
N  {
N    ble_common_evt_t  common_evt;         /**< Common Event, evt_id in BLE_EVT_* series. */
N    ble_gap_evt_t     gap_evt;            /**< GAP originated event, evt_id in BLE_GAP_EVT_* series. */
N    ble_l2cap_evt_t   l2cap_evt;          /**< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series. */
N    ble_gattc_evt_t   gattc_evt;          /**< GATT client originated event, evt_id in BLE_GATTC_EVT* series. */
N    ble_gatts_evt_t   gatts_evt;          /**< GATT server originated event, evt_id in BLE_GATTS_EVT* series. */
N  } evt;
N} ble_evt_t;
N
N
N/**
N * @brief Version Information.
N */
Ntypedef struct
N{
N  uint8_t   version_number;             /**< LMP Version number for BT 4.0 spec is 6 (https://www.bluetooth.org/technical/assignednumbers/link_layer.htm). */
N  uint16_t  company_id;                 /**< Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708). */
N  uint16_t  subversion_number;          /**< LMP Sub Version number corresponds to the SoftDevice Config ID. */
N} ble_version_t;
N
N
N/**@brief Get an event from the pending events queue.
N *
N * @param[in] p_dest Pointer to buffer to be filled in with an event, or NULL to retrieve the event length. This buffer <b>must be 4-byte aligned in memory</b>.
N * @param[in, out] p_len Pointer the length of the buffer, on return it is filled with the event length.
N *
N * @details This call allows the application to pull a BLE event from the BLE stack. The application is signalled that an event is 
N * available from the BLE Stack by the triggering of the SD_EVENT_IRQn interrupt (mapped to IRQ 22).
N * The application is free to choose whether to call this function from thread mode (main context) or directly from the Interrupt Service Routine
N * that maps to SD_EVENT_IRQn. In any case however, and because the BLE stack runs at a higher priority than the application, this function should be called
N * in a loop (until @ref NRF_ERROR_NOT_FOUND is returned) every time SD_EVENT_IRQn is raised to ensure that all available events are pulled from the stack. 
N * Failure to do so could potentially leave events in the internal queue without the application being aware of this fact.
N * Sizing the p_dest buffer is equally important, since the application needs to provide all the memory necessary for the event to be copied into
N * application memory. If the buffer provided is not large enough to fit the entire contents of the event, @ref NRF_ERROR_DATA_SIZE will be returned
N * and the application can then call again with a larger buffer size.
N * Please note that because of the variable length nature of some events, sizeof(ble_evt_t) will not always be large enough to fit certain events, 
N * and so it is the application's responsability to provide an amount of memory large enough so that the relevant event is copied in full.
N * The application may "peek" the event length by providing p_dest as a NULL pointer and inspecting the value of *p_len upon return.
N *
N * @note The pointer supplied must be aligned to the extend defined by @ref BLE_EVTS_PTR_ALIGNMENT
N *
N * @return @ref NRF_SUCCESS Event pulled and stored into the supplied buffer.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
N * @return @ref NRF_ERROR_NOT_FOUND No events ready to be pulled.
N * @return @ref NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
N */
NSVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t* p_dest, uint16_t *p_len));
Xuint32_t __svc(SD_BLE_EVT_GET) sd_ble_evt_get(uint8_t* p_dest, uint16_t *p_len);
N
N
N/**@brief Get the total number of available application transmission buffers in the BLE stack.
N *
N * @details This call allows the application to obtain the total number of
N *          transmission buffers available for application data. Please note that
N *          this does not give the number of free buffers, but rather the total amount of them.
N *          The application has two options to handle its own application transmission buffers:
N *          - Use a simple arithmetic calculation: at boot time the application should use this function
N *          to find out the total amount of buffers available to it and store it in a variable.
N *          Every time a packet that consumes an application buffer is sent using any of the 
N *          exposed functions in this BLE API, the application should decrement that variable.
N *          Conversely, whenever a @ref BLE_EVT_TX_COMPLETE event is received by the application
N *          it should retrieve the count field in such event and add that number to the same
N *          variable storing the number of available packets.
N *          This mechanism allows the application to be aware at any time of the number of
N *          application packets available in the BLE stack's internal buffers, and therefore
N *          it can know with certainty whether it is possible to send more data or it has to
N *          wait for a @ref BLE_EVT_TX_COMPLETE event before it proceeds.
N *          - Choose to simply not keep track of available buffers at all, and instead handle the 
N *          @ref BLE_ERROR_NO_TX_BUFFERS error by queueing the packet to be transmitted and 
N *          try again as soon as a @ref BLE_EVT_TX_COMPLETE event arrives.
N *
N *          The API functions that <b>may</b> consume an application buffer depending on 
N *          the parameters supplied to them can be found below:
N *
N *          - @ref sd_ble_gattc_write (write witout response only)
N *          - @ref sd_ble_gatts_hvx (notifications only)
N *          - @ref sd_ble_l2cap_tx (all packets)
N *
N * @param[out] p_count Pointer to a uint8_t which will contain the number of application transmission buffers upon
N *                     successful return.
N *
N * @return @ref NRF_SUCCESS Number of application transmission buffers retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_TX_BUFFER_COUNT_GET, uint32_t, sd_ble_tx_buffer_count_get(uint8_t* p_count));
Xuint32_t __svc(SD_BLE_TX_BUFFER_COUNT_GET) sd_ble_tx_buffer_count_get(uint8_t* p_count);
N
N
N/**@brief Add a Vendor Specific UUID.
N *
N * @details This call enables the application to add a vendor specific UUID to the BLE stack's table,
N *          for later use all other modules and APIs. This then allows the application to use the shorter,
N *          24-bit @ref ble_uuid_t format when dealing with both 16-bit and 128-bit UUIDs without having to
N *          check for lengths and having split code paths. The way that this is accomplished is by extending the 
N *          grouping mechanism that the Bluetooth SIG standard base UUID uses for all other 128-bit UUIDs. The 
N *          type field in the @ref ble_uuid_t structure is an index (relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN) 
N *          to the table populated by multiple calls to this function, and the uuid field in the same structure contains the 2 bytes 
N *          (byte 12 and byte 13) corresponding to the TimeLow portion of the UUID. The number of possible 128-bit 
N *          UUIDs available to the application is therefore the number of Vendor Specific UUIDs added with the help
N *          of this function times 65536, although restricted to modifying the TimeLow bytes for each of the entries in the supplied array.
N *
N * @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by 
N * the 16-bit uuid field in @ref ble_uuid_t.
N *
N *
N * @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific UUID disregarding
N *                          the TimeLow (bytes 12 and 13) portion of it.
N * @param[out] p_uuid_type  Pointer where the type field in @ref ble_uuid_t corresponding to this UUID will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added the Vendor Specific UUID.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_NO_MEM If the size exceeds the number of free slots for VS UUIDs.
N * @return @ref NRF_ERROR_INVALID_LENGTH If vs_uuid_count is 0.
N * @return @ref NRF_ERROR_INVALID_ADDR if p_vs_uuids is NULL or invalid.
N */
NSVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const * const p_vs_uuid, uint8_t * const p_uuid_type));
Xuint32_t __svc(SD_BLE_UUID_VS_ADD) sd_ble_uuid_vs_add(ble_uuid128_t const * const p_vs_uuid, uint8_t * const p_uuid_type);
N
N
N/** @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure.
N * 
N * @details The raw UUID bytes excluding the TimeLow portion (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared 
N * to the corresponding ones in each entry of the table of vendor specific UUIDs pouplated with @ref sd_ble_uuid_vs_add 
N * to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index 
N * relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type. 
N *
N * @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE.
N *
N * @param[in]      uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes).
N * @param[in]      p_uuid_le   Pointer pointing to little endian raw UUID bytes.
N * @param[in,out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in.
N *
N * @return @ref NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_LENGTH Invalid UUID length.
N * @return @ref NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs.
N */                                                 
NSVCALL(SD_BLE_UUID_DECODE, uint32_t, sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const * const p_uuid_le, ble_uuid_t * const p_uuid));
Xuint32_t __svc(SD_BLE_UUID_DECODE) sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const * const p_uuid_le, ble_uuid_t * const p_uuid);
N
N
N/** @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit).
N *
N * @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validitiy and size of p_uuid is computed.
N *
N * @param[in]      p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes.
N * @param[out]     p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes).
N * @param[out]     p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully encoded into the buffer.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid UUID type.
N */
NSVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const * const p_uuid, uint8_t * const  p_uuid_le_len, uint8_t * const p_uuid_le));
Xuint32_t __svc(SD_BLE_UUID_ENCODE) sd_ble_uuid_encode(ble_uuid_t const * const p_uuid, uint8_t * const p_uuid_le_len, uint8_t * const p_uuid_le);
N
N
N/**@brief Get Version Information.
N *
N * @details This call allows the application to get the BLE stack version information.
N *
N * @param[in] p_version Pointer to ble_version_t structure to be filled in.
N *
N * @return @ref NRF_SUCCESS  Version information stored successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy (typically doing a locally-initiated disconnection procedure).
N */
NSVCALL(SD_BLE_VERSION_GET, uint32_t, sd_ble_version_get(ble_version_t * p_version));
Xuint32_t __svc(SD_BLE_VERSION_GET) sd_ble_version_get(ble_version_t * p_version);
N
N#endif /* BLE_H__ */
N
N/**
N  @}
N  @}
N*/
L 36 "..\..\..\Software\Include\ble_nus.h" 2
N#include "ble_srv_common.h"
L 1 "..\..\..\Software\Include\ble_srv_common.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_srv_common 'Common service definitions'
N * @{
N * @ingroup ble_sdk_srv
N * @brief Constants, type definitions and functions that are common to all services.
N */
N
N#ifndef BLE_SRV_COMMON_H__
N#define BLE_SRV_COMMON_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "ble_types.h"
N#include "app_util.h"
L 1 "..\..\..\Software\Include\app_util.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_H__
N#define APP_UTIL_H__
N
N#include <stdint.h>
N#include "compiler_abstraction.h"
L 1 "..\..\..\Software\Include\compiler_abstraction.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic
N * Semiconductor ASA.Terms and conditions of usage are described in detail
N * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef _COMPILER_ABSTRACTION_H
N#define _COMPILER_ABSTRACTION_H
N
N/*lint ++flb "Enter library region" */
N
N#if defined ( __CC_ARM )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S  #define __current_sp() __get_SP()
S  
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
Sstatic __INLINE unsigned int __current_sp(void)
S  {
S      register unsigned sp asm("sp");
S      return sp;
S  }
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/*lint --flb "Leave library region" */
N
N#endif
L 27 "..\..\..\Software\Include\app_util.h" 2
N#include "nrf51.h"
L 1 "..\..\..\Software\Include\nrf51.h" 1
N
N/****************************************************************************************************//**
N * @file     nRF51.h
N *
N * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
N *           nRF51 from Nordic Semiconductor.
N *
N * @version  V2.4C
N * @date     26. September 2013
N *
N * @note     Generated with SVDConv V2.77p 
N *           from CMSIS SVD File 'nRF51.xml' Version 2.4C,
N *
N * @par      Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved. 
N *           
N *           The information contained herein is property of Nordic Semiconductor ASA. 
N *           Terms and conditions of usage are described in detail in NORDIC 
N *           SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
N *           
N *           Licensees are granted free, non-transferable use of the information. NO 
N *           WARRANTY of ANY KIND is provided. This heading must NOT be removed from 
N *           the file. 
N *           
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup Nordic Semiconductor
N  * @{
N  */
N
N/** @addtogroup nRF51
N  * @{
N  */
N
N#ifndef NRF51_H
N#define NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* ----------------------  nRF51 Specific Interrupt Numbers  ---------------------- */
N  POWER_CLOCK_IRQn              =   0,              /*!<   0  POWER_CLOCK                                                      */
N  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
N  UART0_IRQn                    =   2,              /*!<   2  UART0                                                            */
N  SPI0_TWI0_IRQn                =   3,              /*!<   3  SPI0_TWI0                                                        */
N  SPI1_TWI1_IRQn                =   4,              /*!<   4  SPI1_TWI1                                                        */
N  GPIOTE_IRQn                   =   6,              /*!<   6  GPIOTE                                                           */
N  ADC_IRQn                      =   7,              /*!<   7  ADC                                                              */
N  TIMER0_IRQn                   =   8,              /*!<   8  TIMER0                                                           */
N  TIMER1_IRQn                   =   9,              /*!<   9  TIMER1                                                           */
N  TIMER2_IRQn                   =  10,              /*!<  10  TIMER2                                                           */
N  RTC0_IRQn                     =  11,              /*!<  11  RTC0                                                             */
N  TEMP_IRQn                     =  12,              /*!<  12  TEMP                                                             */
N  RNG_IRQn                      =  13,              /*!<  13  RNG                                                              */
N  ECB_IRQn                      =  14,              /*!<  14  ECB                                                              */
N  CCM_AAR_IRQn                  =  15,              /*!<  15  CCM_AAR                                                          */
N  WDT_IRQn                      =  16,              /*!<  16  WDT                                                              */
N  RTC1_IRQn                     =  17,              /*!<  17  RTC1                                                             */
N  QDEC_IRQn                     =  18,              /*!<  18  QDEC                                                             */
N  LPCOMP_COMP_IRQn              =  19,              /*!<  19  LPCOMP_COMP                                                      */
N  SWI0_IRQn                     =  20,              /*!<  20  SWI0                                                             */
N  SWI1_IRQn                     =  21,              /*!<  21  SWI1                                                             */
N  SWI2_IRQn                     =  22,              /*!<  22  SWI2                                                             */
N  SWI3_IRQn                     =  23,              /*!<  23  SWI3                                                             */
N  SWI4_IRQn                     =  24,              /*!<  24  SWI4                                                             */
N  SWI5_IRQn                     =  25               /*!<  25  SWI5                                                             */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the cm0 Processor and Core Peripherals---------------- */
N#define __CM0_REV                 0x0301            /*!< Cortex-M0 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include <core_cm0.h>                               /*!< Cortex-M0 processor and core peripherals                              */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.02
N * @date     16. July 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.02
N * @date     08. May 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5020028 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 113 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.02
N * @date     24. May 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5020028 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 114 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 102 "..\..\..\Software\Include\nrf51.h" 2
N#include "system_nrf51.h"                           /*!< nRF51 System                                                          */
L 1 "..\..\..\Software\Include\system_nrf51.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef SYSTEM_NRF51_H
N#define SYSTEM_NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_NRF51_H */
L 103 "..\..\..\Software\Include\nrf51.h" 2
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
Ntypedef struct {
N  __IO uint32_t  CPU0;                              /*!< Configurable priority configuration register for CPU0.                */
X  volatile uint32_t  CPU0;                               
N  __IO uint32_t  SPIS1;                             /*!< Configurable priority configuration register for SPIS1.               */
X  volatile uint32_t  SPIS1;                              
N  __IO uint32_t  RADIO;                             /*!< Configurable priority configuration register for RADIO.               */
X  volatile uint32_t  RADIO;                              
N  __IO uint32_t  ECB;                               /*!< Configurable priority configuration register for ECB.                 */
X  volatile uint32_t  ECB;                                
N  __IO uint32_t  CCM;                               /*!< Configurable priority configuration register for CCM.                 */
X  volatile uint32_t  CCM;                                
N  __IO uint32_t  AAR;                               /*!< Configurable priority configuration register for AAR.                 */
X  volatile uint32_t  AAR;                                
N} AMLI_RAMPRI_Type;
N
Ntypedef struct {
N  __O  uint32_t  EN;                                /*!< Enable channel group.                                                 */
X  volatile  uint32_t  EN;                                 
N  __O  uint32_t  DIS;                               /*!< Disable channel group.                                                */
X  volatile  uint32_t  DIS;                                
N} PPI_TASKS_CHG_Type;
N
Ntypedef struct {
N  __IO uint32_t  EEP;                               /*!< Channel event end-point.                                              */
X  volatile uint32_t  EEP;                                
N  __IO uint32_t  TEP;                               /*!< Channel task end-point.                                               */
X  volatile uint32_t  TEP;                                
N} PPI_CH_Type;
N
N
N/* ================================================================================ */
N/* ================                      POWER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Power Control. (POWER)
N  */
N
Ntypedef struct {                                    /*!< POWER Structure                                                       */
N  __I  uint32_t  RESERVED0[30];
X  volatile const  uint32_t  RESERVED0[30];
N  __O  uint32_t  TASKS_CONSTLAT;                    /*!< Enable constant latency mode.                                         */
X  volatile  uint32_t  TASKS_CONSTLAT;                     
N  __O  uint32_t  TASKS_LOWPWR;                      /*!< Enable low power mode (variable latency).                             */
X  volatile  uint32_t  TASKS_LOWPWR;                       
N  __I  uint32_t  RESERVED1[34];
X  volatile const  uint32_t  RESERVED1[34];
N  __IO uint32_t  EVENTS_POFWARN;                    /*!< Power failure warning.                                                */
X  volatile uint32_t  EVENTS_POFWARN;                     
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __IO uint32_t  RESETREAS;                         /*!< Reset reason.                                                         */
X  volatile uint32_t  RESETREAS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __O  uint32_t  SYSTEMOFF;                         /*!< System off register.                                                  */
X  volatile  uint32_t  SYSTEMOFF;                          
N  __I  uint32_t  RESERVED5[3];
X  volatile const  uint32_t  RESERVED5[3];
N  __IO uint32_t  POFCON;                            /*!< Power failure configuration.                                          */
X  volatile uint32_t  POFCON;                             
N  __I  uint32_t  RESERVED6[2];
X  volatile const  uint32_t  RESERVED6[2];
N  __IO uint32_t  GPREGRET;                          /*!< General purpose retention register. This register is a retained
X  volatile uint32_t  GPREGRET;                          
N                                                         register.                                                             */
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __IO uint32_t  RAMON;                             /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMON;                              
N  __I  uint32_t  RESERVED8[7];
X  volatile const  uint32_t  RESERVED8[7];
N  __IO uint32_t  RESET;                             /*!< Pin reset functionality configuration register. This register
X  volatile uint32_t  RESET;                             
N                                                         is a retained register.                                               */
N  __I  uint32_t  RESERVED9[12];
X  volatile const  uint32_t  RESERVED9[12];
N  __IO uint32_t  DCDCEN;                            /*!< DCDC converter enable configuration register.                         */
X  volatile uint32_t  DCDCEN;                             
N} NRF_POWER_Type;
N
N
N/* ================================================================================ */
N/* ================                      CLOCK                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Clock control. (CLOCK)
N  */
N
Ntypedef struct {                                    /*!< CLOCK Structure                                                       */
N  __O  uint32_t  TASKS_HFCLKSTART;                  /*!< Start HFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_HFCLKSTART;                   
N  __O  uint32_t  TASKS_HFCLKSTOP;                   /*!< Stop HFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_HFCLKSTOP;                    
N  __O  uint32_t  TASKS_LFCLKSTART;                  /*!< Start LFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_LFCLKSTART;                   
N  __O  uint32_t  TASKS_LFCLKSTOP;                   /*!< Stop LFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_LFCLKSTOP;                    
N  __O  uint32_t  TASKS_CAL;                         /*!< Start calibration of LFCLK RC oscillator.                             */
X  volatile  uint32_t  TASKS_CAL;                          
N  __O  uint32_t  TASKS_CTSTART;                     /*!< Start calibration timer.                                              */
X  volatile  uint32_t  TASKS_CTSTART;                      
N  __O  uint32_t  TASKS_CTSTOP;                      /*!< Stop calibration timer.                                               */
X  volatile  uint32_t  TASKS_CTSTOP;                       
N  __I  uint32_t  RESERVED0[57];
X  volatile const  uint32_t  RESERVED0[57];
N  __IO uint32_t  EVENTS_HFCLKSTARTED;               /*!< HFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_HFCLKSTARTED;                
N  __IO uint32_t  EVENTS_LFCLKSTARTED;               /*!< LFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_LFCLKSTARTED;                
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __IO uint32_t  EVENTS_DONE;                       /*!< Callibration of LFCLK RC oscillator completed.                        */
X  volatile uint32_t  EVENTS_DONE;                        
N  __IO uint32_t  EVENTS_CTTO;                       /*!< Callibration timer timeout.                                           */
X  volatile uint32_t  EVENTS_CTTO;                        
N  __I  uint32_t  RESERVED2[124];
X  volatile const  uint32_t  RESERVED2[124];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __I  uint32_t  HFCLKSTAT;                         /*!< High frequency clock status.                                          */
X  volatile const  uint32_t  HFCLKSTAT;                          
N  __I  uint32_t  RESERVED4[2];
X  volatile const  uint32_t  RESERVED4[2];
N  __I  uint32_t  LFCLKSTAT;                         /*!< Low frequency clock status.                                           */
X  volatile const  uint32_t  LFCLKSTAT;                          
N  __I  uint32_t  RESERVED5[63];
X  volatile const  uint32_t  RESERVED5[63];
N  __IO uint32_t  LFCLKSRC;                          /*!< Clock source for the LFCLK clock.                                     */
X  volatile uint32_t  LFCLKSRC;                           
N  __I  uint32_t  RESERVED6[7];
X  volatile const  uint32_t  RESERVED6[7];
N  __IO uint32_t  CTIV;                              /*!< Calibration timer interval.                                           */
X  volatile uint32_t  CTIV;                               
N  __I  uint32_t  RESERVED7[5];
X  volatile const  uint32_t  RESERVED7[5];
N  __IO uint32_t  XTALFREQ;                          /*!< Crystal frequency.                                                    */
X  volatile uint32_t  XTALFREQ;                           
N} NRF_CLOCK_Type;
N
N
N/* ================================================================================ */
N/* ================                       MPU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Memory Protection Unit. (MPU)
N  */
N
Ntypedef struct {                                    /*!< MPU Structure                                                         */
N  __I  uint32_t  RESERVED0[330];
X  volatile const  uint32_t  RESERVED0[330];
N  __IO uint32_t  PERR0;                             /*!< Configuration of peripherals in mpu regions.                          */
X  volatile uint32_t  PERR0;                              
N  __IO uint32_t  RLENR0;                            /*!< Length of RAM region 0.                                               */
X  volatile uint32_t  RLENR0;                             
N  __I  uint32_t  RESERVED1[52];
X  volatile const  uint32_t  RESERVED1[52];
N  __IO uint32_t  PROTENSET0;                        /*!< Protection bit enable set register for low addresses.                 */
X  volatile uint32_t  PROTENSET0;                         
N  __IO uint32_t  PROTENSET1;                        /*!< Protection bit enable set register for high addresses.                */
X  volatile uint32_t  PROTENSET1;                         
N  __IO uint32_t  DISABLEINDEBUG;                    /*!< Disable protection mechanism in debug mode.                           */
X  volatile uint32_t  DISABLEINDEBUG;                     
N} NRF_MPU_Type;
N
N
N/* ================================================================================ */
N/* ================                       PU                       ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Patch unit. (PU)
N  */
N
Ntypedef struct {                                    /*!< PU Structure                                                          */
N  __I  uint32_t  RESERVED0[384];
X  volatile const  uint32_t  RESERVED0[384];
N  __IO uint32_t  REPLACEADDR[8];                    /*!< Address of first instruction to replace.                              */
X  volatile uint32_t  REPLACEADDR[8];                     
N  __I  uint32_t  RESERVED1[24];
X  volatile const  uint32_t  RESERVED1[24];
N  __IO uint32_t  PATCHADDR[8];                      /*!< Relative address of patch instructions.                               */
X  volatile uint32_t  PATCHADDR[8];                       
N  __I  uint32_t  RESERVED2[24];
X  volatile const  uint32_t  RESERVED2[24];
N  __IO uint32_t  PATCHEN;                           /*!< Patch enable register.                                                */
X  volatile uint32_t  PATCHEN;                            
N  __IO uint32_t  PATCHENSET;                        /*!< Patch enable register.                                                */
X  volatile uint32_t  PATCHENSET;                         
N  __IO uint32_t  PATCHENCLR;                        /*!< Patch disable register.                                               */
X  volatile uint32_t  PATCHENCLR;                         
N} NRF_PU_Type;
N
N
N/* ================================================================================ */
N/* ================                      AMLI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AHB Multi-Layer Interface. (AMLI)
N  */
N
Ntypedef struct {                                    /*!< AMLI Structure                                                        */
N  __I  uint32_t  RESERVED0[896];
X  volatile const  uint32_t  RESERVED0[896];
N  AMLI_RAMPRI_Type RAMPRI;                          /*!< RAM configurable priority configuration structure.                    */
N} NRF_AMLI_Type;
N
N
N/* ================================================================================ */
N/* ================                      RADIO                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief The radio. (RADIO)
N  */
N
Ntypedef struct {                                    /*!< RADIO Structure                                                       */
N  __O  uint32_t  TASKS_TXEN;                        /*!< Enable radio in TX mode.                                              */
X  volatile  uint32_t  TASKS_TXEN;                         
N  __O  uint32_t  TASKS_RXEN;                        /*!< Enable radio in RX mode.                                              */
X  volatile  uint32_t  TASKS_RXEN;                         
N  __O  uint32_t  TASKS_START;                       /*!< Start radio.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop radio.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable radio.                                                        */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_RSSISTART;                   /*!< Start the RSSI and take one sample of the receive signal strength.    */
X  volatile  uint32_t  TASKS_RSSISTART;                    
N  __O  uint32_t  TASKS_RSSISTOP;                    /*!< Stop the RSSI measurement.                                            */
X  volatile  uint32_t  TASKS_RSSISTOP;                     
N  __O  uint32_t  TASKS_BCSTART;                     /*!< Start the bit counter.                                                */
X  volatile  uint32_t  TASKS_BCSTART;                      
N  __O  uint32_t  TASKS_BCSTOP;                      /*!< Stop the bit counter.                                                 */
X  volatile  uint32_t  TASKS_BCSTOP;                       
N  __I  uint32_t  RESERVED0[55];
X  volatile const  uint32_t  RESERVED0[55];
N  __IO uint32_t  EVENTS_READY;                      /*!< Ready event.                                                          */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address event.                                                        */
X  volatile uint32_t  EVENTS_ADDRESS;                     
N  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Payload event.                                                        */
X  volatile uint32_t  EVENTS_PAYLOAD;                     
N  __IO uint32_t  EVENTS_END;                        /*!< End event.                                                            */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DISABLED;                   /*!< Disable event.                                                        */
X  volatile uint32_t  EVENTS_DISABLED;                    
N  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet.          */
X  volatile uint32_t  EVENTS_DEVMATCH;                    
N  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet.         */
X  volatile uint32_t  EVENTS_DEVMISS;                     
N  __IO uint32_t  EVENTS_RSSIEND;                    /*!< Sampling of the receive signal strength complete. A new RSSI
X  volatile uint32_t  EVENTS_RSSIEND;                    
N                                                         sample is ready for readout at the RSSISAMPLE register.               */
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_BCMATCH;                    /*!< Bit counter reached bit count value specified in BC register.         */
X  volatile uint32_t  EVENTS_BCMATCH;                     
N  __I  uint32_t  RESERVED2[53];
X  volatile const  uint32_t  RESERVED2[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the radio.                                               */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[61];
X  volatile const  uint32_t  RESERVED4[61];
N  __I  uint32_t  CRCSTATUS;                         /*!< CRC status of received packet.                                        */
X  volatile const  uint32_t  CRCSTATUS;                          
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __I  uint32_t  RXMATCH;                           /*!< Received address.                                                     */
X  volatile const  uint32_t  RXMATCH;                            
N  __I  uint32_t  RXCRC;                             /*!< Received CRC.                                                         */
X  volatile const  uint32_t  RXCRC;                              
N  __IO uint32_t  DAI;                               /*!< Device address match index.                                           */
X  volatile uint32_t  DAI;                                
N  __I  uint32_t  RESERVED6[60];
X  volatile const  uint32_t  RESERVED6[60];
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer. Decision point: START task.                           */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  FREQUENCY;                         /*!< Frequency.                                                            */
X  volatile uint32_t  FREQUENCY;                          
N  __IO uint32_t  TXPOWER;                           /*!< Output power.                                                         */
X  volatile uint32_t  TXPOWER;                            
N  __IO uint32_t  MODE;                              /*!< Data rate and modulation.                                             */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  PCNF0;                             /*!< Packet configuration 0.                                               */
X  volatile uint32_t  PCNF0;                              
N  __IO uint32_t  PCNF1;                             /*!< Packet configuration 1.                                               */
X  volatile uint32_t  PCNF1;                              
N  __IO uint32_t  BASE0;                             /*!< Radio base address 0. Decision point: START task.                     */
X  volatile uint32_t  BASE0;                              
N  __IO uint32_t  BASE1;                             /*!< Radio base address 1. Decision point: START task.                     */
X  volatile uint32_t  BASE1;                              
N  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0 to 3.                          */
X  volatile uint32_t  PREFIX0;                            
N  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4 to 7.                          */
X  volatile uint32_t  PREFIX1;                            
N  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select.                                              */
X  volatile uint32_t  TXADDRESS;                          
N  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select.                                               */
X  volatile uint32_t  RXADDRESSES;                        
N  __IO uint32_t  CRCCNF;                            /*!< CRC configuration.                                                    */
X  volatile uint32_t  CRCCNF;                             
N  __IO uint32_t  CRCPOLY;                           /*!< CRC polynomial.                                                       */
X  volatile uint32_t  CRCPOLY;                            
N  __IO uint32_t  CRCINIT;                           /*!< CRC initial value.                                                    */
X  volatile uint32_t  CRCINIT;                            
N  __IO uint32_t  TEST;                              /*!< Test features enable register.                                        */
X  volatile uint32_t  TEST;                               
N  __IO uint32_t  TIFS;                              /*!< Inter Frame Spacing in microseconds.                                  */
X  volatile uint32_t  TIFS;                               
N  __IO uint32_t  RSSISAMPLE;                        /*!< RSSI sample.                                                          */
X  volatile uint32_t  RSSISAMPLE;                         
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __I  uint32_t  STATE;                             /*!< Current radio state.                                                  */
X  volatile const  uint32_t  STATE;                              
N  __IO uint32_t  DATAWHITEIV;                       /*!< Data whitening initial value.                                         */
X  volatile uint32_t  DATAWHITEIV;                        
N  __I  uint32_t  RESERVED8[2];
X  volatile const  uint32_t  RESERVED8[2];
N  __IO uint32_t  BCC;                               /*!< Bit counter compare.                                                  */
X  volatile uint32_t  BCC;                                
N  __I  uint32_t  RESERVED9[39];
X  volatile const  uint32_t  RESERVED9[39];
N  __IO uint32_t  DAB[8];                            /*!< Device address base segment.                                          */
X  volatile uint32_t  DAB[8];                             
N  __IO uint32_t  DAP[8];                            /*!< Device address prefix.                                                */
X  volatile uint32_t  DAP[8];                             
N  __IO uint32_t  DACNF;                             /*!< Device address match configuration.                                   */
X  volatile uint32_t  DACNF;                              
N  __I  uint32_t  RESERVED10[56];
X  volatile const  uint32_t  RESERVED10[56];
N  __IO uint32_t  OVERRIDE0;                         /*!< Trim value override register 0.                                       */
X  volatile uint32_t  OVERRIDE0;                          
N  __IO uint32_t  OVERRIDE1;                         /*!< Trim value override register 1.                                       */
X  volatile uint32_t  OVERRIDE1;                          
N  __IO uint32_t  OVERRIDE2;                         /*!< Trim value override register 2.                                       */
X  volatile uint32_t  OVERRIDE2;                          
N  __IO uint32_t  OVERRIDE3;                         /*!< Trim value override register 3.                                       */
X  volatile uint32_t  OVERRIDE3;                          
N  __IO uint32_t  OVERRIDE4;                         /*!< Trim value override register 4.                                       */
X  volatile uint32_t  OVERRIDE4;                          
N  __I  uint32_t  RESERVED11[561];
X  volatile const  uint32_t  RESERVED11[561];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RADIO_Type;
N
N
N/* ================================================================================ */
N/* ================                      UART                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Universal Asynchronous Receiver/Transmitter, version 1.0. (UART)
N  */
N
Ntypedef struct {                                    /*!< UART Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver.                                                  */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver.                                                   */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter.                                               */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter.                                                */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend UART.                                                         */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __I  uint32_t  RESERVED1[58];
X  volatile const  uint32_t  RESERVED1[58];
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD.                                                 */
X  volatile uint32_t  EVENTS_RXDRDY;                      
N  __I  uint32_t  RESERVED2[4];
X  volatile const  uint32_t  RESERVED2[4];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD.                                                   */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout.                                                     */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5[111];
X  volatile const  uint32_t  RESERVED5[111];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED6[93];
X  volatile const  uint32_t  RESERVED6[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source. Write error field to 1 to clear error.                  */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED7[31];
X  volatile const  uint32_t  RESERVED7[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART and acquire IOs.                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  PSELRTS;                           /*!< Pin select for RTS.                                                   */
X  volatile uint32_t  PSELRTS;                            
N  __IO uint32_t  PSELTXD;                           /*!< Pin select for TXD.                                                   */
X  volatile uint32_t  PSELTXD;                            
N  __IO uint32_t  PSELCTS;                           /*!< Pin select for CTS.                                                   */
X  volatile uint32_t  PSELCTS;                            
N  __IO uint32_t  PSELRXD;                           /*!< Pin select for RXD.                                                   */
X  volatile uint32_t  PSELRXD;                            
N  __I  uint32_t  RXD;                               /*!< RXD register. On read action the buffer pointer is displaced.
X  volatile const  uint32_t  RXD;                               
N                                                         Once read the character is consummed. If read when no character
N                                                          available, the UART will stop working.                               */
N  __O  uint32_t  TXD;                               /*!< TXD register.                                                         */
X  volatile  uint32_t  TXD;                                
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  BAUDRATE;                          /*!< UART Baudrate.                                                        */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED10[17];
X  volatile const  uint32_t  RESERVED10[17];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control register.           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED11[675];
X  volatile const  uint32_t  RESERVED11[675];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_UART_Type;
N
N
N/* ================================================================================ */
N/* ================                       SPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI master 0. (SPI)
N  */
N
Ntypedef struct {                                    /*!< SPI Structure                                                         */
N  __I  uint32_t  RESERVED0[66];
X  volatile const  uint32_t  RESERVED0[66];
N  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __I  uint32_t  RESERVED1[126];
X  volatile const  uint32_t  RESERVED1[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __IO uint32_t  RXD;                               /*!< RX data.                                                              */
X  volatile uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data.                                                              */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED7[681];
X  volatile const  uint32_t  RESERVED7[681];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       TWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Two-wire interface master 0. (TWI)
N  */
N
Ntypedef struct {                                    /*!< TWI Structure                                                         */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start 2-Wire master receive sequence.                                 */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start 2-Wire master transmit sequence.                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop 2-Wire transaction.                                              */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend 2-Wire transaction.                                           */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume 2-Wire transaction.                                            */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< Two-wire stopped.                                                     */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_RXDREADY;                   /*!< Two-wire ready to deliver new RXD byte received.                      */
X  volatile uint32_t  EVENTS_RXDREADY;                    
N  __I  uint32_t  RESERVED4[4];
X  volatile const  uint32_t  RESERVED4[4];
N  __IO uint32_t  EVENTS_TXDSENT;                    /*!< Two-wire finished sending last TXD byte.                              */
X  volatile uint32_t  EVENTS_TXDSENT;                     
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Two-wire error detected.                                              */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_BB;                         /*!< Two-wire byte boundary.                                               */
X  volatile uint32_t  EVENTS_BB;                          
N  __I  uint32_t  RESERVED7[49];
X  volatile const  uint32_t  RESERVED7[49];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for TWI.                                                    */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[64];
X  volatile const  uint32_t  RESERVED8[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[110];
X  volatile const  uint32_t  RESERVED9[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Two-wire error source. Write error field to 1 to clear error.         */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED10[14];
X  volatile const  uint32_t  RESERVED10[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable two-wire master.                                               */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  PSELSCL;                           /*!< Pin select for SCL.                                                   */
X  volatile uint32_t  PSELSCL;                            
N  __IO uint32_t  PSELSDA;                           /*!< Pin select for SDA.                                                   */
X  volatile uint32_t  PSELSDA;                            
N  __I  uint32_t  RESERVED12[2];
X  volatile const  uint32_t  RESERVED12[2];
N  __IO uint32_t  RXD;                               /*!< RX data register.                                                     */
X  volatile uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data register.                                                     */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  __IO uint32_t  FREQUENCY;                         /*!< Two-wire frequency.                                                   */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED14[24];
X  volatile const  uint32_t  RESERVED14[24];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the two-wire transfer.                                */
X  volatile uint32_t  ADDRESS;                            
N  __I  uint32_t  RESERVED15[668];
X  volatile const  uint32_t  RESERVED15[668];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI slave 1. (SPIS)
N  */
N
Ntypedef struct {                                    /*!< SPIS Structure                                                        */
N  __I  uint32_t  RESERVED0[9];
X  volatile const  uint32_t  RESERVED0[9];
N  __O  uint32_t  TASKS_ACQUIRE;                     /*!< Acquire SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_ACQUIRE;                      
N  __O  uint32_t  TASKS_RELEASE;                     /*!< Release SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_RELEASE;                      
N  __I  uint32_t  RESERVED1[54];
X  volatile const  uint32_t  RESERVED1[54];
N  __IO uint32_t  EVENTS_END;                        /*!< Granted transaction completed.                                        */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED2[8];
X  volatile const  uint32_t  RESERVED2[8];
N  __IO uint32_t  EVENTS_ACQUIRED;                   /*!< Semaphore acquired.                                                   */
X  volatile uint32_t  EVENTS_ACQUIRED;                    
N  __I  uint32_t  RESERVED3[53];
X  volatile const  uint32_t  RESERVED3[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for SPIS.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED4[64];
X  volatile const  uint32_t  RESERVED4[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED5[61];
X  volatile const  uint32_t  RESERVED5[61];
N  __I  uint32_t  SEMSTAT;                           /*!< Semaphore status.                                                     */
X  volatile const  uint32_t  SEMSTAT;                            
N  __I  uint32_t  RESERVED6[15];
X  volatile const  uint32_t  RESERVED6[15];
N  __IO uint32_t  STATUS;                            /*!< Status from last transaction.                                         */
X  volatile uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED7[47];
X  volatile const  uint32_t  RESERVED7[47];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPIS.                                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELCSN;                           /*!< Pin select for CSN.                                                   */
X  volatile uint32_t  PSELCSN;                            
N  __I  uint32_t  RESERVED9[7];
X  volatile const  uint32_t  RESERVED9[7];
N  __IO uint32_t  RXDPTR;                            /*!< RX data pointer.                                                      */
X  volatile uint32_t  RXDPTR;                             
N  __IO uint32_t  MAXRX;                             /*!< Maximum number of bytes in the receive buffer.                        */
X  volatile uint32_t  MAXRX;                              
N  __IO uint32_t  AMOUNTRX;                          /*!< Number of bytes received in last granted transaction.                 */
X  volatile uint32_t  AMOUNTRX;                           
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  __IO uint32_t  TXDPTR;                            /*!< TX data pointer.                                                      */
X  volatile uint32_t  TXDPTR;                             
N  __IO uint32_t  MAXTX;                             /*!< Maximum number of bytes in the transmit buffer.                       */
X  volatile uint32_t  MAXTX;                              
N  __IO uint32_t  AMOUNTTX;                          /*!< Number of bytes transmitted in last granted transaction.              */
X  volatile uint32_t  AMOUNTTX;                           
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  DEF;                               /*!< Default character.                                                    */
X  volatile uint32_t  DEF;                                
N  __I  uint32_t  RESERVED13[24];
X  volatile const  uint32_t  RESERVED13[24];
N  __IO uint32_t  ORC;                               /*!< Over-read character.                                                  */
X  volatile uint32_t  ORC;                                
N  __I  uint32_t  RESERVED14[654];
X  volatile const  uint32_t  RESERVED14[654];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPIS_Type;
N
N
N/* ================================================================================ */
N/* ================                     GPIOTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO tasks and events. (GPIOTE)
N  */
N
Ntypedef struct {                                    /*!< GPIOTE Structure                                                      */
N  __O  uint32_t  TASKS_OUT[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile  uint32_t  TASKS_OUT[4];                       
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_IN[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile uint32_t  EVENTS_IN[4];                       
N  __I  uint32_t  RESERVED1[27];
X  volatile const  uint32_t  RESERVED1[27];
N  __IO uint32_t  EVENTS_PORT;                       /*!< Event generated from multiple pins.                                   */
X  volatile uint32_t  EVENTS_PORT;                        
N  __I  uint32_t  RESERVED2[97];
X  volatile const  uint32_t  RESERVED2[97];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[129];
X  volatile const  uint32_t  RESERVED3[129];
N  __IO uint32_t  CONFIG[4];                         /*!< Channel configuration registers.                                      */
X  volatile uint32_t  CONFIG[4];                          
N  __I  uint32_t  RESERVED4[695];
X  volatile const  uint32_t  RESERVED4[695];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_GPIOTE_Type;
N
N
N/* ================================================================================ */
N/* ================                       ADC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Analog to digital converter. (ADC)
N  */
N
Ntypedef struct {                                    /*!< ADC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start an ADC conversion.                                              */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop ADC.                                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_END;                        /*!< ADC conversion complete.                                              */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  BUSY;                              /*!< ADC busy register.                                                    */
X  volatile const  uint32_t  BUSY;                               
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  ENABLE;                            /*!< ADC enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  CONFIG;                            /*!< ADC configuration register.                                           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESULT;                            /*!< Result of ADC conversion.                                             */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ADC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TIMER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Timer 0. (TIMER)
N  */
N
Ntypedef struct {                                    /*!< TIMER Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start Timer.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop Timer.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_COUNT;                       /*!< Increment Timer (In counter mode).                                    */
X  volatile  uint32_t  TASKS_COUNT;                        
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear timer.                                                          */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __I  uint32_t  RESERVED0[12];
X  volatile const  uint32_t  RESERVED0[12];
N  __O  uint32_t  TASKS_CAPTURE[4];                  /*!< Capture Timer value to CC[n] registers.                               */
X  volatile  uint32_t  TASKS_CAPTURE[4];                   
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[44];
X  volatile const  uint32_t  RESERVED2[44];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for Timer.                                                  */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[126];
X  volatile const  uint32_t  RESERVED4[126];
N  __IO uint32_t  MODE;                              /*!< Timer Mode selection.                                                 */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  BITMODE;                           /*!< Sets timer behaviour.                                                 */
X  volatile uint32_t  BITMODE;                            
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  PRESCALER;                         /*!< 4-bit prescaler to source clock frequency (max value 9). Source
X  volatile uint32_t  PRESCALER;                         
N                                                         clock frequency is divided by 2^SCALE.                                */
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED7[683];
X  volatile const  uint32_t  RESERVED7[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TIMER_Type;
N
N
N/* ================================================================================ */
N/* ================                       RTC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Real time counter 0. (RTC)
N  */
N
Ntypedef struct {                                    /*!< RTC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RTC Counter.                                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_TRIGOVRFLW;                  /*!< Set COUNTER to 0xFFFFFFF0.                                            */
X  volatile  uint32_t  TASKS_TRIGOVRFLW;                   
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_TICK;                       /*!< Event on COUNTER increment.                                           */
X  volatile uint32_t  EVENTS_TICK;                        
N  __IO uint32_t  EVENTS_OVRFLW;                     /*!< Event on COUNTER overflow.                                            */
X  volatile uint32_t  EVENTS_OVRFLW;                      
N  __I  uint32_t  RESERVED1[14];
X  volatile const  uint32_t  RESERVED1[14];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[109];
X  volatile const  uint32_t  RESERVED2[109];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[13];
X  volatile const  uint32_t  RESERVED3[13];
N  __IO uint32_t  EVTEN;                             /*!< Configures event enable routing to PPI for each RTC event.            */
X  volatile uint32_t  EVTEN;                              
N  __IO uint32_t  EVTENSET;                          /*!< Enable events routing to PPI. The reading of this register gives
X  volatile uint32_t  EVTENSET;                          
N                                                         the value of EVTEN.                                                   */
N  __IO uint32_t  EVTENCLR;                          /*!< Disable events routing to PPI. The reading of this register
X  volatile uint32_t  EVTENCLR;                          
N                                                         gives the value of EVTEN.                                             */
N  __I  uint32_t  RESERVED4[110];
X  volatile const  uint32_t  RESERVED4[110];
N  __IO uint32_t  COUNTER;                           /*!< Current COUNTER value.                                                */
X  volatile uint32_t  COUNTER;                            
N  __IO uint32_t  PRESCALER;                         /*!< 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
X  volatile uint32_t  PRESCALER;                         
N                                                         Must be written when RTC is STOPed.                                   */
N  __I  uint32_t  RESERVED5[13];
X  volatile const  uint32_t  RESERVED5[13];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED6[683];
X  volatile const  uint32_t  RESERVED6[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RTC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TEMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Temperature Sensor. (TEMP)
N  */
N
Ntypedef struct {                                    /*!< TEMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start temperature measurement.                                        */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop temperature measurement.                                         */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready event.                   */
X  volatile uint32_t  EVENTS_DATARDY;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[127];
X  volatile const  uint32_t  RESERVED2[127];
N  __I  int32_t   TEMP;                              /*!< Die temperature in degC, 2's complement format, 0.25 degC pecision.   */
X  volatile const  int32_t   TEMP;                               
N  __I  uint32_t  RESERVED3[700];
X  volatile const  uint32_t  RESERVED3[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TEMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       RNG                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Random Number Generator. (RNG)
N  */
N
Ntypedef struct {                                    /*!< RNG Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the random number generator.                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the random number generator.                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_VALRDY;                     /*!< New random number generated and written to VALUE register.            */
X  volatile uint32_t  EVENTS_VALRDY;                      
N  __I  uint32_t  RESERVED1[63];
X  volatile const  uint32_t  RESERVED1[63];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the RNG.                                                 */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register                                         */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register                                       */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[126];
X  volatile const  uint32_t  RESERVED3[126];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  VALUE;                             /*!< RNG random number.                                                    */
X  volatile const  uint32_t  VALUE;                              
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RNG_Type;
N
N
N/* ================================================================================ */
N/* ================                       ECB                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES ECB Mode Encryption. (ECB)
N  */
N
Ntypedef struct {                                    /*!< ECB Structure                                                         */
N  __O  uint32_t  TASKS_STARTECB;                    /*!< Start ECB block encrypt. If a crypto operation is running, this
X  volatile  uint32_t  TASKS_STARTECB;                    
N                                                         will not initiate a new encryption and the ERRORECB event will
N                                                          be triggered.                                                        */
N  __O  uint32_t  TASKS_STOPECB;                     /*!< Stop current ECB encryption. If a crypto operation is running,
X  volatile  uint32_t  TASKS_STOPECB;                     
N                                                         this will will trigger the ERRORECB event.                            */
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_ENDECB;                     /*!< ECB block encrypt complete.                                           */
X  volatile uint32_t  EVENTS_ENDECB;                      
N  __IO uint32_t  EVENTS_ERRORECB;                   /*!< ECB block encrypt aborted due to a STOPECB task or due to an
X  volatile uint32_t  EVENTS_ERRORECB;                   
N                                                         error.                                                                */
N  __I  uint32_t  RESERVED1[127];
X  volatile const  uint32_t  RESERVED1[127];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  ECBDATAPTR;                        /*!< ECB block encrypt memory pointer.                                     */
X  volatile uint32_t  ECBDATAPTR;                         
N  __I  uint32_t  RESERVED3[701];
X  volatile const  uint32_t  RESERVED3[701];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ECB_Type;
N
N
N/* ================================================================================ */
N/* ================                       AAR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Accelerated Address Resolver. (AAR)
N  */
N
Ntypedef struct {                                    /*!< AAR Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
X  volatile  uint32_t  TASKS_START;                       
N                                                         data structure.                                                       */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses.                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure completed.                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved.                                                     */
X  volatile uint32_t  EVENTS_RESOLVED;                    
N  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved.                                                 */
X  volatile uint32_t  EVENTS_NOTRESOLVED;                 
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  STATUS;                            /*!< Resolution status.                                                    */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable AAR.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  NIRK;                              /*!< Number of Identity root Keys in the IRK data structure.               */
X  volatile uint32_t  NIRK;                               
N  __IO uint32_t  IRKPTR;                            /*!< Pointer to the IRK data structure.                                    */
X  volatile uint32_t  IRKPTR;                             
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address (6 bytes).                          */
X  volatile uint32_t  ADDRPTR;                            
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to "scratch" data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 3 bytes must be reserved.                    */
N  __I  uint32_t  RESERVED6[697];
X  volatile const  uint32_t  RESERVED6[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_AAR_Type;
N
N
N/* ================================================================================ */
N/* ================                       CCM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES CCM Mode Encryption. (CCM)
N  */
N
Ntypedef struct {                                    /*!< CCM Structure                                                         */
N  __O  uint32_t  TASKS_KSGEN;                       /*!< Start generation of key-stream. This operation will stop by
X  volatile  uint32_t  TASKS_KSGEN;                       
N                                                         itself when completed.                                                */
N  __O  uint32_t  TASKS_CRYPT;                       /*!< Start encrypt/decrypt. This operation will stop by itself when
X  volatile  uint32_t  TASKS_CRYPT;                       
N                                                         completed.                                                            */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop encrypt/decrypt.                                                 */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_ENDKSGEN;                   /*!< Keystream generation completed.                                       */
X  volatile uint32_t  EVENTS_ENDKSGEN;                    
N  __IO uint32_t  EVENTS_ENDCRYPT;                   /*!< Encrypt/decrypt completed.                                            */
X  volatile uint32_t  EVENTS_ENDCRYPT;                    
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error happened.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the CCM.                                                 */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  MICSTATUS;                         /*!< CCM RX MIC check result.                                              */
X  volatile const  uint32_t  MICSTATUS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< CCM enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Operation mode.                                                       */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  CNFPTR;                            /*!< Pointer to data structure holding AES key and NONCE vector.           */
X  volatile uint32_t  CNFPTR;                             
N  __IO uint32_t  INPTR;                             /*!< Pointer to input packet.                                              */
X  volatile uint32_t  INPTR;                              
N  __IO uint32_t  OUTPTR;                            /*!< Pointer to output packet.                                             */
X  volatile uint32_t  OUTPTR;                             
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to "scratch" data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 43 bytes must be reserved.                   */
N  __I  uint32_t  RESERVED5[697];
X  volatile const  uint32_t  RESERVED5[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_CCM_Type;
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Watchdog Timer. (WDT)
N  */
N
Ntypedef struct {                                    /*!< WDT Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the watchdog.                                                   */
X  volatile  uint32_t  TASKS_START;                        
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_TIMEOUT;                    /*!< Watchdog timeout.                                                     */
X  volatile uint32_t  EVENTS_TIMEOUT;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  RUNSTATUS;                         /*!< Watchdog running status.                                              */
X  volatile const  uint32_t  RUNSTATUS;                          
N  __I  uint32_t  REQSTATUS;                         /*!< Request status.                                                       */
X  volatile const  uint32_t  REQSTATUS;                          
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  CRV;                               /*!< Counter reload value in number of 32kiHz clock cycles.                */
X  volatile uint32_t  CRV;                                
N  __IO uint32_t  RREN;                              /*!< Reload request enable.                                                */
X  volatile uint32_t  RREN;                               
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED4[60];
X  volatile const  uint32_t  RESERVED4[60];
N  __O  uint32_t  RR[8];                             /*!< Reload requests registers.                                            */
X  volatile  uint32_t  RR[8];                              
N  __I  uint32_t  RESERVED5[631];
X  volatile const  uint32_t  RESERVED5[631];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_WDT_Type;
N
N
N/* ================================================================================ */
N/* ================                      QDEC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Rotary decoder. (QDEC)
N  */
N
Ntypedef struct {                                    /*!< QDEC Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the quadrature decoder.                                         */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the quadrature decoder.                                          */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_READCLRACC;                  /*!< Transfers the content from ACC registers to ACCREAD registers,
X  volatile  uint32_t  TASKS_READCLRACC;                  
N                                                         and clears the ACC registers.                                         */
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_SAMPLERDY;                  /*!< A new sample is written to the sample register.                       */
X  volatile uint32_t  EVENTS_SAMPLERDY;                   
N  __IO uint32_t  EVENTS_REPORTRDY;                  /*!< REPORTPER number of samples accumulated in ACC register, and
X  volatile uint32_t  EVENTS_REPORTRDY;                  
N                                                         ACC register different than zero.                                     */
N  __IO uint32_t  EVENTS_ACCOF;                      /*!< ACC or ACCDBL register overflow.                                      */
X  volatile uint32_t  EVENTS_ACCOF;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the QDEC.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable the QDEC.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  LEDPOL;                            /*!< LED output pin polarity.                                              */
X  volatile uint32_t  LEDPOL;                             
N  __IO uint32_t  SAMPLEPER;                         /*!< Sample period.                                                        */
X  volatile uint32_t  SAMPLEPER;                          
N  __I  int32_t   SAMPLE;                            /*!< Motion sample value.                                                  */
X  volatile const  int32_t   SAMPLE;                             
N  __IO uint32_t  REPORTPER;                         /*!< Number of samples to generate an EVENT_REPORTRDY.                     */
X  volatile uint32_t  REPORTPER;                          
N  __I  int32_t   ACC;                               /*!< Accumulated valid transitions register.                               */
X  volatile const  int32_t   ACC;                                
N  __I  int32_t   ACCREAD;                           /*!< Snapshot of ACC register. Value generated by the TASKS_READCLEACC
X  volatile const  int32_t   ACCREAD;                           
N                                                         task.                                                                 */
N  __IO uint32_t  PSELLED;                           /*!< Pin select for LED output.                                            */
X  volatile uint32_t  PSELLED;                            
N  __IO uint32_t  PSELA;                             /*!< Pin select for phase A input.                                         */
X  volatile uint32_t  PSELA;                              
N  __IO uint32_t  PSELB;                             /*!< Pin select for phase B input.                                         */
X  volatile uint32_t  PSELB;                              
N  __IO uint32_t  DBFEN;                             /*!< Enable debouncer input filters.                                       */
X  volatile uint32_t  DBFEN;                              
N  __I  uint32_t  RESERVED4[5];
X  volatile const  uint32_t  RESERVED4[5];
N  __IO uint32_t  LEDPRE;                            /*!< Time LED is switched ON before the sample.                            */
X  volatile uint32_t  LEDPRE;                             
N  __I  uint32_t  ACCDBL;                            /*!< Accumulated double (error) transitions register.                      */
X  volatile const  uint32_t  ACCDBL;                             
N  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC
X  volatile const  uint32_t  ACCDBLREAD;                        
N                                                         task.                                                                 */
N  __I  uint32_t  RESERVED5[684];
X  volatile const  uint32_t  RESERVED5[684];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_QDEC_Type;
N
N
N/* ================================================================================ */
N/* ================                     LPCOMP                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Wakeup Comparator. (LPCOMP)
N  */
N
Ntypedef struct {                                    /*!< LPCOMP Structure                                                      */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the LPCOMP.                                              */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Result of last compare.                                               */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the LPCOMP.                                                    */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[4];
X  volatile const  uint32_t  RESERVED5[4];
N  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration.                                          */
X  volatile uint32_t  ANADETECT;                          
N  __I  uint32_t  RESERVED6[694];
X  volatile const  uint32_t  RESERVED6[694];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_LPCOMP_Type;
N
N
N/* ================================================================================ */
N/* ================                      COMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Comparator. (COMP)
N  */
N
Ntypedef struct {                                    /*!< COMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< COMP is ready and output is valid.                                    */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the COMP.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Compare result.                                                       */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the COMP.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[8];
X  volatile const  uint32_t  RESERVED5[8];
N  __IO uint32_t  TH;                                /*!< Threshold configuration for hysteresis unit.                          */
X  volatile uint32_t  TH;                                 
N  __IO uint32_t  MODE;                              /*!< Mode configuration.                                                   */
X  volatile uint32_t  MODE;                               
N  __I  uint32_t  RESERVED6[689];
X  volatile const  uint32_t  RESERVED6[689];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_COMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       SWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SW Interrupts. (SWI)
N  */
N
Ntypedef struct {                                    /*!< SWI Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_SWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      NVMC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Non Volatile Memory Controller. (NVMC)
N  */
N
Ntypedef struct {                                    /*!< NVMC Structure                                                        */
N  __I  uint32_t  RESERVED0[256];
X  volatile const  uint32_t  RESERVED0[256];
N  __I  uint32_t  READY;                             /*!< Ready flag.                                                           */
X  volatile const  uint32_t  READY;                              
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __IO uint32_t  ERASEPAGE;                         /*!< Register for erasing a non-protected non-volatile memory page.        */
X  volatile uint32_t  ERASEPAGE;                          
N  __IO uint32_t  ERASEALL;                          /*!< Register for erasing all non-volatile user memory.                    */
X  volatile uint32_t  ERASEALL;                           
N  __IO uint32_t  ERASEPROTECTEDPAGE;                /*!< Register for erasing a protected non-volatile memory page.            */
X  volatile uint32_t  ERASEPROTECTEDPAGE;                 
N  __IO uint32_t  ERASEUICR;                         /*!< Register for start erasing User Information Congfiguration Registers. */
X  volatile uint32_t  ERASEUICR;                          
N} NRF_NVMC_Type;
N
N
N/* ================================================================================ */
N/* ================                       PPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PPI controller. (PPI)
N  */
N
Ntypedef struct {                                    /*!< PPI Structure                                                         */
N  PPI_TASKS_CHG_Type TASKS_CHG[4];                  /*!< Channel group tasks.                                                  */
N  __I  uint32_t  RESERVED0[312];
X  volatile const  uint32_t  RESERVED0[312];
N  __IO uint32_t  CHEN;                              /*!< Channel enable.                                                       */
X  volatile uint32_t  CHEN;                               
N  __IO uint32_t  CHENSET;                           /*!< Channel enable set.                                                   */
X  volatile uint32_t  CHENSET;                            
N  __IO uint32_t  CHENCLR;                           /*!< Channel enable clear.                                                 */
X  volatile uint32_t  CHENCLR;                            
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  PPI_CH_Type CH[16];                               /*!< PPI Channel.                                                          */
N  __I  uint32_t  RESERVED2[156];
X  volatile const  uint32_t  RESERVED2[156];
N  __IO uint32_t  CHG[4];                            /*!< Channel group configuration.                                          */
X  volatile uint32_t  CHG[4];                             
N} NRF_PPI_Type;
N
N
N/* ================================================================================ */
N/* ================                      FICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Factory Information Configuration. (FICR)
N  */
N
Ntypedef struct {                                    /*!< FICR Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __I  uint32_t  CODEPAGESIZE;                      /*!< Code memory page size in bytes.                                       */
X  volatile const  uint32_t  CODEPAGESIZE;                       
N  __I  uint32_t  CODESIZE;                          /*!< Code memory size in pages.                                            */
X  volatile const  uint32_t  CODESIZE;                           
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N  __I  uint32_t  CLENR0;                            /*!< Length of code region 0 in bytes.                                     */
X  volatile const  uint32_t  CLENR0;                             
N  __I  uint32_t  PPFC;                              /*!< Pre-programmed factory code present.                                  */
X  volatile const  uint32_t  PPFC;                               
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __I  uint32_t  NUMRAMBLOCK;                       /*!< Number of individualy controllable RAM blocks.                        */
X  volatile const  uint32_t  NUMRAMBLOCK;                        
N  __I  uint32_t  SIZERAMBLOCK[4];                   /*!< Size of RAM block in bytes.                                           */
X  volatile const  uint32_t  SIZERAMBLOCK[4];                    
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __I  uint32_t  CONFIGID;                          /*!< Configuration identifier.                                             */
X  volatile const  uint32_t  CONFIGID;                           
N  __I  uint32_t  DEVICEID[2];                       /*!< Device identifier.                                                    */
X  volatile const  uint32_t  DEVICEID[2];                        
N  __I  uint32_t  RESERVED4[6];
X  volatile const  uint32_t  RESERVED4[6];
N  __I  uint32_t  ER[4];                             /*!< Encryption root.                                                      */
X  volatile const  uint32_t  ER[4];                              
N  __I  uint32_t  IR[4];                             /*!< Identity root.                                                        */
X  volatile const  uint32_t  IR[4];                              
N  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type.                                                  */
X  volatile const  uint32_t  DEVICEADDRTYPE;                     
N  __I  uint32_t  DEVICEADDR[2];                     /*!< Device address.                                                       */
X  volatile const  uint32_t  DEVICEADDR[2];                      
N  __I  uint32_t  OVERRIDEEN;                        /*!< Radio calibration override enable.                                    */
X  volatile const  uint32_t  OVERRIDEEN;                         
N  __I  uint32_t  RESERVED5[15];
X  volatile const  uint32_t  RESERVED5[15];
N  __I  uint32_t  BLE_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit
X  volatile const  uint32_t  BLE_1MBIT[5];                      
N                                                         mode.                                                                 */
N} NRF_FICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      UICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief User Information Configuration. (UICR)
N  */
N
Ntypedef struct {                                    /*!< UICR Structure                                                        */
N  __IO uint32_t  CLENR0;                            /*!< Length of code region 0.                                              */
X  volatile uint32_t  CLENR0;                             
N  __IO uint32_t  RBPCONF;                           /*!< Readback protection configuration.                                    */
X  volatile uint32_t  RBPCONF;                            
N  __IO uint32_t  XTALFREQ;                          /*!< Reset value for CLOCK XTALFREQ register.                              */
X  volatile uint32_t  XTALFREQ;                           
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __I  uint32_t  FWID;                              /*!< Firmware ID.                                                          */
X  volatile const  uint32_t  FWID;                               
N  __IO uint32_t  BOOTLOADERADDR;                    /*!< Bootloader start address.                                             */
X  volatile uint32_t  BOOTLOADERADDR;                     
N} NRF_UICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      GPIO                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief General purpose input and output. (GPIO)
N  */
N
Ntypedef struct {                                    /*!< GPIO Structure                                                        */
N  __I  uint32_t  RESERVED0[321];
X  volatile const  uint32_t  RESERVED0[321];
N  __IO uint32_t  OUT;                               /*!< Write GPIO port.                                                      */
X  volatile uint32_t  OUT;                                
N  __IO uint32_t  OUTSET;                            /*!< Set individual bits in GPIO port.                                     */
X  volatile uint32_t  OUTSET;                             
N  __IO uint32_t  OUTCLR;                            /*!< Clear individual bits in GPIO port.                                   */
X  volatile uint32_t  OUTCLR;                             
N  __I  uint32_t  IN;                                /*!< Read GPIO port.                                                       */
X  volatile const  uint32_t  IN;                                 
N  __IO uint32_t  DIR;                               /*!< Direction of GPIO pins.                                               */
X  volatile uint32_t  DIR;                                
N  __IO uint32_t  DIRSET;                            /*!< DIR set register.                                                     */
X  volatile uint32_t  DIRSET;                             
N  __IO uint32_t  DIRCLR;                            /*!< DIR clear register.                                                   */
X  volatile uint32_t  DIRCLR;                             
N  __I  uint32_t  RESERVED1[120];
X  volatile const  uint32_t  RESERVED1[120];
N  __IO uint32_t  PIN_CNF[32];                       /*!< Configuration of GPIO pins.                                           */
X  volatile uint32_t  PIN_CNF[32];                        
N} NRF_GPIO_Type;
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER_BASE                  0x40000000UL
N#define NRF_CLOCK_BASE                  0x40000000UL
N#define NRF_MPU_BASE                    0x40000000UL
N#define NRF_PU_BASE                     0x40000000UL
N#define NRF_AMLI_BASE                   0x40000000UL
N#define NRF_RADIO_BASE                  0x40001000UL
N#define NRF_UART0_BASE                  0x40002000UL
N#define NRF_SPI0_BASE                   0x40003000UL
N#define NRF_TWI0_BASE                   0x40003000UL
N#define NRF_SPI1_BASE                   0x40004000UL
N#define NRF_TWI1_BASE                   0x40004000UL
N#define NRF_SPIS1_BASE                  0x40004000UL
N#define NRF_GPIOTE_BASE                 0x40006000UL
N#define NRF_ADC_BASE                    0x40007000UL
N#define NRF_TIMER0_BASE                 0x40008000UL
N#define NRF_TIMER1_BASE                 0x40009000UL
N#define NRF_TIMER2_BASE                 0x4000A000UL
N#define NRF_RTC0_BASE                   0x4000B000UL
N#define NRF_TEMP_BASE                   0x4000C000UL
N#define NRF_RNG_BASE                    0x4000D000UL
N#define NRF_ECB_BASE                    0x4000E000UL
N#define NRF_AAR_BASE                    0x4000F000UL
N#define NRF_CCM_BASE                    0x4000F000UL
N#define NRF_WDT_BASE                    0x40010000UL
N#define NRF_RTC1_BASE                   0x40011000UL
N#define NRF_QDEC_BASE                   0x40012000UL
N#define NRF_LPCOMP_BASE                 0x40013000UL
N#define NRF_COMP_BASE                   0x40013000UL
N#define NRF_SWI_BASE                    0x40014000UL
N#define NRF_NVMC_BASE                   0x4001E000UL
N#define NRF_PPI_BASE                    0x4001F000UL
N#define NRF_FICR_BASE                   0x10000000UL
N#define NRF_UICR_BASE                   0x10001000UL
N#define NRF_GPIO_BASE                   0x50000000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER                       ((NRF_POWER_Type          *) NRF_POWER_BASE)
N#define NRF_CLOCK                       ((NRF_CLOCK_Type          *) NRF_CLOCK_BASE)
N#define NRF_MPU                         ((NRF_MPU_Type            *) NRF_MPU_BASE)
N#define NRF_PU                          ((NRF_PU_Type             *) NRF_PU_BASE)
N#define NRF_AMLI                        ((NRF_AMLI_Type           *) NRF_AMLI_BASE)
N#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
N#define NRF_UART0                       ((NRF_UART_Type           *) NRF_UART0_BASE)
N#define NRF_SPI0                        ((NRF_SPI_Type            *) NRF_SPI0_BASE)
N#define NRF_TWI0                        ((NRF_TWI_Type            *) NRF_TWI0_BASE)
N#define NRF_SPI1                        ((NRF_SPI_Type            *) NRF_SPI1_BASE)
N#define NRF_TWI1                        ((NRF_TWI_Type            *) NRF_TWI1_BASE)
N#define NRF_SPIS1                       ((NRF_SPIS_Type           *) NRF_SPIS1_BASE)
N#define NRF_GPIOTE                      ((NRF_GPIOTE_Type         *) NRF_GPIOTE_BASE)
N#define NRF_ADC                         ((NRF_ADC_Type            *) NRF_ADC_BASE)
N#define NRF_TIMER0                      ((NRF_TIMER_Type          *) NRF_TIMER0_BASE)
N#define NRF_TIMER1                      ((NRF_TIMER_Type          *) NRF_TIMER1_BASE)
N#define NRF_TIMER2                      ((NRF_TIMER_Type          *) NRF_TIMER2_BASE)
N#define NRF_RTC0                        ((NRF_RTC_Type            *) NRF_RTC0_BASE)
N#define NRF_TEMP                        ((NRF_TEMP_Type           *) NRF_TEMP_BASE)
N#define NRF_RNG                         ((NRF_RNG_Type            *) NRF_RNG_BASE)
N#define NRF_ECB                         ((NRF_ECB_Type            *) NRF_ECB_BASE)
N#define NRF_AAR                         ((NRF_AAR_Type            *) NRF_AAR_BASE)
N#define NRF_CCM                         ((NRF_CCM_Type            *) NRF_CCM_BASE)
N#define NRF_WDT                         ((NRF_WDT_Type            *) NRF_WDT_BASE)
N#define NRF_RTC1                        ((NRF_RTC_Type            *) NRF_RTC1_BASE)
N#define NRF_QDEC                        ((NRF_QDEC_Type           *) NRF_QDEC_BASE)
N#define NRF_LPCOMP                      ((NRF_LPCOMP_Type         *) NRF_LPCOMP_BASE)
N#define NRF_COMP                        ((NRF_COMP_Type           *) NRF_COMP_BASE)
N#define NRF_SWI                         ((NRF_SWI_Type            *) NRF_SWI_BASE)
N#define NRF_NVMC                        ((NRF_NVMC_Type           *) NRF_NVMC_BASE)
N#define NRF_PPI                         ((NRF_PPI_Type            *) NRF_PPI_BASE)
N#define NRF_FICR                        ((NRF_FICR_Type           *) NRF_FICR_BASE)
N#define NRF_UICR                        ((NRF_UICR_Type           *) NRF_UICR_BASE)
N#define NRF_GPIO                        ((NRF_GPIO_Type           *) NRF_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group nRF51 */
N/** @} */ /* End of group Nordic Semiconductor */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* nRF51_H */
N
L 28 "..\..\..\Software\Include\app_util.h" 2
N#include "app_error.h"
L 1 "..\..\..\Software\Include\app_error.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N 
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler and macros for utilizing a common error handler.
N */
N
N#ifndef APP_ERROR_H__
N#define APP_ERROR_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf_error.h"
N
N/**@brief Function for error handling, which is called when an error has occurred. 
N *
N * @param[in] error_code  Error code supplied to the handler.
N * @param[in] line_num    Line number where the handler is called.
N * @param[in] p_file_name Pointer to the file name. 
N */
Nvoid app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name);
N
N/**@brief Macro for calling error handler function. 
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#define APP_ERROR_HANDLER(ERR_CODE)                         \
N    do                                                      \
N    {                                                       \
N        app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);  \
N    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                             do                                                          {                                                               app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);      } while (0)
N
N/**@brief Macro for calling error handler function if supplied error code any other than NRF_SUCCESS. 
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */    
N#define APP_ERROR_CHECK(ERR_CODE)                           \
N    do                                                      \
N    {                                                       \
N        const uint32_t LOCAL_ERR_CODE = (ERR_CODE);         \
N        if (LOCAL_ERR_CODE != NRF_SUCCESS)                  \
N        {                                                   \
N            APP_ERROR_HANDLER(LOCAL_ERR_CODE);              \
N        }                                                   \
N    } while (0)    
X#define APP_ERROR_CHECK(ERR_CODE)                               do                                                          {                                                               const uint32_t LOCAL_ERR_CODE = (ERR_CODE);                 if (LOCAL_ERR_CODE != NRF_SUCCESS)                          {                                                               APP_ERROR_HANDLER(LOCAL_ERR_CODE);                      }                                                       } while (0)    
N    
N/**@brief Macro for calling error handler function if supplied boolean value is false. 
N *
N * @param[in] BOOLEAN_VALUE Boolean value to be evaluated.
N */    
N#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                 \
N    do                                                      \
N    {                                                       \
N        const bool LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);   \
N        if (!LOCAL_BOOLEAN_VALUE)                           \
N        {                                                   \
N            APP_ERROR_HANDLER(0);                           \
N        }                                                   \
N    } while (0)        
X#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                     do                                                          {                                                               const bool LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);           if (!LOCAL_BOOLEAN_VALUE)                                   {                                                               APP_ERROR_HANDLER(0);                                   }                                                       } while (0)        
N
N#endif // APP_ERROR_H__
N
N/** @} */
L 29 "..\..\..\Software\Include\app_util.h" 2
N
N/**@brief The interrupt priorities available to the application while the softdevice is active. */
Ntypedef enum
N{
N    APP_IRQ_PRIORITY_HIGH = 1,
N    APP_IRQ_PRIORITY_LOW  = 3
N} app_irq_priority_t;
N
Nenum
N{
N    UNIT_0_625_MS = 625,                                /**< Number of microseconds in 0.625 milliseconds. */
N    UNIT_1_25_MS  = 1250,                               /**< Number of microseconds in 1.25 milliseconds. */
N    UNIT_10_MS    = 10000                               /**< Number of microseconds in 10 milliseconds. */
N};
N
N#define NRF_APP_PRIORITY_THREAD    4                    /**< "Interrupt level" when running in Thread Mode. */
N
N/**@cond NO_DOXYGEN */
N#define EXTERNAL_INT_VECTOR_OFFSET 16
N/**@endcond */
N
N#define PACKED(TYPE) __packed TYPE
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N *
N * @note If the assertion fails when compiling using Keil, the compiler will report error message
N *       "error: #94: the size of an array must be greater than zero" (while gcc will list the
N *       symbol static_assert_failed, making the error message more readable).
N *       If the supplied expression can not be evaluated at compile time, Keil will report
N *       "error: #28: expression must have a constant value".
N *
N * @note The macro is intentionally implemented not using do while(0), allowing it to be used
N *       outside function blocks (e.g. close to global type- and variable declarations).
N *       If used in a code block, it must be used before any executable code in this block.
N *
N * @param[in]   EXPR   Constant expression to be verified.
N */
N
N#define STATIC_ASSERT(EXPR) typedef char static_assert_failed[(EXPR) ? 1 : -1]
N
N/**@brief type for holding an encoded (i.e. little endian) 16 bit unsigned integer. */
Ntypedef uint8_t uint16_le_t[2];
N
N/**@brief type for holding an encoded (i.e. little endian) 32 bit unsigned integer. */
Ntypedef uint8_t uint32_le_t[4];
N
N/**@brief Byte array type. */
Ntypedef struct
N{
N    uint16_t  size;                 /**< Number of array entries. */
N    uint8_t * p_data;               /**< Pointer to array entries. */
N} uint8_array_t;
N
N/**@cond NO_DOXYGEN */
N#define INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE) \
N    do{                                                                               \
N        NRF_GPIO->PIN_CNF[(PIN_NO)] =                                                 \
N            ((IO_DIR)   << GPIO_PIN_CNF_DIR_Pos)   |                                  \
N            ((IO_INPUT) << GPIO_PIN_CNF_INPUT_Pos) |                                  \
N            ((IO_PULL)  << GPIO_PIN_CNF_PULL_Pos)  |                                  \
N            ((IO_DRIVE) << GPIO_PIN_CNF_DRIVE_Pos) |                                  \
N            ((IO_SENSE) << GPIO_PIN_CNF_SENSE_Pos);                                   \
N    } while (0)
X#define INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)     do{                                                                                       NRF_GPIO->PIN_CNF[(PIN_NO)] =                                                             ((IO_DIR)   << GPIO_PIN_CNF_DIR_Pos)   |                                              ((IO_INPUT) << GPIO_PIN_CNF_INPUT_Pos) |                                              ((IO_PULL)  << GPIO_PIN_CNF_PULL_Pos)  |                                              ((IO_DRIVE) << GPIO_PIN_CNF_DRIVE_Pos) |                                              ((IO_SENSE) << GPIO_PIN_CNF_SENSE_Pos);                                       } while (0)
N/**@endcond */
N
N/**@brief Macro to configure an I/O.
N *
N * @details This macro configures a given I/O to input or output with pullup/buffer configuration.
N *
N * @param[in]  PIN_NO     I/O pin to configure.
N * @param[in]  IO_DIR     I/O pin direction.
N * @param[in]  IO_INPUT   Connect or disconnect input path.
N * @param[in]  IO_PULL    Pull-up or -down configuration.
N * @param[in]  IO_DRIVE   Drive configuration.
N * @param[in]  IO_SENSE   Pin sensing mechanism.
N */
N#define GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE) \
N            INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)
X#define GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)             INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)
N
N/**@brief Configure a PIN to be used as a LED.
N *
N * @param[in]  PIN_NO  Input pin to configure.
N */
N#define GPIO_LED_CONFIG(PIN_NO)                       \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Output,      \
N                        GPIO_PIN_CNF_INPUT_Disconnect,\
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_LED_CONFIG(PIN_NO)                           do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Output,                              GPIO_PIN_CNF_INPUT_Disconnect,                        GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a debug pin (e.g. to be monitored using a logic analyzer).
N *
N * @param[in]  PIN_NO  Input pin to configure.
N */
N#define GPIO_DEBUG_PIN_CONFIG(PIN_NO)                 \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Output,      \
N                        GPIO_PIN_CNF_INPUT_Disconnect,\
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_DEBUG_PIN_CONFIG(PIN_NO)                     do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Output,                              GPIO_PIN_CNF_INPUT_Disconnect,                        GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_BUTTON_CONFIG(PIN_NO)                    \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_BUTTON_CONFIG(PIN_NO)                        do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button and a Wakeup source.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_WAKEUP_BUTTON_CONFIG(PIN_NO)             \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Low);      \
N    } while (0)
X#define GPIO_WAKEUP_BUTTON_CONFIG(PIN_NO)                 do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Low);          } while (0)
N
N/**@brief Configure a PIN to be used as a Button, with a pullup resistor enabled.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)        \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Pullup,     \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)            do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Pullup,                             GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button and a Wakeup source, with a pullup resistor
N *        enabled.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_WAKEUP_BUTTON_WITH_PULLUP_CONFIG(PIN_NO) \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Pullup,     \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Low);      \
N    } while (0)
X#define GPIO_WAKEUP_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)     do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Pullup,                             GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Low);          } while (0)
N
N/**@brief Macro for entering a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#define CRITICAL_REGION_ENTER()                                                             \
N    {                                                                                       \
N        uint8_t IS_NESTED_CRITICAL_REGION = 0;                                              \
N        uint32_t CURRENT_INT_PRI = current_int_priority_get();                              \
N        if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                       \
N        {                                                                                   \
N            uint32_t ERR_CODE = sd_nvic_critical_region_enter(&IS_NESTED_CRITICAL_REGION);  \
N            if (ERR_CODE == NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                               \
N            {                                                                               \
N                __disable_irq();                                                            \
N            }                                                                               \
N            else                                                                            \
N            {                                                                               \
N                APP_ERROR_CHECK(ERR_CODE);                                                  \
N            }                                                                               \
N        }        
X#define CRITICAL_REGION_ENTER()                                                                 {                                                                                               uint8_t IS_NESTED_CRITICAL_REGION = 0;                                                      uint32_t CURRENT_INT_PRI = current_int_priority_get();                                      if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                               {                                                                                               uint32_t ERR_CODE = sd_nvic_critical_region_enter(&IS_NESTED_CRITICAL_REGION);              if (ERR_CODE == NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                                           {                                                                                               __disable_irq();                                                                        }                                                                                           else                                                                                        {                                                                                               APP_ERROR_CHECK(ERR_CODE);                                                              }                                                                                       }        
N    
N/**@brief Macro for leaving a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#define CRITICAL_REGION_EXIT()                                                              \
N        if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                       \
N        {                                                                                   \
N            uint32_t ERR_CODE;                                                              \
N            __enable_irq();                                                                 \
N            ERR_CODE = sd_nvic_critical_region_exit(IS_NESTED_CRITICAL_REGION);             \
N            if (ERR_CODE != NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                               \
N            {                                                                               \
N                APP_ERROR_CHECK(ERR_CODE);                                                  \
N            }                                                                               \
N        }                                                                                   \
N    }
X#define CRITICAL_REGION_EXIT()                                                                      if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                               {                                                                                               uint32_t ERR_CODE;                                                                          __enable_irq();                                                                             ERR_CODE = sd_nvic_critical_region_exit(IS_NESTED_CRITICAL_REGION);                         if (ERR_CODE != NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                                           {                                                                                               APP_ERROR_CHECK(ERR_CODE);                                                              }                                                                                       }                                                                                       }
N    
N/**@brief Perform rounded integer division (as opposed to truncating the result).
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Rounded (integer) result of dividing A by B.
N */
N#define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))
N
N/**@brief Check if the integer provided is a power of two.
N *
N * @param[in]   A   Number to be tested.
N *
N * @return      true if value is power of two.
N * @return      false if value not power of two.
N */
N#define IS_POWER_OF_TWO(A) ( ((A) != 0) && ((((A) - 1) & (A)) == 0) )
N
N/**@brief To convert ticks to millisecond
N * @param[in] time          Number of millseconds that needs to be converted.
N * @param[in] resolution    Units to be converted.
N */
N#define MSEC_TO_UNITS(TIME, RESOLUTION) (((TIME) * 1000) / (RESOLUTION))
N
N
N/**@brief Perform integer division, making sure the result is rounded up.
N *
N * @details One typical use for this is to compute the number of objects with size B is needed to
N *          hold A number of bytes.
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Integer result of dividing A by B, rounded up.
N */
N#define CEIL_DIV(A, B)      \
N    /*lint -save -e573 */   \
N    ((((A) - 1) / (B)) + 1) \
N    /*lint -restore */
X#define CEIL_DIV(A, B)                  ((((A) - 1) / (B)) + 1)      
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N    
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) | 
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
N}
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
N}
N
N    
N/**@brief Function for finding the current interrupt level.
N *
N * @return   Current interrupt level.
N * @retval   APP_IRQ_PRIORITY_HIGH    We are running in Application High interrupt level.
N * @retval   APP_IRQ_PRIORITY_LOW     We are running in Application Low interrupt level.
N * @retval   APP_IRQ_PRIORITY_THREAD  We are running in Thread Mode.
N */
Nstatic __INLINE uint8_t current_int_priority_get(void)
Xstatic __inline uint8_t current_int_priority_get(void)
N{
N    uint32_t isr_vector_num = (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
X    uint32_t isr_vector_num = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->ICSR & (0x1FFUL << 0));
N    if (isr_vector_num > 0)
N    {
N        int32_t irq_type = ((int32_t)isr_vector_num - EXTERNAL_INT_VECTOR_OFFSET);
X        int32_t irq_type = ((int32_t)isr_vector_num - 16);
N        return (NVIC_GetPriority((IRQn_Type)irq_type) & 0xFF);
N    }
N    else
N    {
N        return NRF_APP_PRIORITY_THREAD;
X        return 4;
N    }
N}
N
N/** @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.
N *
N *  @details The calculation is based on a linearized version of the battery's discharge
N *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and
N *           is considered to be the lower boundary.
N *
N *           The discharge curve for CR2032 is non-linear. In this model it is split into
N *           4 linear sections:
N *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)
N *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)
N *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)
N *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)
N *
N *           These numbers are by no means accurate. Temperature and
N *           load in the actual application is not accounted for!
N *
N *  @param[in] mvolts The voltage in mV
N *
N *  @return    Battery level in percent.
N*/
Nstatic __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
Xstatic __inline uint8_t battery_level_in_percent(const uint16_t mvolts)
N{
N    uint8_t battery_level;
N
N    if (mvolts >= 3000)
N    {
N        battery_level = 100;
N    }
N    else if (mvolts > 2900)
N    {
N        battery_level = 100 - ((3000 - mvolts) * 58) / 100;
N    }
N    else if (mvolts > 2740)
N    {
N        battery_level = 42 - ((2900 - mvolts) * 24) / 160;
N    }
N    else if (mvolts > 2440)
N    {
N        battery_level = 18 - ((2740 - mvolts) * 12) / 300;
N    }
N    else if (mvolts > 2100)
N    {
N        battery_level = 6 - ((2440 - mvolts) * 6) / 340;
N    }
N    else
N    {
N        battery_level = 0;
N    }
N
N    return battery_level;
N}
N
N/**@brief Function for checking if a pointer value is aligned to a 4 byte boundary.
N *
N * @param[in]   p   Pointer value to be checked.
N *
N * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
N */
Nstatic __INLINE bool is_word_aligned(void * p)
Xstatic __inline _Bool is_word_aligned(void * p)
N{
N    return (((uint32_t)p & 0x00000003) == 0);
N}
N
N#endif // APP_UTIL_H__
N
N/** @} */
L 28 "..\..\..\Software\Include\ble_srv_common.h" 2
N#include "ble_gap.h"
N
N/** @defgroup UUID_SERVICES Service UUID definitions
N * @{ */
N#define BLE_UUID_ALERT_NOTIFICATION_SERVICE                      0x1811     /**< Alert Notification service UUID. */
N#define BLE_UUID_BATTERY_SERVICE                                 0x180F     /**< Battery service UUID. */
N#define BLE_UUID_BLOOD_PRESSURE_SERVICE                          0x1810     /**< Blood Pressure service UUID. */
N#define BLE_UUID_CURRENT_TIME_SERVICE                            0x1805     /**< Current Time service UUID. */
N#define BLE_UUID_CYCLING_SPEED_AND_CADENCE                       0x1816     /**< Cycling Speed and Cadence service UUID. */
N#define BLE_UUID_DEVICE_INFORMATION_SERVICE                      0x180A     /**< Device Information service UUID. */
N#define BLE_UUID_GLUCOSE_SERVICE                                 0x1808     /**< Glucose service UUID. */
N#define BLE_UUID_HEALTH_THERMOMETER_SERVICE                      0x1809     /**< Health Thermometer service UUID. */
N#define BLE_UUID_HEART_RATE_SERVICE                              0x180D     /**< Heart Rate service UUID. */
N#define BLE_UUID_HUMAN_INTERFACE_DEVICE_SERVICE                  0x1812     /**< Human Interface Device service UUID. */
N#define BLE_UUID_IMMEDIATE_ALERT_SERVICE                         0x1802     /**< Immediate Alert service UUID. */
N#define BLE_UUID_LINK_LOSS_SERVICE                               0x1803     /**< Link Loss service UUID. */
N#define BLE_UUID_NEXT_DST_CHANGE_SERVICE                         0x1807     /**< Next Dst Change service UUID. */
N#define BLE_UUID_PHONE_ALERT_STATUS_SERVICE                      0x180E     /**< Phone Alert Status service UUID. */
N#define BLE_UUID_REFERENCE_TIME_UPDATE_SERVICE                   0x1806     /**< Reference Time Update service UUID. */
N#define BLE_UUID_RUNNING_SPEED_AND_CADENCE                       0x1814     /**< Running Speed and Cadence service UUID. */
N#define BLE_UUID_SCAN_PARAMETERS_SERVICE                         0x1813     /**< Scan Parameters service UUID. */
N#define BLE_UUID_TX_POWER_SERVICE                                0x1804     /**< TX Power service UUID. */
N/** @} */
N
N/** @defgroup UUID_CHARACTERISTICS Characteristic UUID definitions
N * @{ */
N#define BLE_UUID_BATTERY_LEVEL_STATE_CHAR                        0x2A1B     /**< Battery Level State characteristic UUID. */
N#define BLE_UUID_BATTERY_POWER_STATE_CHAR                        0x2A1A     /**< Battery Power State characteristic UUID. */
N#define BLE_UUID_REMOVABLE_CHAR                                  0x2A3A     /**< Removable characteristic UUID. */
N#define BLE_UUID_SERVICE_REQUIRED_CHAR                           0x2A3B     /**< Service Required characteristic UUID. */
N#define BLE_UUID_ALERT_CATEGORY_ID_CHAR                          0x2A43     /**< Alert Category Id characteristic UUID. */
N#define BLE_UUID_ALERT_CATEGORY_ID_BIT_MASK_CHAR                 0x2A42     /**< Alert Category Id Bit Mask characteristic UUID. */
N#define BLE_UUID_ALERT_LEVEL_CHAR                                0x2A06     /**< Alert Level characteristic UUID. */
N#define BLE_UUID_ALERT_NOTIFICATION_CONTROL_POINT_CHAR           0x2A44     /**< Alert Notification Control Point characteristic UUID. */
N#define BLE_UUID_ALERT_STATUS_CHAR                               0x2A3F     /**< Alert Status characteristic UUID. */
N#define BLE_UUID_BATTERY_LEVEL_CHAR                              0x2A19     /**< Battery Level characteristic UUID. */
N#define BLE_UUID_BLOOD_PRESSURE_FEATURE_CHAR                     0x2A49     /**< Blood Pressure Feature characteristic UUID. */
N#define BLE_UUID_BLOOD_PRESSURE_MEASUREMENT_CHAR                 0x2A35     /**< Blood Pressure Measurement characteristic UUID. */
N#define BLE_UUID_BODY_SENSOR_LOCATION_CHAR                       0x2A38     /**< Body Sensor Location characteristic UUID. */
N#define BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR                 0x2A22     /**< Boot Keyboard Input Report characteristic UUID. */
N#define BLE_UUID_BOOT_KEYBOARD_OUTPUT_REPORT_CHAR                0x2A32     /**< Boot Keyboard Output Report characteristic UUID. */
N#define BLE_UUID_BOOT_MOUSE_INPUT_REPORT_CHAR                    0x2A33     /**< Boot Mouse Input Report characteristic UUID. */
N#define BLE_UUID_CURRENT_TIME_CHAR                               0x2A2B     /**< Current Time characteristic UUID. */
N#define BLE_UUID_DATE_TIME_CHAR                                  0x2A08     /**< Date Time characteristic UUID. */
N#define BLE_UUID_DAY_DATE_TIME_CHAR                              0x2A0A     /**< Day Date Time characteristic UUID. */
N#define BLE_UUID_DAY_OF_WEEK_CHAR                                0x2A09     /**< Day Of Week characteristic UUID. */
N#define BLE_UUID_DST_OFFSET_CHAR                                 0x2A0D     /**< Dst Offset characteristic UUID. */
N#define BLE_UUID_EXACT_TIME_256_CHAR                             0x2A0C     /**< Exact Time 256 characteristic UUID. */
N#define BLE_UUID_FIRMWARE_REVISION_STRING_CHAR                   0x2A26     /**< Firmware Revision String characteristic UUID. */
N#define BLE_UUID_GLUCOSE_FEATURE_CHAR                            0x2A51     /**< Glucose Feature characteristic UUID. */
N#define BLE_UUID_GLUCOSE_MEASUREMENT_CHAR                        0x2A18     /**< Glucose Measurement characteristic UUID. */
N#define BLE_UUID_GLUCOSE_MEASUREMENT_CONTEXT_CHAR                0x2A34     /**< Glucose Measurement Context characteristic UUID. */
N#define BLE_UUID_HARDWARE_REVISION_STRING_CHAR                   0x2A27     /**< Hardware Revision String characteristic UUID. */
N#define BLE_UUID_HEART_RATE_CONTROL_POINT_CHAR                   0x2A39     /**< Heart Rate Control Point characteristic UUID. */
N#define BLE_UUID_HEART_RATE_MEASUREMENT_CHAR                     0x2A37     /**< Heart Rate Measurement characteristic UUID. */
N#define BLE_UUID_HID_CONTROL_POINT_CHAR                          0x2A4C     /**< Hid Control Point characteristic UUID. */
N#define BLE_UUID_HID_INFORMATION_CHAR                            0x2A4A     /**< Hid Information characteristic UUID. */
N#define BLE_UUID_IEEE_REGULATORY_CERTIFICATION_DATA_LIST_CHAR    0x2A2A     /**< IEEE Regulatory Certification Data List characteristic UUID. */
N#define BLE_UUID_INTERMEDIATE_CUFF_PRESSURE_CHAR                 0x2A36     /**< Intermediate Cuff Pressure characteristic UUID. */
N#define BLE_UUID_INTERMEDIATE_TEMPERATURE_CHAR                   0x2A1E     /**< Intermediate Temperature characteristic UUID. */
N#define BLE_UUID_LOCAL_TIME_INFORMATION_CHAR                     0x2A0F     /**< Local Time Information characteristic UUID. */
N#define BLE_UUID_MANUFACTURER_NAME_STRING_CHAR                   0x2A29     /**< Manufacturer Name String characteristic UUID. */
N#define BLE_UUID_MEASUREMENT_INTERVAL_CHAR                       0x2A21     /**< Measurement Interval characteristic UUID. */
N#define BLE_UUID_MODEL_NUMBER_STRING_CHAR                        0x2A24     /**< Model Number String characteristic UUID. */
N#define BLE_UUID_UNREAD_ALERT_CHAR                               0x2A45     /**< Unread Alert characteristic UUID. */
N#define BLE_UUID_NEW_ALERT_CHAR                                  0x2A46     /**< New Alert characteristic UUID. */
N#define BLE_UUID_PNP_ID_CHAR                                     0x2A50     /**< PNP Id characteristic UUID. */
N#define BLE_UUID_PROTOCOL_MODE_CHAR                              0x2A4E     /**< Protocol Mode characteristic UUID. */
N#define BLE_UUID_RECORD_ACCESS_CONTROL_POINT_CHAR                0x2A52     /**< Record Access Control Point characteristic UUID. */
N#define BLE_UUID_REFERENCE_TIME_INFORMATION_CHAR                 0x2A14     /**< Reference Time Information characteristic UUID. */
N#define BLE_UUID_REPORT_CHAR                                     0x2A4D     /**< Report characteristic UUID. */
N#define BLE_UUID_REPORT_MAP_CHAR                                 0x2A4B     /**< Report Map characteristic UUID. */
N#define BLE_UUID_RINGER_CONTROL_POINT_CHAR                       0x2A40     /**< Ringer Control Point characteristic UUID. */
N#define BLE_UUID_RINGER_SETTING_CHAR                             0x2A41     /**< Ringer Setting characteristic UUID. */
N#define BLE_UUID_SCAN_INTERVAL_WINDOW_CHAR                       0x2A4F     /**< Scan Interval Window characteristic UUID. */
N#define BLE_UUID_SCAN_REFRESH_CHAR                               0x2A31     /**< Scan Refresh characteristic UUID. */
N#define BLE_UUID_SERIAL_NUMBER_STRING_CHAR                       0x2A25     /**< Serial Number String characteristic UUID. */
N#define BLE_UUID_SOFTWARE_REVISION_STRING_CHAR                   0x2A28     /**< Software Revision String characteristic UUID. */
N#define BLE_UUID_SUPPORTED_NEW_ALERT_CATEGORY_CHAR               0x2A47     /**< Supported New Alert Category characteristic UUID. */
N#define BLE_UUID_SUPPORTED_UNREAD_ALERT_CATEGORY_CHAR            0x2A48     /**< Supported Unread Alert Category characteristic UUID. */
N#define BLE_UUID_SYSTEM_ID_CHAR                                  0x2A23     /**< System Id characteristic UUID. */
N#define BLE_UUID_TEMPERATURE_MEASUREMENT_CHAR                    0x2A1C     /**< Temperature Measurement characteristic UUID. */
N#define BLE_UUID_TEMPERATURE_TYPE_CHAR                           0x2A1D     /**< Temperature Type characteristic UUID. */
N#define BLE_UUID_TIME_ACCURACY_CHAR                              0x2A12     /**< Time Accuracy characteristic UUID. */
N#define BLE_UUID_TIME_SOURCE_CHAR                                0x2A13     /**< Time Source characteristic UUID. */
N#define BLE_UUID_TIME_UPDATE_CONTROL_POINT_CHAR                  0x2A16     /**< Time Update Control Point characteristic UUID. */
N#define BLE_UUID_TIME_UPDATE_STATE_CHAR                          0x2A17     /**< Time Update State characteristic UUID. */
N#define BLE_UUID_TIME_WITH_DST_CHAR                              0x2A11     /**< Time With Dst characteristic UUID. */
N#define BLE_UUID_TIME_ZONE_CHAR                                  0x2A0E     /**< Time Zone characteristic UUID. */
N#define BLE_UUID_TX_POWER_LEVEL_CHAR                             0x2A07     /**< TX Power Level characteristic UUID. */
N#define BLE_UUID_CSC_FEATURE_CHAR                                0x2A5C     /**< Cycling Speed and Cadence Feature characteristic UUID. */
N#define BLE_UUID_CSC_MEASUREMENT_CHAR                            0x2A5B     /**< Cycling Speed and Cadence Measurement characteristic UUID. */
N#define BLE_UUID_RSC_FEATURE_CHAR                                0x2A54     /**< Running Speed and Cadence Feature characteristic UUID. */
N#define BLE_UUID_SC_CTRLPT_CHAR                                  0x2A55     /**< Speed and Cadence Control Point UUID. */
N#define BLE_UUID_RSC_MEASUREMENT_CHAR                            0x2A53     /**< Running Speed and Cadence Measurement characteristic UUID. */
N#define BLE_UUID_SENSOR_LOCATION_CHAR                            0x2A5D     /**< Sensor Location characteristic UUID. */
N/** @} */
N
N/** @defgroup UUID_CHARACTERISTICS Characteristic UUID definitions
N * @{ */
N#define BLE_UUID_EXTERNAL_REPORT_REF_DESCR                       0x2907     /**< External Report Reference descriptor UUID. */
N#define BLE_UUID_REPORT_REF_DESCR                                0x2908     /**< Report Reference descriptor UUID. */
N/** @} */
N
N/** @defgroup CCCD_BITS CCCD bit definitions
N * @{ */
N#define BLE_CCCD_NOTIFY_BIT_MASK                                 0x0001     /**< Enable Notification bit. */
N#define BLE_CCCD_INDICATE_BIT_MASK                               0x0002     /**< Enable Indication bit. */
N/** @} */
N
N/** @defgroup ALERT_LEVEL_VALUES Definitions for the Alert Level characteristic values
N * @{ */
N#define BLE_CHAR_ALERT_LEVEL_NO_ALERT                            0x00       /**< No Alert. */
N#define BLE_CHAR_ALERT_LEVEL_MILD_ALERT                          0x01       /**< Mild Alert. */
N#define BLE_CHAR_ALERT_LEVEL_HIGH_ALERT                          0x02       /**< High Alert. */
N/** @} */
N
N#define BLE_SRV_ENCODED_REPORT_REF_LEN                           2          /**< The length of an encoded Report Reference Descriptor. */
N#define BLE_CCCD_VALUE_LEN                                       2          /**< The length of a CCCD value. */
N
N/**@brief Type definition for error handler function which will be called in case of an error in
N *        a service or a service library module. */
Ntypedef void (*ble_srv_error_handler_t)(uint32_t nrf_error);
N
N/**@brief Value of a Report Reference descriptor. 
N *
N * @details This is mapping information which maps the parent characteristic to the Report ID(s) and
N *          Report Type(s) defined within a Report Map characteristic.
N */
Ntypedef struct
N{
N    uint8_t report_id;                                  /**< Non-zero value if these is more than one instance of the same Report Type */
N    uint8_t report_type;                                /**< Type of Report characteristic (see @ref BLE_SRV_HIDS_REPORT_TYPE) */
N} ble_srv_report_ref_t;
N
N/**@brief UTF-8 string data type.
N *
N * @note The type can only hold a pointer to the string data (i.e. not the actual data).
N */
Ntypedef struct
N{
N    uint16_t  length;                                   /**< String length. */
N    uint8_t * p_str;                                    /**< String data. */
N} ble_srv_utf8_str_t;
N
N/**@brief Security settings structure.
N * @details This structure contains the security options needed during initialization of the
N *          service.
N */
Ntypedef struct
N{
N    ble_gap_conn_sec_mode_t read_perm;                  /**< Read permissions. */
N    ble_gap_conn_sec_mode_t write_perm;                 /**< Write permissions. */
N} ble_srv_security_mode_t;
N
N/**@brief Security settings structure.
N * @details This structure contains the security options needed during initialization of the
N *          service. It can be used when the charecteristics contains cccd.
N */
Ntypedef struct
N{
N    ble_gap_conn_sec_mode_t cccd_write_perm;
N    ble_gap_conn_sec_mode_t read_perm;                  /**< Read permissions. */
N    ble_gap_conn_sec_mode_t write_perm;                 /**< Write permissions. */
N} ble_srv_cccd_security_mode_t;
N
N/**@brief Function for decoding a CCCD value, and then testing if notification is
N *        enabled.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded CCCD is stored.
N *
N * @return      TRUE if notification is enabled, FALSE otherwise.
N */
Nstatic __INLINE bool ble_srv_is_notification_enabled(uint8_t * p_encoded_data)
Xstatic __inline _Bool ble_srv_is_notification_enabled(uint8_t * p_encoded_data)
N{
N    uint16_t cccd_value = uint16_decode(p_encoded_data);
N    return ((cccd_value & BLE_CCCD_NOTIFY_BIT_MASK) != 0);
X    return ((cccd_value & 0x0001) != 0);
N}
N    
N/**@brief Function for decoding a CCCD value, and then testing if indication is
N *        enabled.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded CCCD is stored.
N *
N * @return      TRUE if indication is enabled, FALSE otherwise.
N */
Nstatic __INLINE bool ble_srv_is_indication_enabled(uint8_t * p_encoded_data)
Xstatic __inline _Bool ble_srv_is_indication_enabled(uint8_t * p_encoded_data)
N{
N    uint16_t cccd_value = uint16_decode(p_encoded_data);
N    return ((cccd_value & BLE_CCCD_INDICATE_BIT_MASK) != 0);
X    return ((cccd_value & 0x0002) != 0);
N}
N
N/**@brief Function for encoding a Report Reference Descriptor.
N *
N * @param[in]   p_encoded_buffer  The buffer of the encoded data.
N * @param[in]   p_report_ref      Report Reference value to be encoded.
N *
N * @return      Length of the encoded data.
N */
Nuint8_t ble_srv_report_ref_encode(uint8_t *                    p_encoded_buffer,
N                                  const ble_srv_report_ref_t * p_report_ref);
N
N/**@brief Function for making UTF-8 structure refer to an ASCII string.
N *
N * @param[out]  p_utf8   UTF-8 structure to be set.
N * @param[in]   p_ascii  ASCII string to be referred to.
N */
Nvoid ble_srv_ascii_to_utf8(ble_srv_utf8_str_t * p_utf8, char * p_ascii);
N
N#endif // BLE_SRV_COMMON_H__
N
N/** @} */
L 37 "..\..\..\Software\Include\ble_nus.h" 2
N
N#define BLE_UUID_NUS_SERVICE 0x0001
N#define BLE_UUID_NUS_TX_CHARACTERISTIC 0x0002
N#define BLE_UUID_NUS_RX_CHARACTERISTIC 0x0003
N
N#define NUS_MAX_DATA_LENGTH 20
N
N
N// Forward declaration of the ble_nus_t type. 
Ntypedef struct ble_nus_s ble_nus_t;
N
N/**@brief Service event handler type. */
Ntypedef void (*ble_nus_data_handler_t) (ble_nus_t * p_nus, uint8_t * data, uint16_t length);
N
N/**@brief Nordic UART Service init structure. This contains all options and data needed for
N *        initialization of the service.*/
Ntypedef struct
N{
N    ble_nus_data_handler_t data_handler;              /**< Event handler to be called for handling received data. */
N} ble_nus_init_t;
N
N/**@brief Nordic UART Service structure. This contains various status information for the service. */
Ntypedef struct ble_nus_s
N{
N    uint8_t                  uuid_type;               /**< UUID type for Service Base UUID. */
N    uint16_t                 service_handle;          /**< Handle of Service (as provided by the BLE stack). */
N    ble_gatts_char_handles_t tx_handles;              /**< Handles related to the TX characteristic. */
N    ble_gatts_char_handles_t rx_handles;              /**< Handles related to the RX characteristic. */
N    uint16_t                 conn_handle;             /**< Handle of the current connection (as provided by the BLE stack, is BLE_CONN_HANDLE_INVALID if not in a connection). */
N    bool                     is_notification_enabled; 
X    _Bool                     is_notification_enabled; 
N    ble_nus_data_handler_t   data_handler;            /**< Event handler to be called for handling received data. */
N} ble_nus_t;
N
N/**@brief Initialize the  Service.
N *
N * @param[out]  p_nus       Nordic UART Service structure. This structure will have to be supplied by
N *                          the application. It will be initialized by this function, and will later
N *                          be used to identify this particular service instance.
N * @param[in]   p_nus_init  Information needed to initialize the service.
N *
N * @return      NRF_SUCCESS on successful initialization of service, otherwise an error code.
N */
Nuint32_t ble_nus_init(ble_nus_t * p_nus, const ble_nus_init_t * p_nus_init);
N
N/**@brief Nordic UART Service BLE stack event handler.
N *
N * @details Handles all events from the BLE stack of interest to the Nordic UART Service.
N *
N * @note For the requirements in the nus specification to be fulfilled,
N *       ble_nus_battery_level_update() must be called upon reconnection if the
N *       battery level has changed while the service has been disconnected from a bonded
N *       client.
N *
N * @param[in]   p_nus      Nordic UART Service structure.
N * @param[in]   p_ble_evt  Event received from the BLE stack.
N */
Nvoid ble_nus_on_ble_evt(ble_nus_t * p_nus, ble_evt_t * p_ble_evt);
N
N/**@brief Send string. 
N *
N * @details The application calls this function to send a string to the peer device. 
N *
N *
N * @param[in]   p_nus          Nordic UART Service structure.
N * @param[in]   string         String to be sent.
N * @param[in]   length         Length of string. 
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t ble_nus_send_string(ble_nus_t * p_nus, uint8_t * string, uint16_t length);
N
N#endif // BLE_NUS_H__
N
N/** @} */
L 14 "..\..\..\Software\Source\ble_serv\ble_nus.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 410000
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 15 "..\..\..\Software\Source\ble_serv\ble_nus.c" 2
N#include "nordic_common.h"
L 1 "..\..\..\Software\Include\nordic_common.h" 1
N/* Copyright (c) 2008 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N */ 
N
N/** @file
N * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
N */
N
N#ifndef NORDIC_COMMON_H__
N#define NORDIC_COMMON_H__
N
N/** Swaps the upper byte with the lower byte in a 16 bit variable */
N//lint -emacro((572),SWAP) // Suppress warning 572 "Excessive shift value"
N#define SWAP(x) ((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
N
N/** The upper 8 bits of a 16 bit value */
N#define MSB(a) (((a) & 0xFF00) >> 8)
N/** The lower 8 bits (of a 16 bit value) */
N#define LSB(a) ((a) & 0xFF)
N
N/** Leaves the minimum of the two arguments */
N/*lint -emacro(506, MIN) */ /* Suppress "Constant value Boolean */ 
N#define MIN(a, b) ((a) < (b) ? (a) : (b))
N/** Leaves the maximum of the two arguments */
N/*lint -emacro(506, MAX) */ /* Suppress "Constant value Boolean */ 
N#define MAX(a, b) ((a) < (b) ? (b) : (a))
N
N#define BIT_0 0x01 /**< The value of bit 0 */
N#define BIT_1 0x02 /**< The value of bit 1 */
N#define BIT_2 0x04 /**< The value of bit 2 */
N#define BIT_3 0x08 /**< The value of bit 3 */
N#define BIT_4 0x10 /**< The value of bit 4 */
N#define BIT_5 0x20 /**< The value of bit 5 */
N#define BIT_6 0x40 /**< The value of bit 6 */
N#define BIT_7 0x80 /**< The value of bit 7 */
N#define BIT_8 0x0100 /**< The value of bit 8 */
N#define BIT_9 0x0200 /**< The value of bit 9 */
N#define BIT_10 0x0400 /**< The value of bit 10 */
N#define BIT_11 0x0800 /**< The value of bit 11 */
N#define BIT_12 0x1000 /**< The value of bit 12 */
N#define BIT_13 0x2000 /**< The value of bit 13 */
N#define BIT_14 0x4000 /**< The value of bit 14 */
N#define BIT_15 0x8000 /**< The value of bit 15 */
N#define BIT_16 0x00010000 /**< The value of bit 16 */
N#define BIT_17 0x00020000 /**< The value of bit 17 */
N#define BIT_18 0x00040000 /**< The value of bit 18 */
N#define BIT_19 0x00080000 /**< The value of bit 19 */
N#define BIT_20 0x00100000 /**< The value of bit 20 */
N#define BIT_21 0x00200000 /**< The value of bit 21 */
N#define BIT_22 0x00400000 /**< The value of bit 22 */
N#define BIT_23 0x00800000 /**< The value of bit 23 */
N#define BIT_24 0x01000000 /**< The value of bit 24 */
N#define BIT_25 0x02000000 /**< The value of bit 25 */
N#define BIT_26 0x04000000 /**< The value of bit 26 */
N#define BIT_27 0x08000000 /**< The value of bit 27 */
N#define BIT_28 0x10000000 /**< The value of bit 28 */
N#define BIT_29 0x20000000 /**< The value of bit 29 */
N#define BIT_30 0x40000000 /**< The value of bit 30 */
N#define BIT_31 0x80000000 /**< The value of bit 31 */
N
N#define UNUSED_VARIABLE(X)  ((void)(X))
N#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
N
N#endif // NORDIC_COMMON_H__
L 16 "..\..\..\Software\Source\ble_serv\ble_nus.c" 2
N#include "ble_srv_common.h"
N#include "app_util.h"
N
N/**@brief Connect event handler.
N *
N * @param[in]   p_nus       Nordic UART Service structure.
N * @param[in]   p_ble_evt   Event received from the BLE stack.
N */
Nstatic void on_connect(ble_nus_t * p_nus, ble_evt_t * p_ble_evt)
N{
N    p_nus->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
N}
N
N
N/**@brief Disconnect event handler.
N *
N * @param[in]   p_nus       Nordic UART Service structure.
N * @param[in]   p_ble_evt   Event received from the BLE stack.
N */
Nstatic void on_disconnect(ble_nus_t * p_nus, ble_evt_t * p_ble_evt)
N{
N    UNUSED_PARAMETER(p_ble_evt);
X    ((void)(p_ble_evt));
N    p_nus->conn_handle = BLE_CONN_HANDLE_INVALID;
X    p_nus->conn_handle = 0xFFFF;
N}
N
N
N/**@brief Write event handler.
N *
N * @param[in]   p_nus       Nordic UART Service structure.
N * @param[in]   p_ble_evt   Event received from the BLE stack.
N * p_evt_write->data stores the received datas from BLE stack, p_evt_write->len is the length of received datas
N */
Nstatic void on_write(ble_nus_t * p_nus, ble_evt_t * p_ble_evt)
N{  
N    ble_gatts_evt_write_t * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
N    
N    if (
N        (p_evt_write->handle == p_nus->rx_handles.cccd_handle)
N        &&
N        (p_evt_write->len == 2)
N    )
N    {
N        uint16_t value = *(uint16_t *) p_evt_write->data;
N        if (value == 0x001)   //judge if the service is added or not
N        {
N            p_nus->is_notification_enabled = true;
X            p_nus->is_notification_enabled = 1;
N        }
N        else
N        {
N            p_nus->is_notification_enabled = false;
X            p_nus->is_notification_enabled = 0;
N        }
N        
N    }
N    else if ((p_evt_write->handle == p_nus->tx_handles.value_handle) &&
N             (p_nus->data_handler != NULL))
X             (p_nus->data_handler != 0))
N    {
N        p_nus->data_handler(p_nus, p_evt_write->data, p_evt_write->len);
N			  
N    }
N}
N
Nvoid ble_nus_on_ble_evt(ble_nus_t * p_nus, ble_evt_t * p_ble_evt)
N{
N    switch (p_ble_evt->header.evt_id)
N    {
N        case BLE_GAP_EVT_CONNECTED:
N            on_connect(p_nus, p_ble_evt);
N            break;
N            
N        case BLE_GAP_EVT_DISCONNECTED:
N            on_disconnect(p_nus, p_ble_evt);
N            break;
N        
N        case BLE_GATTS_EVT_WRITE:   
N            on_write(p_nus, p_ble_evt);
N            break;
N            
N        default:
N            break;
N    }
N}
N
N
N/**@brief Add RX characteristic.
N *
N * @param[in]   p_nus        Nordic UART Service structure.
N * @param[in]   p_nus_init   Information needed to initialize the service.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nstatic uint32_t rx_char_add(ble_nus_t * p_nus, const ble_nus_init_t * p_nus_init)
N{
N    ble_gatts_char_md_t char_md;
N    ble_gatts_attr_md_t cccd_md;
N    ble_gatts_attr_t    attr_char_value;
N    ble_uuid_t          ble_uuid;
N    ble_gatts_attr_md_t attr_md;
N    
N    // Add Battery Level characteristic
N    memset(&cccd_md, 0, sizeof(cccd_md));
N
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
X    do {(&cccd_md . read_perm)->sm = 1; (&cccd_md . read_perm)->lv = 1;} while(0);
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.write_perm);
X    do {(&cccd_md . write_perm)->sm = 1; (&cccd_md . write_perm)->lv = 1;} while(0);
N    cccd_md.vloc = BLE_GATTS_VLOC_STACK;
X    cccd_md.vloc = 0x01;
N    
N    memset(&char_md, 0, sizeof(char_md));
N    
N    char_md.char_props.notify = 1;
N    char_md.p_char_user_desc  = NULL;
X    char_md.p_char_user_desc  = 0;
N    char_md.p_char_pf         = NULL;
X    char_md.p_char_pf         = 0;
N    char_md.p_user_desc_md    = NULL;
X    char_md.p_user_desc_md    = 0;
N    char_md.p_cccd_md         = &cccd_md;
N    char_md.p_sccd_md         = NULL;
X    char_md.p_sccd_md         = 0;
N    
N    ble_uuid.type = p_nus->uuid_type;
N    ble_uuid.uuid = BLE_UUID_NUS_RX_CHARACTERISTIC;
X    ble_uuid.uuid = 0x0003;
N    
N    memset(&attr_md, 0, sizeof(attr_md));
N
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
X    do {(&attr_md . read_perm)->sm = 1; (&attr_md . read_perm)->lv = 1;} while(0);
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
X    do {(&attr_md . write_perm)->sm = 1; (&attr_md . write_perm)->lv = 1;} while(0);
N    
N    attr_md.vloc       = BLE_GATTS_VLOC_STACK;
X    attr_md.vloc       = 0x01;
N    attr_md.rd_auth    = 0;
N    attr_md.wr_auth    = 0;
N    attr_md.vlen       = 1;
N    
N    memset(&attr_char_value, 0, sizeof(attr_char_value));
N
N    attr_char_value.p_uuid       = &ble_uuid;
N    attr_char_value.p_attr_md    = &attr_md;
N    attr_char_value.init_len     = sizeof(uint8_t);
N    attr_char_value.init_offs    = 0;
N    attr_char_value.max_len      = 20;
N    
N    return sd_ble_gatts_characteristic_add(p_nus->service_handle, &char_md,
N                                               &attr_char_value,
N                                               &p_nus->rx_handles);
N
N}
N
N/**@brief Add TX characteristic.
N *
N * @param[in]   p_nus        Nordic UART Service structure.
N * @param[in]   p_nus_init   Information needed to initialize the service.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nstatic uint32_t tx_char_add(ble_nus_t * p_nus, const ble_nus_init_t * p_nus_init)
N{
N    ble_gatts_char_md_t char_md;
N    ble_gatts_attr_t    attr_char_value;
N    ble_uuid_t          ble_uuid;
N    ble_gatts_attr_md_t attr_md;
N    
N    memset(&char_md, 0, sizeof(char_md));
N    
N    char_md.char_props.write  = 1;
N    char_md.p_char_user_desc  = NULL;
X    char_md.p_char_user_desc  = 0;
N    char_md.p_char_pf         = NULL;
X    char_md.p_char_pf         = 0;
N    char_md.p_user_desc_md    = NULL;
X    char_md.p_user_desc_md    = 0;
N    char_md.p_cccd_md         = NULL;
X    char_md.p_cccd_md         = 0;
N    char_md.p_sccd_md         = NULL;
X    char_md.p_sccd_md         = 0;
N    
N    ble_uuid.type = p_nus->uuid_type;
N    ble_uuid.uuid = BLE_UUID_NUS_TX_CHARACTERISTIC;
X    ble_uuid.uuid = 0x0002;
N    
N    memset(&attr_md, 0, sizeof(attr_md));
N
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
X    do {(&attr_md . read_perm)->sm = 1; (&attr_md . read_perm)->lv = 1;} while(0);
N    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
X    do {(&attr_md . write_perm)->sm = 1; (&attr_md . write_perm)->lv = 1;} while(0);
N    
N    attr_md.vloc       = BLE_GATTS_VLOC_STACK;
X    attr_md.vloc       = 0x01;
N    attr_md.rd_auth    = 0;
N    attr_md.wr_auth    = 0;
N    attr_md.vlen       = 1;
N    
N    memset(&attr_char_value, 0, sizeof(attr_char_value));
N
N    attr_char_value.p_uuid       = &ble_uuid;
N    attr_char_value.p_attr_md    = &attr_md;
N    attr_char_value.init_len     = 1;
N    attr_char_value.init_offs    = 0;
N    attr_char_value.max_len      = 20;
N    
N    return sd_ble_gatts_characteristic_add(p_nus->service_handle, &char_md,
N                                               &attr_char_value,
N                                               &p_nus->tx_handles);
N}
N
Nuint32_t ble_nus_init(ble_nus_t * p_nus, const ble_nus_init_t * p_nus_init)
N{
N    uint32_t   err_code;
N    ble_uuid_t ble_uuid;
N    ble_uuid128_t nus_base_uuid = {0x9E, 0xCA, 0xDC, 0x24, 0x0E, 0xE5, 0xA9, 0xE0, 0x93, 0xF3, 0xA3, 0xB5, 0x00, 0x00, 0x40, 0x6E};
N    
N    // Initialize service structure
N    p_nus->conn_handle = BLE_CONN_HANDLE_INVALID;
X    p_nus->conn_handle = 0xFFFF;
N    p_nus->data_handler = p_nus_init->data_handler;
N    p_nus->is_notification_enabled = false;
X    p_nus->is_notification_enabled = 0;
N    
N
N    // Add custom base UUID
N    err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_nus->uuid_type);
N    if (err_code != NRF_SUCCESS)
X    if (err_code != ((0x0) + 0))
N    {
N        return err_code;
N    }
N
N    // Add service
N    ble_uuid.type = p_nus->uuid_type;
N    ble_uuid.uuid = BLE_UUID_NUS_SERVICE;
X    ble_uuid.uuid = 0x0001;
N
N    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_nus->service_handle);
X    err_code = sd_ble_gatts_service_add(0x01, &ble_uuid, &p_nus->service_handle);
N    if (err_code != NRF_SUCCESS)
X    if (err_code != ((0x0) + 0))
N    {
N        return err_code;
N    }
N    
N	err_code = rx_char_add(p_nus, p_nus_init);
N	if (err_code != NRF_SUCCESS)
X	if (err_code != ((0x0) + 0))
N	{
N		return err_code;
N	}
N	
N	err_code = tx_char_add(p_nus, p_nus_init);
N	if (err_code != NRF_SUCCESS)
X	if (err_code != ((0x0) + 0))
N	{
N		return err_code;
N	}
N    
N	return NRF_SUCCESS;
X	return ((0x0) + 0);
N}
N
N
Nuint32_t ble_nus_send_string(ble_nus_t * p_nus, uint8_t * string, uint16_t length)
N{
N    ble_gatts_hvx_params_t hvx_params;
N    
N    if (!p_nus->is_notification_enabled)
N    {
N        return NRF_ERROR_INVALID_STATE;
X        return ((0x0) + 8);
N    }
N    
N    if (length > NUS_MAX_DATA_LENGTH)
X    if (length > 20)
N    {
N        return NRF_ERROR_INVALID_PARAM;
X        return ((0x0) + 7);
N    }
N    
N    memset(&hvx_params, 0, sizeof(hvx_params));
N    hvx_params.handle = p_nus->rx_handles.value_handle;
N    hvx_params.p_data = string;
N    hvx_params.p_len  = &length;
N    hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
X    hvx_params.type   = 0x01;
N    
N    return sd_ble_gatts_hvx(p_nus->conn_handle, &hvx_params);
N}

; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\output\simple_uart.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\simple_uart.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\Software\Include -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Device\Nordic\nRF51822\Include -DNRF51 -DBOARD_PCA10001 -DNRF51_DBG --omf_browse=.\output\simple_uart.crf ..\..\..\Software\Source\simple_uart\simple_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  simple_uart_get PROC
;;;19     
;;;20     uint8_t simple_uart_get(void)
000000  bf00              NOP      
                  |L1.2|
;;;21     {
;;;22       while (NRF_UART0->EVENTS_RXDRDY != 1)
000002  4842              LDR      r0,|L1.268|
000004  6880              LDR      r0,[r0,#8]
000006  2801              CMP      r0,#1
000008  d1fb              BNE      |L1.2|
;;;23       {
;;;24         // Wait for RXD data to be received
;;;25       }
;;;26       
;;;27       NRF_UART0->EVENTS_RXDRDY = 0;
00000a  2000              MOVS     r0,#0
00000c  493f              LDR      r1,|L1.268|
00000e  6088              STR      r0,[r1,#8]
;;;28       return (uint8_t)NRF_UART0->RXD;
000010  483f              LDR      r0,|L1.272|
000012  6980              LDR      r0,[r0,#0x18]
000014  b2c0              UXTB     r0,r0
;;;29     }
000016  4770              BX       lr
;;;30     
                          ENDP

                  simple_uart_get_with_timeout PROC
;;;31     bool simple_uart_get_with_timeout(int32_t timeout_ms, uint8_t *rx_data)
000018  b570              PUSH     {r4-r6,lr}
;;;32     {
00001a  4604              MOV      r4,r0
00001c  460d              MOV      r5,r1
;;;33       bool ret = true;
00001e  2601              MOVS     r6,#1
;;;34       
;;;35       while (NRF_UART0->EVENTS_RXDRDY != 1)
000020  e00a              B        |L1.56|
                  |L1.34|
;;;36       {
;;;37         if (timeout_ms-- >= 0)
000022  4620              MOV      r0,r4
000024  1e64              SUBS     r4,r4,#1
000026  2800              CMP      r0,#0
000028  db04              BLT      |L1.52|
;;;38         {
;;;39           // wait in 1ms chunk before checking for status
;;;40           nrf_delay_us(1000);
00002a  207d              MOVS     r0,#0x7d
00002c  00c0              LSLS     r0,r0,#3
00002e  f7fffffe          BL       __asm___13_simple_uart_c_5dda6715__nrf_delay_us
000032  e001              B        |L1.56|
                  |L1.52|
;;;41         }
;;;42         else
;;;43         {
;;;44           ret = false;
000034  2600              MOVS     r6,#0
;;;45           break;
000036  e003              B        |L1.64|
                  |L1.56|
000038  4834              LDR      r0,|L1.268|
00003a  6880              LDR      r0,[r0,#8]            ;35
00003c  2801              CMP      r0,#1                 ;35
00003e  d1f0              BNE      |L1.34|
                  |L1.64|
000040  bf00              NOP      
;;;46         }
;;;47       }  // Wait for RXD data to be received
;;;48     
;;;49       if (timeout_ms >= 0)
000042  2c00              CMP      r4,#0
000044  db05              BLT      |L1.82|
;;;50       {
;;;51         // clear the event and set rx_data with received byte
;;;52           NRF_UART0->EVENTS_RXDRDY = 0;
000046  2000              MOVS     r0,#0
000048  4930              LDR      r1,|L1.268|
00004a  6088              STR      r0,[r1,#8]
;;;53           *rx_data = (uint8_t)NRF_UART0->RXD;
00004c  4830              LDR      r0,|L1.272|
00004e  6980              LDR      r0,[r0,#0x18]
000050  7028              STRB     r0,[r5,#0]
                  |L1.82|
;;;54       }
;;;55     
;;;56       return ret;
000052  4630              MOV      r0,r6
;;;57     }
000054  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

                  simple_uart_put PROC
;;;59     void simple_uart_put(uint8_t cr)
000056  492e              LDR      r1,|L1.272|
;;;60     {
;;;61       NRF_UART0->TXD = (uint8_t)cr;
000058  61c8              STR      r0,[r1,#0x1c]
;;;62     
;;;63       while (NRF_UART0->EVENTS_TXDRDY!=1)
00005a  bf00              NOP      
                  |L1.92|
00005c  492b              LDR      r1,|L1.268|
00005e  69c9              LDR      r1,[r1,#0x1c]
000060  2901              CMP      r1,#1
000062  d1fb              BNE      |L1.92|
;;;64       {
;;;65         // Wait for TXD data to be sent
;;;66       }
;;;67     
;;;68       NRF_UART0->EVENTS_TXDRDY=0;
000064  2100              MOVS     r1,#0
000066  4a29              LDR      r2,|L1.268|
000068  61d1              STR      r1,[r2,#0x1c]
;;;69     }
00006a  4770              BX       lr
;;;70     
                          ENDP

                  simple_uart_putstring PROC
;;;71     void simple_uart_putstring(const uint8_t *str)
00006c  b530              PUSH     {r4,r5,lr}
;;;72     {
00006e  4603              MOV      r3,r0
;;;73       uint_fast8_t i = 0;
000070  2500              MOVS     r5,#0
;;;74       uint8_t ch = str[i++];
000072  4628              MOV      r0,r5
000074  1c6d              ADDS     r5,r5,#1
000076  5c1c              LDRB     r4,[r3,r0]
;;;75       while (ch != '\0')
000078  e005              B        |L1.134|
                  |L1.122|
;;;76       {
;;;77         simple_uart_put(ch);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       simple_uart_put
;;;78         ch = str[i++];
000080  4628              MOV      r0,r5
000082  1c6d              ADDS     r5,r5,#1
000084  5c1c              LDRB     r4,[r3,r0]
                  |L1.134|
000086  2c00              CMP      r4,#0                 ;75
000088  d1f7              BNE      |L1.122|
;;;79       }
;;;80     }
00008a  bd30              POP      {r4,r5,pc}
;;;81     
                          ENDP

                  simple_uart_config PROC
;;;82     void simple_uart_config(  uint8_t rts_pin_number,
00008c  b5f8              PUSH     {r3-r7,lr}
;;;83                               uint8_t txd_pin_number,
;;;84                               uint8_t cts_pin_number,
;;;85                               uint8_t rxd_pin_number,
;;;86                               bool hwfc)
;;;87     {
00008e  4607              MOV      r7,r0
000090  460c              MOV      r4,r1
000092  4615              MOV      r5,r2
000094  461e              MOV      r6,r3
;;;88       nrf_gpio_cfg_output(txd_pin_number);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       nrf_gpio_cfg_output
;;;89       nrf_gpio_cfg_input(rxd_pin_number, NRF_GPIO_PIN_NOPULL);  
00009c  2100              MOVS     r1,#0
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       nrf_gpio_cfg_input
;;;90     
;;;91       NRF_UART0->PSELTXD = txd_pin_number;
0000a4  481a              LDR      r0,|L1.272|
0000a6  60c4              STR      r4,[r0,#0xc]
;;;92       NRF_UART0->PSELRXD = rxd_pin_number;
0000a8  6146              STR      r6,[r0,#0x14]
;;;93     
;;;94       if (hwfc)
0000aa  9806              LDR      r0,[sp,#0x18]
0000ac  2800              CMP      r0,#0
0000ae  d00d              BEQ      |L1.204|
;;;95       {
;;;96         nrf_gpio_cfg_output(rts_pin_number);
0000b0  4638              MOV      r0,r7
0000b2  f7fffffe          BL       nrf_gpio_cfg_output
;;;97         nrf_gpio_cfg_input(cts_pin_number, NRF_GPIO_PIN_NOPULL);
0000b6  2100              MOVS     r1,#0
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       nrf_gpio_cfg_input
;;;98         NRF_UART0->PSELCTS = cts_pin_number;
0000be  4814              LDR      r0,|L1.272|
0000c0  6105              STR      r5,[r0,#0x10]
;;;99         NRF_UART0->PSELRTS = rts_pin_number;
0000c2  6087              STR      r7,[r0,#8]
;;;100        NRF_UART0->CONFIG  = (UART_CONFIG_HWFC_Enabled << UART_CONFIG_HWFC_Pos);
0000c4  2001              MOVS     r0,#1
0000c6  4912              LDR      r1,|L1.272|
0000c8  3140              ADDS     r1,r1,#0x40
0000ca  62c8              STR      r0,[r1,#0x2c]
                  |L1.204|
;;;101      }
;;;102    
;;;103      NRF_UART0->BAUDRATE         = (UART_BAUDRATE_BAUDRATE_Baud115200 << UART_BAUDRATE_BAUDRATE_Pos);
0000cc  4811              LDR      r0,|L1.276|
0000ce  4910              LDR      r1,|L1.272|
0000d0  6248              STR      r0,[r1,#0x24]
;;;104      NRF_UART0->ENABLE           = (UART_ENABLE_ENABLE_Enabled << UART_ENABLE_ENABLE_Pos);
0000d2  2004              MOVS     r0,#4
0000d4  6008              STR      r0,[r1,#0]
;;;105      NRF_UART0->TASKS_STARTTX    = 1;
0000d6  2001              MOVS     r0,#1
0000d8  490f              LDR      r1,|L1.280|
0000da  6088              STR      r0,[r1,#8]
;;;106      NRF_UART0->TASKS_STARTRX    = 1;
0000dc  6008              STR      r0,[r1,#0]
;;;107      NRF_UART0->EVENTS_RXDRDY    = 0;
0000de  2000              MOVS     r0,#0
0000e0  490a              LDR      r1,|L1.268|
0000e2  6088              STR      r0,[r1,#8]
;;;108    }
0000e4  bdf8              POP      {r3-r7,pc}
                          ENDP

                  nrf_gpio_cfg_output PROC
;;;120     */
;;;121    static __INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
0000e6  2101              MOVS     r1,#1
;;;122    {
;;;123        /*lint -e{845} // A zero has been given as right argument to operator '|'" */
;;;124        NRF_GPIO->PIN_CNF[pin_number] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
0000e8  2205              MOVS     r2,#5
0000ea  0712              LSLS     r2,r2,#28
0000ec  2307              MOVS     r3,#7
0000ee  021b              LSLS     r3,r3,#8
0000f0  18d2              ADDS     r2,r2,r3
0000f2  0083              LSLS     r3,r0,#2
0000f4  50d1              STR      r1,[r2,r3]
;;;125                                                | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
;;;126                                                | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
;;;127                                                | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
;;;128                                                | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;129    }
0000f6  4770              BX       lr
;;;130    
                          ENDP

                  nrf_gpio_cfg_input PROC
;;;140     */
;;;141    static __INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
0000f8  b510              PUSH     {r4,lr}
;;;142    {
;;;143        /*lint -e{845} // A zero has been given as right argument to operator '|'" */
;;;144        NRF_GPIO->PIN_CNF[pin_number] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
0000fa  008a              LSLS     r2,r1,#2
0000fc  2305              MOVS     r3,#5
0000fe  071b              LSLS     r3,r3,#28
000100  2407              MOVS     r4,#7
000102  0224              LSLS     r4,r4,#8
000104  191b              ADDS     r3,r3,r4
000106  0084              LSLS     r4,r0,#2
000108  511a              STR      r2,[r3,r4]
;;;145                                            | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
;;;146                                            | (pull_config << GPIO_PIN_CNF_PULL_Pos)
;;;147                                            | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
;;;148                                            | (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);
;;;149    }
00010a  bd10              POP      {r4,pc}
;;;150    
                          ENDP

                  |L1.268|
                          DCD      0x40002100
                  |L1.272|
                          DCD      0x40002500
                  |L1.276|
                          DCD      0x01d7e000
                  |L1.280|
                          DCD      0x40002000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Software\\Source\\simple_uart\\simple_uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_simple_uart_c_5dda6715____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_simple_uart_c_5dda6715____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_simple_uart_c_5dda6715____REVSH|
#line 130
|__asm___13_simple_uart_c_5dda6715____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_simple_uart_c_5dda6715__nrf_delay_us|
#line 8 "..\\..\\..\\Software\\Include\\nrf_delay.h"
|__asm___13_simple_uart_c_5dda6715__nrf_delay_us| PROC
#line 9

loop
 SUBS R0, R0, #1
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 BNE loop
 BX LR
	ENDP

;*** End   embedded assembler ***

; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\output\flash_ctrl.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\flash_ctrl.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\Software\Include -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Device\Nordic\nRF51822\Include -DNRF51 -DBOARD_PCA10001 -DNRF51_DBG --omf_browse=.\output\flash_ctrl.crf ..\..\..\Software\Source\sys_work_handle\flash_ctrl.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  flash_page_erase PROC
;;;28      */
;;;29     void flash_page_erase(uint32_t *page_address)
000000  2102              MOVS     r1,#2
;;;30     {
;;;31       // Turn on flash erase enable and wait until the NVMC is ready:
;;;32         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Een << NVMC_CONFIG_WEN_Pos);
000002  4a2a              LDR      r2,|L1.172|
000004  6051              STR      r1,[r2,#4]
;;;33         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000006  bf00              NOP      
                  |L1.8|
000008  4929              LDR      r1,|L1.176|
00000a  6809              LDR      r1,[r1,#0]
00000c  2900              CMP      r1,#0
00000e  d0fb              BEQ      |L1.8|
;;;34         {
;;;35             // Do nothing.
;;;36         }
;;;37         
;;;38         // Erase page:
;;;39         NRF_NVMC->ERASEPAGE = (uint32_t)page_address;
000010  4926              LDR      r1,|L1.172|
000012  6088              STR      r0,[r1,#8]
;;;40         
;;;41         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000014  bf00              NOP      
                  |L1.22|
000016  4926              LDR      r1,|L1.176|
000018  6809              LDR      r1,[r1,#0]
00001a  2900              CMP      r1,#0
00001c  d0fb              BEQ      |L1.22|
;;;42         {
;;;43             // Do nothing.
;;;44         }
;;;45         
;;;46         // Turn off flash erase enable and wait until the NVMC is ready:
;;;47         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos);
00001e  2100              MOVS     r1,#0
000020  4a22              LDR      r2,|L1.172|
000022  6051              STR      r1,[r2,#4]
;;;48         
;;;49         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000024  bf00              NOP      
                  |L1.38|
000026  4922              LDR      r1,|L1.176|
000028  6809              LDR      r1,[r1,#0]
00002a  2900              CMP      r1,#0
00002c  d0fb              BEQ      |L1.38|
;;;50         {
;;;51             // Do nothing.
;;;52         }
;;;53     }
00002e  4770              BX       lr
;;;54     
                          ENDP

                  flash_word_write PROC
;;;61      */
;;;62     void flash_word_write(uint32_t *address, uint32_t value)
000030  2201              MOVS     r2,#1
;;;63     {
;;;64         // Turn on flash write enable and wait until the NVMC is ready:
;;;65         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos);
000032  4b1e              LDR      r3,|L1.172|
000034  605a              STR      r2,[r3,#4]
;;;66         
;;;67         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000036  bf00              NOP      
                  |L1.56|
000038  4a1d              LDR      r2,|L1.176|
00003a  6812              LDR      r2,[r2,#0]
00003c  2a00              CMP      r2,#0
00003e  d0fb              BEQ      |L1.56|
;;;68         {
;;;69             // Do nothing.
;;;70         }
;;;71       
;;;72         *address = value;
000040  6001              STR      r1,[r0,#0]
;;;73       
;;;74         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000042  bf00              NOP      
                  |L1.68|
000044  4a1a              LDR      r2,|L1.176|
000046  6812              LDR      r2,[r2,#0]
000048  2a00              CMP      r2,#0
00004a  d0fb              BEQ      |L1.68|
;;;75         {
;;;76             // Do nothing.
;;;77         }
;;;78       
;;;79         // Turn off flash write enable and wait until the NVMC is ready:
;;;80         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos);
00004c  2200              MOVS     r2,#0
00004e  4b17              LDR      r3,|L1.172|
000050  605a              STR      r2,[r3,#4]
;;;81       
;;;82         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000052  bf00              NOP      
                  |L1.84|
000054  4a16              LDR      r2,|L1.176|
000056  6812              LDR      r2,[r2,#0]
000058  2a00              CMP      r2,#0
00005a  d0fb              BEQ      |L1.84|
;;;83         {
;;;84             // Do nothing.
;;;85         }
;;;86     }
00005c  4770              BX       lr
;;;87     
                          ENDP

                  flash_specword_write PROC
;;;88     void flash_specword_write(uint32_t *address, uint8_t offset, uint32_t data)
00005e  b5f0              PUSH     {r4-r7,lr}
;;;89     {
000060  b0ff              SUB      sp,sp,#0x1fc
000062  b0ff              SUB      sp,sp,#0x1fc
000064  b082              SUB      sp,sp,#8
000066  4605              MOV      r5,r0
000068  460e              MOV      r6,r1
00006a  4617              MOV      r7,r2
;;;90         uint32_t backup[256];
;;;91         uint32_t i;
;;;92         
;;;93         for(i = 0; i < 256; i++ )
00006c  2400              MOVS     r4,#0
00006e  e005              B        |L1.124|
                  |L1.112|
;;;94         {
;;;95             backup[i] = *(address + i);
000070  00a0              LSLS     r0,r4,#2
000072  5828              LDR      r0,[r5,r0]
000074  00a1              LSLS     r1,r4,#2
000076  466a              MOV      r2,sp
000078  5050              STR      r0,[r2,r1]
00007a  1c64              ADDS     r4,r4,#1              ;93
                  |L1.124|
00007c  2cff              CMP      r4,#0xff              ;93
00007e  d9f7              BLS      |L1.112|
;;;96         }
;;;97         
;;;98         flash_page_erase(address);
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       flash_page_erase
;;;99         
;;;100        backup[offset] = data;
000086  00b0              LSLS     r0,r6,#2
000088  4669              MOV      r1,sp
00008a  500f              STR      r7,[r1,r0]
;;;101        
;;;102        for(i = 0; i < 256; i++ )
00008c  2400              MOVS     r4,#0
00008e  e007              B        |L1.160|
                  |L1.144|
;;;103        {
;;;104            flash_word_write((address + i), backup[i]);
000090  00a2              LSLS     r2,r4,#2
000092  466b              MOV      r3,sp
000094  5899              LDR      r1,[r3,r2]
000096  00a2              LSLS     r2,r4,#2
000098  1950              ADDS     r0,r2,r5
00009a  f7fffffe          BL       flash_word_write
00009e  1c64              ADDS     r4,r4,#1              ;102
                  |L1.160|
0000a0  2cff              CMP      r4,#0xff              ;102
0000a2  d9f5              BLS      |L1.144|
;;;105        }
;;;106           
;;;107    }
0000a4  b07f              ADD      sp,sp,#0x1fc
0000a6  b07f              ADD      sp,sp,#0x1fc
0000a8  b002              ADD      sp,sp,#8
0000aa  bdf0              POP      {r4-r7,pc}
;;;108    
                          ENDP

                  |L1.172|
                          DCD      0x4001e500
                  |L1.176|
                          DCD      0x4001e400

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Software\\Source\\sys_work_handle\\flash_ctrl.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_flash_ctrl_c_f146e052____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_flash_ctrl_c_f146e052____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_flash_ctrl_c_f146e052____REVSH|
#line 130
|__asm___12_flash_ctrl_c_f146e052____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
